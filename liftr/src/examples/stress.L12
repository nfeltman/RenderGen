let 
	@next {
		datatype comp = LT | EQ | GT
	}
	val next{compare} = next {
		fn (i,j) : int * int => if i < j then LT else if i == j then EQ else GT
	}
	@ mono { 
		datatype list = Empty | Cons of int * list
	} @ mono { 
		rec partition ((p,l) : int*list) : (int*list*list) = 
			case unroll l of 
			  _ => (0,Empty, Empty) 
			| (h,t) => 
				let val (s,left,right) = partition (p,t) in 
				if h<p then (s+1,Cons(h,left),right) else (s,left,Cons(h,right))
	}

	rec qs ((mono{l},next{i}) : ^list * $int) : $int = 
		case pushS mono {unroll l} of 
		  _ => next {0} 
		| mono{ht} => 
			let 
				val mono{(n,left,right)} = mono{partition ht}
				val next{n} = hold mono{n}
			in
			next { 
				case unroll (compare (i,n)) of
				  _ => prev{qs (mono{left},next{i})}
				| _ => prev{hold mono{#1 ht}}
				| _ => prev{qs (mono{right},next{(i-n)-1})}
			}

	@next{
		datatype list2 = Empty2 | Cons2 of int * list2
	}

	fun map ((f,l,next{q}) : (^list*$int -> $int) * ^list * $list2) = 
		next {
			let	
				rec m (q : list2) : list2 = 
					case unroll q of
					  _ => Empty2
					| (h,t) => Cons2 (prev{f (l,next{h})}, m t)
			in m q
		}

	val mono{c} = mono{Cons}
	val testlist = mono{c(8,c(2,c(3,c(7,c(4,c(5,Empty))))))}

	val next{c} = next{Cons2}
	val queries = next{c(0,c(1,c(2,c(3,c(4,c(5,Empty2))))))}		
in 
map (qs, testlist, queries)