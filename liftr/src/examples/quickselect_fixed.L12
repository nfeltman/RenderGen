let 
	@next {
		datatype comp = LT | EQ | GT
	}
	val next{compare} = next {
		fn (i,j) : int * int => if i < j then LT else if i == j then EQ else GT
	}
	@ mono { 
		datatype list = Empty | Cons of int * list
	} @ mono { 
		rec partition ((p,l) : int*list) : (int*list*list) = 
			case unroll l of 
			  _ => (0,Empty, Empty) 
			| (h,t) => 
				let val (s,left,right) = partition (p,t) in 
				if h<p then (s+1,Cons(h,left),right) else (s,left,Cons(h,right))
	}

	rec qs ((mono{l},next{i}) : ^list * $int) : $int = 
		case pushS mono {unroll l} of 
		  _ => next {0} 
		| mono{ht} => 
			let 
				val mono{(n,left,right)} = mono{partition ht}
				val next{n} = hold mono{n}
			in
			next { 
				case unroll (compare (i,n)) of
				  _ => prev{qs (mono{left},next{i})}
				| _ => prev{hold mono{#1 ht}}
				| _ => prev{qs (mono{right},next{(i-n)-1})}
			}

	val mono{c} = mono{Cons}
	val testlist = mono{c(8,c(2,c(3,c(7,c(4,c(5,Empty))))))}
in 
qs (testlist, next{2})