let 
	@ mono { datatype list = Empty | Cons of int * list }
	datatype listU = EmptyU | ConsU of ^int * ^list 
	
	fun unwrap (mono{l} : ^list) =
		case pushS mono{unroll l} of 
		  _ => EmptyU 
		| mono{(h,t)} => ConsU (mono{h}, mono{t})

	fun partition ((mono{p}, mono{l}) : ^int*^list) =
		let 
			@ mono { 
				rec part ((p,l) : int*list) : (int*list*list) = 
					case unroll l of 
					  _ => (0,Empty, Empty) 
					| (h,t) => 
						let val (s,left,right) = part (p,t) in 
						if h<p then (s+1,Cons(h,left),right) else (s,left,Cons(h,right))
			}
			val mono{(n,left,right)} = mono{part (p,l)} 
		in
		(mono{n},mono{left},mono{right})

	rec qs ((l,next{i}) : ^list * $int) : $int = 
		case unroll (unwrap l) of 
		  _ => next {0} 
		| (h,t) => 
			let 
				val (n,left,right) = partition (h,t)
				val next{n} = hold n
			in
			next { 
				if i < n then prev{qs (left,next{i})}
				else if i == n then prev{hold h}
				else prev{qs (right,next{(i-n)-1})}
			}

	val mono{c} = mono{Cons}
	val testlist = mono{c(8,c(2,c(3,c(7,c(4,c(5,Empty))))))}
in 
qs (testlist, next{2})