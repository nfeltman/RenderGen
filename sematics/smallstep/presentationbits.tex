%beginlit
\documentclass{article}

\usepackage{amsmath}
\usepackage{proof}
\usepackage{mathpartir}
\usepackage{mathabx}
\usepackage{bbm}
\usepackage[usenames,dvipsnames]{color}

\pagenumbering{gobble}

\newcommand {\next}{asdlfkj}
\input{macros}

\newcommand{\calp}{\mathcal{P}}
\newcommand{\overn}[1][]{\overline {n_{#1}}}
\newcommand{\steps}{\hookrightarrow}
\newcommand{\stepsone}{\rightbarharpoon}
\newcommand{\stepstwo}{\barrightharpoon}

\newcommand{\bit}[1]{\noindent{#1}:\\}

\begin{document}
%endlit

\bit{Intro1}
%beginbit
\[ 
\calp \val 
\]
%endbits

\bit{Intro2}
%beginbit
\[
	\calp \steps \calp'
\]
%endbit

\bit{Intro3}
%beginbit
\[
	\calp_1 \steps \calp_2 \steps \cdots \steps \calp' 
	\text{ where } \calp \val
\]
%endbit

\bit{Intro4}
%beginbit
\[
	\calp_1 \steps \calp_2 \steps \cdots
\]
%endbit

\bit{Examples1}
%beginbit 
\[
	1+\pi_1(2+3,4) \steps 1+\pi_1(5,4) \steps 1+5 \steps 6
\]
%endbit

\bit{Examples2}
%beginbit
\[
(\lambda x. x+x)(4+5)\steps (\lambda x.x+x) 9 \steps 9+9 \steps 18
\]
%endbit

\bit{Value Rules}
%beginbit
\begin{mathpar}
\infer{\overn \val}{\cdot} \and
\infer{\lambda x.e \val}{\cdot} \and
\infer{(v_1,v_2) \val}{v_1 \val & v_2 \val}
\end{mathpar}
%endbit

\bit{Beta Rules}
%beginbit
\begin{mathpar}
\infer{\overn [1] + \overn [2] \steps \overn [3]}{n_1 + n_2 = n_3} \and
\infer{(\lambda x.e) v \steps [v/x] e}{v \val} \\
\infer{\pi_1(v_1,v_2) \steps v_1}{(v_1,v_2) \val} \and
\infer{\pi_2(v_1,v_2) \steps v_2}{(v_1,v_2) \val}
\end{mathpar}
%endbit

\bit{Substep Rules}
%beginbit
\begin{mathpar}
\infer{e_1 + e_2 \steps e_1' + e_2}{e_1 \steps e_1'} \and
\infer{\overn[1] + e_2 \steps \overn[1] + e_2'}{e_2 \steps e_2'} \and
\infer{e_1~e_2 \steps e_1'~e_2}{e_1 \steps e_1'} \and
\infer{(\lambda x.e)~e_2 \steps (\lambda x.e)~e_2'}{e_2 \steps e_2'} \and
\infer{\pi_1 e \steps \pi_1 e'}{e \steps e'}\and
\infer{\pi_2 e \steps \pi_2 e'}{e \steps e'}
\end{mathpar}
%endbit

\bit{Progress Bad}
%beginbit
\[
\text{For all terms } e \text{, either } e \val \text{ or } e \steps e'
\]
%endbit

\bit{Counterexample}
%beginbit
\[
(1,2)+3
\]
%endbit

\bit{Progress}
%beginbit
\[
\text{For all terms } e:A \text{, either } e \val \text{ or } e \steps e'
\]
%endbit

\bit{Preservation}
%beginbit
\[
\text{For all terms } e:A \text{, if } e \steps e' \text{ then } e':A
\]
%endbit

\bit{Intro Multistage}
%beginbit
\[
\calp \stepsone \cdots \stepsone \calp' \stepstwo \cdots \stepstwo \calp'' 
\text{ where } \calp' \pval \text{ and } \calp'' \fval
\]
%endbit

\bit{L12 Judgments}
%beginbit
\[
\begin{array}{llll}
e \stepsone e'~@~\bbonem 
& e \pval~@~\bbonem 
& e \stepstwo e'~@~\bbonem 
& e \fval~@~\bbonem \\
e \stepsone e'~@~\bbtwo 
& e \pval~@~\bbtwo 
& e \stepstwo e'~@~\bbtwo 
& e \fval~@~\bbtwo \\
\end{array}
\]
%endbit 

\bit{Partial Values}
%beginbit
\begin{mathpar}
\infer{\overn \pval~@~\bbonem}{\cdot} \and
\infer{\lambda x.e \pval~@~\bbonem}{\cdot} \and
\infer{(e_1,e_2) \pval~@~\bbonem}{e_1 \pval~@~\bbonem & e_2 \pval~@~\bbonem} \and
\infer{\next~e \pval~@~\bbonem}{e \pval~@~\bbtwo} \and
\infer{\overn \pval~@~\bbtwo}{\cdot} \and
\infer{e_1 + e_2 \pval~@~\bbtwo}{e_1 \pval~@~\bbtwo & e_2 \pval~@~\bbtwo} \and
\infer{\lambda x.e \pval~@~\bbtwo}{e \pval~@~\bbtwo} \and
\infer{x \pval~@~\bbtwo}{\cdot} \and
\infer{e_1~e_2 \pval~@~\bbtwo}{e_1 \pval~@~\bbtwo & e_2 \pval~@~\bbtwo} \and
\infer{(e_1,e_2) \pval~@~\bbtwo}{e_1 \pval~@~\bbtwo & e_2 \pval~@~\bbtwo} \and
\infer{\pi_1e \pval~@~\bbtwo}{e \pval~@~\bbtwo} \and
\infer{\pi_2e \pval~@~\bbtwo}{e \pval~@~\bbtwo} 
\end{mathpar}
%endbit

\bit{Typing Form}
%beginbit
\begin{align*}
&\typeswor {e} A\text{, where} \\
&~e \text{ is a term} \\
&~A \text{ is a type} \\
&~w \text{ is a world (\bbone\ or \bbtwo)}
\end{align*}
%endbit

\bit{Typing Versions}
%beginbit
\begin{mathpar}
\typesone {e} A \and
\typestwo {e} A
\end{mathpar}
%endbit

\bit{Int Typing}
%beginbit
\begin{mathpar}
\infer{\typeswor {\overn} \rmint}{\cdot} \and
\infer{\typeswor {e_1 + e_2} \rmint}{\typeswor {e_1} \rmint & \typeswor {e_2} \rmint} \and
\infer{\typestwo {\pause~e} \rmint}{\typesone e \rmint}
\end{mathpar}
%endbit

\bit{Tuple Typing}
%beginbit
\begin{mathpar}
\infer{\typeswor {(e_1, e_2)} {A \times B}}{\typeswor {e_1} A & \typeswor {e_2} B} \\
\infer{\typeswor {\#1~e} A}{\typeswor e {A \times B}} \and
\infer{\typeswor {\#2~e} B}{\typeswor e {A \times B}}
\end{mathpar}
%endbit

\bit{Next/Prev Typing}
%beginbit
\begin{mathpar}
\infer{\typesone {\next~e} {\fut A}}{\typestwo e A} \and
\infer{\typestwo {\prev~e} A}{\typesone e {\fut A}}
\end{mathpar}
%endbit

\bit{Function Typing}
%beginbit
\begin{mathpar}
\infer{\typeswor {\lambda x:A. e} {A \to B}}{\typeswor [, \colwor x A] e B} \and
\infer{\typeswor {e_1~e_2} B}{\typeswor {e_1} {A \to B} & \typeswor {e_2} A}
\end{mathpar}
%endbit

\bit{Splitting Construction}
%beginbit
\begin{align*}
&e \splittwosym \{p | l.r\} \text{, where} \\
&\types [\cdot] p \tau \text{ is a monostage term} \\
&\types [l:\tau] r A \text{ is a type}
\end{align*}
%endbit

\bit{Simple Splitting}
%beginbit
\begin{align*}
&\text{if } \typestwo e A \text{, then} \\
&e \splittwosym \{p | l.r\} \text{, such that} \\
&\types [\cdot] p \tau \text{ is a monostage term} \\
&\types [l:\tau] r A \text{ is a type}
\end{align*}
%endbit

%beginlit
\end{document}
%endlit
