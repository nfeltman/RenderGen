\documentclass[11pt]{article}
\usepackage{amsmath}
\usepackage{bbm}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{mathpartir}
\usepackage{amssymb,amsthm}
\usepackage[margin=1in,nohead]{geometry}
\parindent 0pt
\parskip .75em

% bnf stuff
\newcommand {\myit} [1]{\operatorname{\it{#1}}}
\newcommand {\stage} {\langle\mathit{stage}\rangle}
\newcommand {\typeo} {\langle\bbone\text{-}\mathit{type}\rangle}
\newcommand {\expro} {\langle\bbone\text{-}\mathit{exp}\rangle}
\newcommand {\typet} {\langle\bbtwo\text{-}\mathit{type}\rangle}
\newcommand {\exprt} {\langle\bbtwo\text{-}\mathit{exp}\rangle}
\newcommand {\var} {\langle\mathit{var}\rangle}
\newcommand {\context} {\langle\mathit{cont}\rangle}
\newcommand {\gbar} {~~|~~}
\newcommand {\fut} {\bigcirc}

% nodes
\newcommand {\bbone} {\mathbbm 1}
\newcommand {\bbtwo} {\mathbbm 2}
\newcommand {\at} {{\tt~@~}}
\newcommand {\pause} {{\tt save}}
\newcommand {\next} {{\tt next}}
\newcommand {\prev} {{\tt prev}}
\newcommand {\gds} {{\Gamma \vdash^\sigma}}
\newcommand {\gdo} {{\Gamma \vdash^\bbone}}
\newcommand {\gdt} {{\Gamma \vdash^\bbtwo}}
\newcommand {\letin} [3] {{\tt let}~{#1} = {#2}~{\tt in}~{#3}}
\newcommand {\caseof} [3] {{\tt case}~{#1} ~{\tt of}~{#2}~{\tt |}~{#3}}
\newcommand {\tallcase} [3] {\begin{array}{l} {\tt case}~{#1} ~{\tt of}\\~~{#2}\\{\tt |}~{#3} \end{array}}

% transitions
\newcommand {\splito} {\overset{\bbone}\rightsquigarrow}
\newcommand {\splits} {\overset{\bbtwo}\rightsquigarrow}

% Equation spacing
\newcommand {\inferenceSpacing}{\setlength{\jot}{1.8ex}}
\newcommand {\normalSpacing}{\setlength{\jot}{1ex}}
\newcommand {\tab}{~~~~~~}

%language names
\newcommand {\lang} {$\lambda^{\bbone\bbtwo}$}
\newcommand {\wstage} {\textsc{Stag}}
\newcommand {\wostage} {\textsc{Doe}}

\title{\Large\textbf{Staging as a Mechanism for Algorithm Derivation}}
\author{Nicolas Feltman}
\begin{document}
\maketitle

\section{Introduction}

Add intro in a bit.

\section{\lang~Definition}
\label{sec:def}

In this section I define \lang, a two-stage language.  Throughout this document, I will use $\bbone$ and $\bbtwo$ to refer to the two stages.  A grammer for the terms, types, and contexts of \lang\ is shown in Figure \ref{fig:gram}.  Although both stages of \lang\ contain products, sums, and functions, I have chosen to seperate the stages syntactically to emphasize that this need not be the case.

You'll notice that there are three seperate mechanisms by which one stage can refer to another: $\next$, $\prev$, and $\pause$.  Specifically, $\next$ allows a stage $\bbone$ term to reference computation that will occur in the future, at stage $\bbtwo$, whereas $\prev$ and $\pause$ allow a stage $\bbtwo$ computation to refer back to stage $\bbone$.  The precise meaning of these constructs will be explored in future sections.

\section{Typing}

The rules relating types and terms are given in Figure \ref{fig:staging}.  The structure of the core typing judgement is entirely standard.  The nullary terms (currently just the unit value) are all explicitly annotated with a stage.  The non-nullary terms essentially preserve the stage of their inputs, except for $\pause$, which transtions an expression from $\bbone$ to $\bbtwo$.  From this, it is apparent that a stage $\bbone$ term cannot depend on any stage $\bbtwo$ terms.  This property can be justified by the notion that the program gets ``more reduced'' as time goes on, and that a term can be no more reduced than those it depends on.

\wstage~has one additional peculiar feature.  The predicate of a case statement can be stage $\bbtwo$ while the branches have subterms with stage $\bbone$.  This implies that some computation in a branch must be performed even before we know which branch to take.  This feature, called {\it speculation}, will be explored more later.

\begin{figure}
\caption{\wstage~Grammar}
\label{fig:gram}
\centering
\begin{align*}
\typeo &= \text{unit} \\
&\gbar \typeo \times \typeo \\
&\gbar \typeo + \typeo \\
&\gbar \typeo \to \typeo \\
&\gbar \fut \typet \\
\typet &= \text{unit} \\
&\gbar \typet \times \typeo \\
&\gbar \typet + \typet \\
&\gbar \typet \to \typet \\
\expro &= \lambda \var.\expro \\
&\gbar \var \\
&\gbar \expro~\expro \\
&\gbar () \\
&\gbar (\expro, \expro) \\
&\gbar \pi_1~\expro \gbar \pi_2~\expro \\
&\gbar \iota_1~\expro \gbar \iota_2~\expro \\
&\gbar {\tt case}~\expro ~{\tt of}~\var.\expro~{\tt `|}\text{'}~\var.\expro \\
&\gbar \next~\exprt \\
\exprt &= \lambda \var.\exprt \\
&\gbar \var \\
&\gbar \exprt~\exprt \\
&\gbar () \\
&\gbar (\exprt, \exprt) \\
&\gbar \pi_1~\exprt \gbar \pi_2~\exprt \\
&\gbar \iota_1~\exprt \gbar \iota_2~\exprt \\
&\gbar {\tt case}~\exprt ~{\tt of}~\var.\exprt~{\tt `|}\text{'}~\var.\exprt \\
&\gbar \pause~\expro \\
&\gbar \prev~\expro \\
\context &= \cdot \\
&\gbar \context, \var : \typeo ^\bbone \\
&\gbar \context, \var : \typet ^\bbtwo
\end{align*}
\end{figure}

\begin{figure}
\caption{Typing Rules}
\label{fig:staging}
\inferenceSpacing
\begin{gather}
\infer {\gds () : \text{unit}}{\cdot} \\
\infer {\gds (e_1,e_2) : A\times B}{\gds e_1 : A & \gds e_2 : B} \\
\infer {\gds \pi_1~e : A}{\gds e : A\times B} \\
\infer {\gds \pi_2~e : B}{\gds e : A\times B} \\
\infer {\gds (\lambda x:A.e) : A \to B}{\Gamma,x:A^\sigma \vdash e : B} \\
\infer {\gds x : A}{x : A^\sigma \in \Gamma} \\
\infer {\gds e_1~e_2 : B}{\gds e_1 : A \to B & \gds e_2 : A} \\
\infer {\Gamma \vdash^\bbtwo \pause~e : A}{\Gamma \vdash^\bbone e : A} \\
\infer {\Gamma \vdash^\bbone \next~e : \fut A}{\Gamma \vdash^\bbtwo e : A} \\
\infer {\Gamma \vdash^\bbtwo \prev~e : A}{\Gamma \vdash^\bbone e : \fut A} 
%\infer {\gds \letin {x}{e_1}{e_2} : B}{\gds e_1 : A & \Gamma,x:A^\sigma \vdash B : e_2} \\
%\infer {\gds \iota_1~e : A+B}{\gds e : A} \\
%\infer {\gds \iota_2~e : A+B}{\gds e : B} \\
%\infer {\gds \caseof {e_1}{x_2.e_2}{x_3.e_3} : C}{\gds e_1 : A+B & \Gamma,x_2:A^\sigma \vdash^\sigma e_2 : C & \Gamma,x_3:B^\sigma \vdash^\sigma e_3 : C} 
\end{gather}
\end{figure}

\subsection{Evaluation}
The evaluation is given in Figure \ref{fig:eval}.  Were it complete, it would contain a definition of values (which we predict to be unchanged by the staging system), and a big-step sematics relating terms to values.  The big-step evaluation should be indexed by the stage at which it completes.  That is, we have both $\Downarrow_\bbone$ and $\Downarrow_\bbtwo$.  Also, the bigstep semantics will reflect that speculation occurs down both branches of a case as part of  $\Downarrow_\bbone$ reduction.

\newcommand {\downsig} {\Downarrow_\sigma} 
\newcommand {\downone} {\Downarrow_\bbone} 
\newcommand {\downtwo} {\Downarrow_\bbtwo} 
\newcommand {\downp} {\Downarrow_p} 
\begin{figure}
\caption{Typing Rules}
\label{fig:eval}
\inferenceSpacing
\begin{gather}
\infer {()_\sigma \downsig ()}{\cdot} \\
\infer {f~e \downsig v' }{e \downsig v & f~v \Downarrow v'} \\
\infer {\pi_1~e \downsig v_1 }{e \downsig (v_1, v_2)} \\
\infer {\pi_2~e \downsig v_2 }{e \downsig (v_1, v_2)} \\
\infer {\iota_1~e \downsig \iota_1~v}{e \downsig v} \\
\infer {\iota_2~e \downsig \iota_2~v}{e \downsig v} \\
\infer { (e_1,e_2) \downsig (v_1, v_2)}{e_1 \downsig v_1 & e_2 \downsig v_2} \\
\infer {\letin {x}{e_1}{e_2} \downsig v_2}{e_1 \downsig v_1 & [v'/x] e_2 \downsig v_2} \\
\infer {\letin {x}{e_1}{e_2} \downp v_2}{e_1 \downone v_1 & [v'/x] e_2 \downp v_2} \\
\infer {\letin {x}{e_1}{e_2} \downp \letin {x}{v_1}{v_2}}{e_1 \downp v_1 & e_2 \downp v_2} \\
\infer {\caseof {e}{x_1.e_1}{x_2.e_2} \downsig v}{e \downsig (\iota_i~v) & [v/x_i]e_i \downsig v} \\
\infer {\caseof {e}{x_1.e_1}{x_2.e_2} \downp v}{e \downone (\iota_i~v) & [v/x_i]e_i \downp v} \\
\infer {\caseof {e}{x_1.e_1}{x_2.e_2} \downp \caseof {v}{x_1.v_1}{x_2.v_2}}{e \downp v & e_1 \downp v_1 & e_2 \downp v_2} \\
\infer {\pause~e \downtwo }{e : A\at\bbone}
\end{gather}
\end{figure}

\subsection{Stage Splitting}

The core operation of interest is the process of ``stage splitting," wherein a term with stage $\bbtwo$ is converted to a precomputed part, and a residual that depends on that precomputed part.  Specifically, we introduce a judgement ``$\Gamma \vdash e \splits [p,x.r]$'', which can be read ``under the context $\Gamma$, $e$ stage-splits into a precomputation $p$, and a residual $r$ which is open on $x$''.  The idea is that $p$ contains the parts of $e$ that are stage $\bbone$, $r$ contains the parts of $e$ that are stage $\bbtwo$, and the reduced value of $p$ is bound to $x$ when evaluating $r$. 

Note that the precomputation and residual are not actually terms in \wstage.  They are terms in a simpler language, called \wostage, which is essentially \wstage~without the staging constructs.  The grammar for \wostage~is shown in Figure \ref{fig:gram2}.  The typing rules for \wostage~are not shown, but can be guessed.


The full rules for splitting are shown in Figure \ref{fig:splitting}.  In two of the rules, I reference another judgement, of the form ``$\Gamma \vdash e \splito e'$''.  This means that the one-stage \wstage~term $e$ simply translates to a \wostage~term $e'$.  There are no surprises in how this works, so the details are omitted.

Even without a semantics done, we can think of two theorems that should hold true of stage splitting.  Namely, that good types in lead to good types out.  Explicitly:

\begin{center}
\begin{tabular}{lll}
If $\Gamma \vdash e:\tau \at \bbone$ &~~~~~~~~~~~~~~ & If $\Gamma \vdash e:\tau \at \bbtwo$ \\
then $\Gamma \vdash e \splito e'$ && then $\Gamma \vdash e \splits [p,x.r]$ \\
and $\Gamma \vdash e':\tau$ && and $\Gamma_\bbone \vdash p:\tau'$\\
 && and $\Gamma_\bbtwo, x:\tau' \vdash r:\tau$
\end{tabular}
\end{center}
Note that I'm implicitly abusing the identical structures of pretypes in \wstage~and types in \wostage.  Also, for any stage $\sigma$, we define $\Gamma_\sigma$ as,
\begin{align}
(\cdot)_\sigma &= \cdot \\
(\Gamma,x:\tau\at\sigma)_\sigma &= \Gamma_\sigma, \tau \\
(\Gamma,x:\tau\at\sigma')_\sigma &= \Gamma_\sigma &\text{where } \sigma \not= \sigma'
\end{align}

\begin{figure*}
\caption{Basic Splitting}
\label{fig:splitBasic}
\inferenceSpacing
\begin{gather}
\infer {\gdo \next~e : \fut A \splito [((),p),l.r]}{\gdt e : A\splits [p,l.r] } \\
\infer {\gdt \prev~e : A\splits [\pi_2~c,l.r] }{\gdo e : \fut A \splito [c,l.r]} \\
\infer {\gdt \pause~e : A \splits [e,l.l]}{\gdo e : A& A \text{~transferable}} 
\end{gather}
\end{figure*}


\begin{figure*}
\caption{Product Splitting}
\label{fig:splitProduct}
\inferenceSpacing
\begin{gather}
\infer {\gdo () : \text{unit} \splito [((),()),\_.()]}{\cdot} \\
\infer {\gdo (e_1,e_2) : A\times B \splito [((\pi_1 c, \pi_1 c),(\pi_2 c_1, \pi_2 c_2)), l.(\letin{l_1}{\pi_1 l}{r_1},\letin{l_2}{\pi_2 l}{r_2})] }
	{ \gdo e_1 : A \splito [c_1,l_1.r_1] 
	&\gdo e_2 : B \splito [c_2,l_2.r_2]} \\
\infer {\gdo \pi_1~e : A \splito [(\pi_1~p),l.\pi_1~r] }{\gdo e : A\times B \splito [c,l.r] } \\
\infer {\gdo \pi_2~e : B \splito [\pi_2~p,l.\pi_2~r] }{\gdo e : A\times B \splito [c,l.r]} \\
\infer {\gdt () : \text{unit} \splits [(),\_.()]}{\cdot} \\
\infer {\gdt (e_1,e_2) : A\times B \splits [(p_1,p_2), l.(\letin{l_1}{\pi_1~l}{r_1},\letin{l_2}{\pi_2~l}{r_2})] }
	{ \gdt e_1 : A \splits [p_1,l_1.r_1] 
	&\gdt e_2 : B \splits [p_2,l_2.r_2]} \\
\infer {\gdt \pi_1~e : A \splits [p,l.\pi_1~r] }{\gdt e : A\times B \splits [p,l.r] } \\
\infer {\gdt \pi_2~e : B \splits [p,l.\pi_2~r] }{\gdt e : A\times B \splits [p,l.r]} 
\end{gather}
\end{figure*}

\begin{figure*}
\caption{Function Splitting}
\label{fig:splitFunction}
\inferenceSpacing
\begin{gather}
\infer {\gdo x : A\splito [(x,()),\_.x]}{x : A^\bbone \in \Gamma} \\
\infer {\gdo (\lambda x:A.e) : A \to B \splito [(\lambda x:|A|_\bbone.c,()),\_.(\lambda (x,l):|A|_\bbtwo\times \tau.r)]}
	{\Gamma,x:A^\bbone \vdash e : B \splito [c,l.r]} \\
\infer {\gdo e_1~e_2 : B \splito 
	\left[ \begin{array}{l}\letin{y}{(\pi_1 c_1) (\pi_1 c2)}{(\pi_1 y,(\pi_2 c_1,\pi_2 c_2, \pi_2 y))}, \\
	l.(\letin{x_1}{\pi_1~l}{r_1})(\letin{x_2}{\pi_2~l}{r_2},\pi_3~l) \end{array} \right ] }
	{\gdo e_1 : A \to B \splito [c_1,l_1.r_1] 
	& \gdo e_2 : A \splito [c_2,l_2.r_2]} \\
\infer {\gdt x : A\splits [(),\_.x]}{x : A^\bbtwo \in \Gamma} \\
\infer {\gdt (\lambda x:A.e) : A \to B \splits [p,l.\lambda x:A.r]}{\Gamma,x:A^\bbtwo \vdash e : B \splits [p,l.r]} \\
\infer {\gdt e_1~e_2 : B \splits [(p_1,p_2), l.(\letin{x_1}{\pi_1~l}{r_1})(\letin{x_2}{\pi_2~l}{r_2})]}
	{\gdt e_1 : A \to B \splits [p_1,l_1.r_1] 
	& \gdt e_2 : A \splits [p_2,l_2.r_2]}
\end{gather}
\end{figure*}

\begin{figure*}
\caption{Sum Splitting}
\label{fig:splitSum}
\inferenceSpacing
\begin{gather}
\infer 
	{\gdo \caseof {e_1}{x_2.e_2}{x_3.e_3} :C \splito 
	\left[\left(\tallcase {\pi_1c_2}{x_2.\letin{y}{c_2}{(\pi_1 y,\iota_1(\pi_2 y))}}{x_3.\letin{y}{c_3}{(\pi_1 y,\iota_2(\pi_2 y))}}\right), 
	l.\left(\tallcase{l}{l_2.r_2}{l_3.r_3}\right)\right]}
	{\gdo e_1 : A+B \splito [c_2, l_2.r_2]
	& \Gamma,x_2:A^\bbone \vdash^\bbone e_2 : C \splito [c_2,l_2.r_2] 
	& \Gamma,x_3:B^\bbone \vdash^\bbone e_3 : C \splito [c_3,l_3.r_3]} \\
\infer 
	{\gdt \caseof {e_1}{x_2.e_2}{x_3.e_3} : C\splits \left[(p_1,(p_2,p_3)), l.
		\left(\tallcase{(\letin {l_1}{\pi_1 l}{r_1})}{x_2.\letin {l_2}{\pi_1(\pi_2 l)}{r_2}} {x_3.\letin {l_3}{\pi_2(\pi_2 l)}{r_3}} \right)
	\right] }
	{ \gdt e_1 : A+B \splits [p_1,l_1.r_1]
	& \Gamma,x_2:A^\bbtwo \vdash^\bbtwo e_2 : C \splits [p_2,l_2.r_2] 
	& \Gamma,x_3:B^\bbtwo \vdash^\bbtwo e_3 : C \splits [p_3,l_3.r_3]} 
\end{gather}
\end{figure*}
%\infer {\Gamma\vdash \letin {x}{e_1}{e_2} \splits [\letin {x}{e'_1}{p_2}, y_2.r_2] }{\Gamma\vdash e_1 \translates e_1' & \Gamma, x:\bbone \vdash e_2 \splits [p_2,y_2.r_2]} \\
%\infer { \Gamma\vdash \letin {x}{e_1}{e_2}  \splits [(p_1,p_2), l.\letin {x}{(\letin {y_1}{\pi_1~l}{r_1})}{\letin {y_2}{\pi_2~l}{r_2}}] }{\Gamma\vdash e_1 \splits [p_1,y_1.r_1] & \Gamma, x:\sigma_1 \vdash e_2 \splits [p_2,y_2.r_2]} \\


\subsection{Implementation}

I have an implementation of stage-splitting in SML.  Currently, the code only keeps track of stage, and not the pre-type.

[Add results.]

\section{Related Work}
\label{sec:lit}
\subsection{Partial Evaluation}
One can immediately see a connection between this work and partial evaluation. Both involve the idea of specializing a piece of code to some of it's inputs, leaving a residual that depends only on the remaining inputs.  But stage splitting is actually only part of partial evaluation.  At it's core, stage splitting is ``factor out the first stage, reduce it to a value, and express the second stage abstractly over that value," whereas partial evaluation is ``factor out the first stage, reduce it to a value, and specialize the code of the second stage to that value."  Expressed equationally,
\begin{center}
\begin{tabular}{rll}
{\bf Partial Evaluation}:& $p(f,a)=f_a$ &s.t. $f_a(b) = f(a,b)$ \\
{\bf Stage Splitting}:& $s(f)=(f_1,f_2)$ &s.t. $f_2(f_1(a),b) = f(a,b)$
\end{tabular}
\end{center}
Immediately, we note that stage splitting has broader application than partial evaluation, since the latter requires that $p$ (specifically, some code-specializing apparatus) and $a$ be available at the same time.  If this requirement is satisfied, then we can compare apples to apples by creating a partial evaluator out of a stage splitter:
	\[f_a = (\letin {x}{f_1(a)}{\lambda b.f_2(x,b)})\]
From this view, we see that partial evaluators are more powerful because they can avoid memeory loads, prune unused branches, and even duplicate recursive code for further specialization.  These are largely free wins, except for the recursive code generation, which might have large space costs.

\subsection{Temporal Logic}

There are two papers (called ``circle'' and ``square'') by Rowan Davies which give a justification for binding time analysis in modal logics.  Those papers feel stylistically similar to this work.  Circle, in addition to its other contributions, gives a particularly good account of the difference between its style (which we use), and the rest of the literature. 

There's an important question that our work will need to answer about the difference between the logic that our type system induces and those of Davies.  In particular, what does it mean that our language has no {\tt prev} operator?

\subsection{Speculation}

I can find nothing in the literature that looks like our speculation.  That's probably because speculation is unsafe (especially around side effects), and so it would be a terrible idea in a system without lots of programmer direction.

\end{document}
