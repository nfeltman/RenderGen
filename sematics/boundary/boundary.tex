\documentclass[]{article}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{mathpartir}
\usepackage{mathabx}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{color}

\title{Boundary Types}
\author{Nico}

\newcommand {\next}{asdlfkj}
\input{../../paper/macros}

\begin{document}
\maketitle

\newcommand {\ibksym} {\rotatebox[origin=c]{270}{$\therefore$}}
\newcommand {\btsym} {\rotatebox[origin=c]{270}{$\triangle$}}
\newcommand {\ktype} {\rm Type}
\newcommand {\ibk} [2] {{#1}~\ibksym~{#2}}
\newcommand {\btj} [4] {{#1}:{#2}~@~{#3}~\btsym~{#4}}
\newcommand {\btyo} [4] [\Gamma] {{#1}\vdash \btj{#2}{#3}\bbone{#4}}
\newcommand {\btyt} [4] [\Gamma] {{#1}\vdash \btj{#2}{#3}\bbtwo{#4}}
\newcommand {\btyw} [4] [\Gamma] {{#1}\vdash \btj{#2}{#3}w{#4}}
\newcommand {\btysub} [2] [] {\bty{e_{#1}:{#2}}{\tau_{#1}}{\sigma_{#1}}}

\section{Goals}

The purpose of this document is to explain how to type the boundary produced by our splitting algorithm.
We'll start with a very simple input language, the boundary of which can be typed in an easy way.
We'll then start adding features to the language, thereby inducing complexity in the boundary type system.

For the most part, we'll do all of our work with a single new judgement $\btj e A w \tau$, 
which indicates that the expression $e$ (which has type $A$ at world $w$) has the boundary type $\tau$.
Ideally, the splitting rules will agree with the boundary type given to us by this judgment.
That is, if $\btj e A \bbtwo \tau$ and $\splitone{e}{A}{p,l.r}$, 
then $p:\tau$ and $l:\tau \vdash r:A$ (and a similar relationship at stage \bbone, covered later).
Mind you, we don't actually bother checking that property in this document.

\section{Straight-line Code}

We first consider an input language which has no functions or divergence.
At either stage, the boundary type of any expression is 
just the product of the boundary types of its subexpressions
(unit in the nullary case).
The only exception to this pattern is the $\pause$ rule,
which also multiplies an int into the boundary type.

\begin{mathpar}
\infer {\btyw i {\rm int}\rmunit} {\cdot} \and
\infer {\btyw b {\rm bool}\rmunit} {\cdot} \and
\infer {\btyw {(e_1,e_2)} {A \times B} {\tau_1 \times \tau_2}} 
	{\btyw {e_1} A {\tau_1} 
	&\btyw {e_2} B {\tau_2}} \and
\infer {\btyw {\pio~e} A \tau} 
	{\btyw {e} {A \times B} {\tau}} \and
\infer {\btyw {\pit~e} B \tau} 
	{\btyw {e} {A \times B} {\tau}} \and
\infer {\btyo {\next~e} {\fut A} \tau} 
	{\btyt {e} A {\tau}} \and
\infer {\btyt {\prev~e} A \tau} 
	{\btyo {e} {\fut A} {\tau}} \and
\infer {\btyt {\pause~e} \rmint {\tau \times \rmint}} 
	{\btyo e \rmint \tau}
\end{mathpar}

Finally, we look at the let and var rules.

\begin{mathpar}
\infer [let] {\btyw {\letin x {e_1} {e_2}} {B} {\tau_1 \times \tau_2}} 
	{\btyw {e_1} A {\tau_1} 
	&\btyw [\Gamma,\btj x A w \rmunit] {e_2} B {\tau_2}} \and
\infer [var] {\btyw [\Gamma,\btj x A w \rmunit] {x} A \rmunit} {\cdot}
\end{mathpar}
Notice that we've defined these two rules in a slightly different way than usual.
Typically, we'd say that whenever some variable $x$ is in the context 
(because it was put there at a binder site),
we can form the judgment that $x$ reference sites have a unit boundary.
Instead what we've done is put the whole boundary type judgment in context at the binding site,
and then we pull it out of the context at the reference site.
Strictly speaking, the var rule is merely a special case of the 
general structural rule stating ``you can use what you assume,'' so we'll omit it from here on out.

This is a pretty common technique  called {\em hypothetical judgments}.
For now, the use of hypothetical judgments is merely a stylistic difference,
but it will become important when things get more complicated.

\section{Adding Functions and Fixed Points}

Lets turn this language to 11.  
In addition to straight-line code, we'll add \texttt{if}s, functions, and fixed points,
which the astute reader will notice is enough to make the language Turing-complete.
Before getting into the rules, consider the following example, 
where $E$ is some purely stage \bbone\ expression:

\[
\left(
\tallif {E}
	{(\lam x \rmint {\next\{\pause\{x\}+1\})}}
	{(\lam x \rmint {\next\{\pause\{x\}+\pause\{x*x\}\}})}
\right ) 5
\]

What do we expect the boundary type to be for this whole piece of code?
Well, it depends. 
If $E$ evaluates to true, then we'd expect the boundary type to be $\rmint$,
but if $E$ evaluates to false, we'd expect the boundary type to be $\rmint \times \rmint$.
Ergo, figuring out the boundary type of this piece of code is at least as hard 
as figuring out what any given expression evaluates to.
Of course, that's not decidable. Yikes. 

Fortunately for us, that's not really the end of it.  
Just because we can't know the boundary type of a piece of code doesn't mean we can't say anything.  
Maybe instead of giving the {\em exact} answer, we can give a list of possibilities.

\section{Adding Just \texttt{if}-Expressions}

So to explore what this means, lets dial back the language a bit.  
In addition to straight-line from before, lets just add \texttt{if} expressions.
It turns out this is easy to integrate into the existing framework:

\begin{mathpar}
\infer {\btyo {\ifthen {e_1}{e_2}{e_3}} {A} {\tau_1 \times (\tau_2 + \tau_3)}} 
	{\btyo {e_1} \rmbool {\tau_1} 
	&\btyo {e_2} A {\tau_2}
	&\btyo {e_3} A {\tau_3}} \and
\infer {\btyt {\ifthen {e_1}{e_2}{e_3}} {A} {\tau_1 \times \tau_2 \times \tau_3}} 
	{\btyt {e_1} \rmbool {\tau_1} 
	&\btyt {e_2} A {\tau_2}
	&\btyt {e_3} A {\tau_3}}
\end{mathpar}

The only particular care we took here was to observe speculation in the stage \bbtwo\ case,
which induces a product (whereas stage \bbone\ had a sum).
We can rewrite the problematic example in our restricted language 
by distributing the application into the if and applying the lambda in both branches:
\[
\tallif {E}
	{(\next\{\pause\{5\}+1\})}
	{(\next\{\pause\{5\}+\pause\{5*5\}\})}
\]
We our new rules, we can say that the boundary type of this expression is
$\rmunit \times (\rmint + \rmint \times \rmint)$.
Sure, this isn't the {\em exact} boundary type, 
but it's as much as we can know without an oracle.

\section{Adding Just Functions}

Lets now take a different stab at this, by adding functions to our straight-line code,
but leaving \texttt{if}s out for now.
Again, lets consider an example:
\[
L1 := (\lam x \rmint {\next\{5\}})
\]
The boundary type of $L1$ is obviously unit, right?
After all, lambdas are values, and values have unit boundary.
So then what about this example:
\[
L2 := (\lam x \rmint {\next\{\pause\{x\}+1\}})
\]
I'd like to think it's the same story.
But what if we apply a value to these functions?
Consider
\[
(\lam x \rmint {\next\{5\}})~3
\]
versus
\[
(\lam x \rmint {\next\{\pause\{x\}+1\}})~3
\]
The boundary type of the first expression should still be unit 
(even after substitution it has no $\pause$s),
but the bound type of the second expression should definitely be int.

There's a problem here: $L1$ and $L2$ had the same boundary type before application, but different ones after.
This suggests that if we want the boundary type to be a compositional property (rather than global),
then we'll need to keep track of more information.

We do this by making a distinction between the {\em internal} boundary of an expression,
and its {\em external} boundary.  
$L1$ and $L2$ have the same external boundary, namely unit,
but they have different internal boundaries.  
In particular, the interal boundary of $L1$ should be int (or isomorphic to it), 
whereas the internal boundary of $L2$ should be unit.

% Consider a language with products and functions.  The internal boundary kind is given by:

% \begin{mathpar}
% \infer {\ibk {\rm int}{\rm Unit}} {\cdot} \and 
% \infer {\ibk {\rm bool}{\rm Unit}} {\cdot} \and 
% \infer {\ibk {A \times B}{\kappa_A \times \kappa_B}} {\ibk A {\kappa_A} & \ibk B {\kappa_B}} \and 
% %\infer {\ibk {A \to B}{\kappa_A \to \ktype \times \kappa_B}} {\ibk A {\kappa_A} & \ibk B {\kappa_B}} 
% \end{mathpar}



\end{document}
