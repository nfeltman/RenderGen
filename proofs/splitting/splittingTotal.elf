
%% SOME SORT OF SEPERATION THEOREM THAT I DIDN'T FINISH BUT MAY NEED IN THE FUTURE
%{
sep-1 :  ({x} split wor1 x (pipe A R) -> split W2 (E x) (pipe C R'))
		-> {B} ({x} split wor1 x (pipe A B) -> split W2 (E x) (pipe C R''))
		-> type.
%mode sep-1 +Dspl +T -Dspl'.
- : sep-1 ([x][s:split wor1 x (pipe A R)] s) B ([x][s:split wor1 x (pipe A B)] s).
- : sep-1 ([x][s] Dspl) B ([x][s] Dspl).
- : sep-1 ([x][s] spl1-tup (Dspl1 x s) (Dspl2 x s)) B ([x][s] spl1-tup (Dspl1' x s) (Dspl2' x s))
	<- sep-1 Dspl1 B Dspl1'
	<- sep-1 Dspl2 B Dspl2'.
- : sep-1 ([x][s] spl1-pi1 (Dspl x s)) B ([x][s] spl1-pi1 (Dspl' x s))
	<- sep-1 Dspl B Dspl'.
- : sep-1 ([x][s] spl1-pi2 (Dspl x s)) B ([x][s] spl1-pi2 (Dspl' x s))
	<- sep-1 Dspl B Dspl'.
- : sep-1 ([x][s] spl1-app (Dspl1 x s) (Dspl2 x s)) B ([x][s] spl1-app (Dspl1' x s) (Dspl2' x s))
	<- sep-1 Dspl1 B Dspl1'
	<- sep-1 Dspl2 B Dspl2'.
- : sep-1 ([x][s] spl1-next (Dspl x s)) B ([x][s] spl1-next (Dspl' x s))
	<- sep-1 Dspl B Dspl'.



- : sep-1 ([x][s] spl2-tup (Dspl1 x s) (Dspl2 x s)) B ([x][s] spl2-tup (Dspl1' x s) (Dspl2' x s))
	<- sep-1 Dspl1 B Dspl1'
	<- sep-1 Dspl2 B Dspl2'.
- : sep-1 ([x][s] spl2-pi1 (Dspl x s)) B ([x][s] spl2-pi1 (Dspl' x s))
	<- sep-1 Dspl B Dspl'.
- : sep-1 ([x][s] spl2-pi2 (Dspl x s)) B ([x][s] spl2-pi2 (Dspl' x s))
	<- sep-1 Dspl B Dspl'.
- : sep-1 ([x][s] spl2-lam ([y][sy] Dspl y sy x s)) B ([x][s] spl2-lam ([y][sy] Dspl' y sy x s))
	<- {y}{sply} sep-1 (Dspl y sply) B (Dspl' y sply).
- : sep-1 ([x][s] spl2-app (Dspl1 x s) (Dspl2 x s)) B ([x][s] spl2-app (Dspl1' x s) (Dspl2' x s))
	<- sep-1 Dspl1 B Dspl1'
	<- sep-1 Dspl2 B Dspl2'.
- : sep-1 ([x][s] spl2-prev (Dspl x s)) B ([x][s] spl2-prev (Dspl' x s))
	<- sep-1 Dspl B Dspl'.
- : sep-1 ([x][s] spl1-lam ([y][y1][y2][sy] Dspl y y1 y2 sy x s)) B ([x][s] spl1-lam ([y][y1][y2][sy] Dspl' y y1 y2 sy x s))
	<- {y}{y1}{y2}{sply}
		sep-1 ([x][s] Dspl y y1 y2 sply x s) B ([x][s] Dspl' y y1 y2 sply x s : split wor1 (E y x) (pipe (E2 y1) (E3 y2))).
%worlds (splitting-block) (sep-1 _ _ _).
%%total (D) (sep-1 D _ _).
}%

sep-1\1 : ({x : term}{x1 : term}{x2 : term}
			split W1 x (pipe (VC x1) (VR x2)) -> split W2 (E x) (pipe (C x x1 x2) ([l] R l x x1 x2))) 
			-> ({x : term}{x1 : term}{x2 : term} eq-term (C x x1 x2) (C' x1)) 
			-> ({l : term}{x : term}{x1 : term}{x2 : term} eq-term (R l x x1 x2) (R' l x2)) 
			-> type.
%mode sep-1\1 +Dspl -Deq1 -Deq2.
- : sep-1\1 ([x][x1][x2][dspl] Dspl x x1 x2 dspl : split W (E x) (pipe (C x1) ([l] R l x2))) 
	([_][_][_] eq-term_) 
	([_][_][_][_] eq-term_).
- : sep-1\1 ([x][x1][x2][dspl] spl1-pi1 (Dspl x x1 x2 dspl)) Deq1' Deq2'
	<- sep-1\1 Dspl Deq1 Deq2
	<- ({x}{x1}{x2} eq-cong/lett (Deq1 x x1 x2) ([y] [z] eq-term_) (Deq1' x x1 x2))
	<- ({l}{x}{x1}{x2} eq-cong pi1 (Deq2 l x x1 x2) (Deq2' l x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl1-pi2 (Dspl x x1 x2 dspl)) Deq1' Deq2'
	<- sep-1\1 Dspl Deq1 Deq2
	<- ({x}{x1}{x2} eq-cong/lett (Deq1 x x1 x2) ([y] [z] eq-term_) (Deq1' x x1 x2))
	<- ({l}{x}{x1}{x2} eq-cong pi2 (Deq2 l x x1 x2) (Deq2' l x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl1-tup (DsplA x x1 x2 dspl) (DsplB x x1 x2 dspl)) Deq1' Deq2'
	<- sep-1\1 DsplA DeqA1 DeqA2
	<- sep-1\1 DsplB DeqB1 DeqB2
	<- ({x}{x1}{x2}{y}{z} eq-cong/0/2 lett (DeqB1 x x1 x2) ([_][_] eq-term_) (Deq1 x x1 x2 y z))
	<- ({x}{x1}{x2} eq-cong/lett (DeqA1 x x1 x2) ([y][z] Deq1 x x1 x2 y z) (Deq1' x x1 x2))
	<- ({l1}{l2}{x}{x1}{x2} eq-cong2 tup (DeqA2 l1 x x1 x2) (DeqB2 l2 x x1 x2) (Deq2 l1 l2 x x1 x2))
	<- ({l}{x}{x1}{x2} eq-cong/lett eq-term_ ([l1][l2] Deq2 l1 l2 x x1 x2) (Deq2' l x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl1-app (DsplA x x1 x2 dspl) (DsplB x x1 x2 dspl)) Deq1' Deq2''
	<- sep-1\1 DsplA DeqA1 DeqA2
	<- sep-1\1 DsplB DeqB1 DeqB2
	<- ({x}{x1}{x2}{y}{z} eq-cong/lett (DeqB1 x x1 x2) ([_][_] eq-term_) (Deq1 x x1 x2 y z))
	<- ({x}{x1}{x2} eq-cong/lett (DeqA1 x x1 x2) ([y][z] Deq1 x x1 x2 y z) (Deq1' x x1 x2))
	<- ({l1}{l2}{l3}{x}{x1}{x2} eq-cong2 ([a][b] app a (tup b l3)) (DeqA2 l1 x x1 x2) (DeqB2 l2 x x1 x2) (Deq2 l1 l2 l3 x x1 x2))
	<- ({l12}{l3}{x}{x1}{x2} eq-cong/lett eq-term_ ([l1][l2] Deq2 l1 l2 l3 x x1 x2) (Deq2' l12 l3 x x1 x2))
	<- ({l}{x}{x1}{x2} eq-cong/lett eq-term_ ([l12][l3] Deq2' l12 l3 x x1 x2) (Deq2'' l x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl1-lam ([y][y1][y2][yspl] Dspl y y1 y2 yspl x x1 x2 dspl)) Deq1'' ([_] Deq2'')
	<- ({y}{y1}{y2}{yspl} sep-1\1 (Dspl y y1 y2 yspl) ([x][x1][x2] Deq1 x x1 x2 y1) ([l][x][x1][x2] Deq2 x x1 x2 y2 l))
	<- ({x}{x1}{x2} eq-cong/1 lam ([y1] Deq1 x x1 x2 y1) (Deq1' x x1 x2))
	<- ({x}{x1}{x2} eq-cong2 tup (Deq1' x x1 x2) eq-term_ (Deq1'' x x1 x2))
	<- ({xl}{x}{x1}{x2} eq-cong/lett eq-term_ (Deq2 x x1 x2) (Deq2' x x1 x2 xl))
	<- ({x}{x1}{x2} eq-cong/1 lam (Deq2' x x1 x2) (Deq2'' x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl1-next (Dspl x x1 x2 dspl)) Deq1' Deq2
	<- sep-1\1 Dspl Deq1 Deq2
	<- ({x}{x1}{x2} eq-cong2 tup eq-term_ (Deq1 x x1 x2) (Deq1' x x1 x2)).


- : sep-1\1 ([x][x1][x2][dspl] spl2-tup (DsplA x x1 x2 dspl) (DsplB x x1 x2 dspl)) Deq1 Deq2'
	<- sep-1\1 DsplA DeqA1 DeqA2
	<- sep-1\1 DsplB DeqB1 DeqB2
	<- ({x}{x1}{x2} eq-cong2 tup (DeqA1 x x1 x2) (DeqB1 x x1 x2) (Deq1 x x1 x2))
	<- ({l1}{l2}{x}{x1}{x2} eq-cong2 tup (DeqA2 l1 x x1 x2) (DeqB2 l2 x x1 x2) (Deq2 l1 l2 x x1 x2))
	<- ({l}{x}{x1}{x2} eq-cong/lett eq-term_ ([l1][l2] Deq2 l1 l2 x x1 x2) (Deq2' l x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl2-pi1 (Dspl x x1 x2 dspl)) Deq1 Deq2'
	<- sep-1\1 Dspl Deq1 Deq2
	<- ({l}{x}{x1}{x2} eq-cong pi1 (Deq2 l x x1 x2) (Deq2' l x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl2-pi2 (Dspl x x1 x2 dspl)) Deq1 Deq2'
	<- sep-1\1 Dspl Deq1 Deq2
	<- ({l}{x}{x1}{x2} eq-cong pi2 (Deq2 l x x1 x2) (Deq2' l x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl2-lam (Dspl x x1 x2 dspl)) Deq1 Deq2'
	<- ({y}{yspl} sep-1\1 ([x][x1][x2][dspl] Dspl x x1 x2 dspl y yspl) Deq1 ([l][x][x1][x2] Deq2 x x1 x2 l y))
	<- ({l}{x}{x1}{x2} eq-cong/1 lam (Deq2 x x1 x2 l) (Deq2' l x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl2-app (DsplA x x1 x2 dspl) (DsplB x x1 x2 dspl)) Deq1 Deq2'
	<- sep-1\1 DsplA DeqA1 DeqA2
	<- sep-1\1 DsplB DeqB1 DeqB2
	<- ({x}{x1}{x2} eq-cong2 tup (DeqA1 x x1 x2) (DeqB1 x x1 x2) (Deq1 x x1 x2))
	<- ({l1}{l2}{x}{x1}{x2} eq-cong2 app (DeqA2 l1 x x1 x2) (DeqB2 l2 x x1 x2) (Deq2 l1 l2 x x1 x2))
	<- ({l}{x}{x1}{x2} eq-cong/lett eq-term_ ([l1][l2] Deq2 l1 l2 x x1 x2) (Deq2' l x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl2-lam (Dspl x x1 x2 dspl)) Deq1 Deq2'
	<- ({y}{yspl} sep-1\1 ([x][x1][x2][dspl] Dspl x x1 x2 dspl y yspl) Deq1 ([l][x][x1][x2] Deq2 x x1 x2 l y))
	<- ({l}{x}{x1}{x2} eq-cong/1 lam (Deq2 x x1 x2 l) (Deq2' l x x1 x2)).
- : sep-1\1 ([x][x1][x2][dspl] spl2-prev (Dspl x x1 x2 dspl)) Deq1' Deq2
	<- sep-1\1 Dspl Deq1 Deq2
	<- ({x}{x1}{x2} eq-cong pi2 (Deq1 x x1 x2) (Deq1' x x1 x2)).
%worlds (splitting-block) (sep-1\1 _ _ _).
%total (D) (sep-1\1 D _ _).

%% SPLITTING RESPECTS IDENTITY
split-resp : split W E (pipe P R) -> eq-term P P' -> ({l} eq-term (R l) (R' l)) -> split W E (pipe P' R') -> type.
%mode split-resp +Dspl +Deq1 +Deq2 -Dspl'.
- : split-resp Dspl eq-term_ ([l] eq-term_) Dspl.
%worlds (any-splitting | term-block) (split-resp _ _ _ _).
%total (Deq) (split-resp _ Deq _ _).

%% SOME SORT OF SEPERATION PROPERTY
separation : ({x : term}{x1 : term}{x2 : term}
				split W1 x (pipe (VC x1) (VR x2)) -> split W2 (E x) (pipe (C x x1 x2) ([l] R l x x1 x2))) 
			-> ({x : term}{x1 : term}{x2 : term} 
				split W1 x (pipe (VC x1) (VR x2)) -> split W2 (E x) (pipe (C' x1) ([l] R' l x2))) 
			-> type.
%mode separation +Dspl -Dspl'.
- : separation Dspl Dspl'
	<- sep-1\1 Dspl Deq1 Deq2
	<- {x}{x1}{x2}{dspl} split-resp (Dspl x x1 x2 dspl) (Deq1 x x1 x2) ([l] Deq2 l x x1 x2) (Dspl' x x1 x2 dspl).
%worlds (splitting-block) (separation _ _).
%total (D) (separation D _).


%% FIRST-STAGE RESULTS CANNOT DEPEND ON STAGE TWO VARIABLES
c-strengthen : ({x : term} split wor2 x (pipe ztup ([_] x)) -> split wor1 (E x) (pipe (C x) _)) -> ({x :term} eq-term (C x) C') -> type.
%mode c-strengthen +Dspl -Deq.
p-strengthen : ({x : term} split wor2 x (pipe ztup ([_] x)) -> split wor2 (E x) (pipe (P x) _)) -> ({x :term} eq-term (P x) P') -> type.
%mode p-strengthen +Dspl -Deq.

%% CATCHALL CASES
- : c-strengthen ([x] [dspl] Dspl x dspl : split wor1 (E x) (pipe C _)) ([x] eq-term_).
- : p-strengthen ([x] [dspl] Dspl x dspl : split wor2 (E x) (pipe P _)) ([x] eq-term_).

%% PI1
- : c-strengthen ([x] [dspl] spl1-pi1 (Dspl x dspl)) Deq'
	<- c-strengthen Dspl Deq
	<- {x} eq-cong/lett (Deq x) ([y] [z] eq-term_) (Deq' x).
- : p-strengthen ([x] [dspl] spl2-pi1 (Dspl x dspl)) Deq
	<- p-strengthen Dspl Deq.

%% PI2
- : c-strengthen ([x] [dspl] spl1-pi2 (Dspl x dspl)) Deq'
	<- c-strengthen Dspl Deq
	<- {x} eq-cong/lett (Deq x) ([y] [z] eq-term_) (Deq' x).
- : p-strengthen ([x] [dspl] spl2-pi2 (Dspl x dspl)) Deq
	<- p-strengthen Dspl Deq.

%% TUP
- : c-strengthen ([x] [dspl] spl1-tup (Dspl1 x dspl) (Dspl2 x dspl)) Deq
	<- c-strengthen Dspl1 Deq1
	<- c-strengthen Dspl2 Deq2
	<- ({x}{y}{z} eq-cong/lett (Deq2 x) ([x2] [y2] eq-term_) (Deq2' x z y))
	<- {x} eq-cong/lett (Deq1 x) ([y] [z] Deq2' x z y) (Deq x).
- : p-strengthen ([x] [dspl] spl2-tup (Dspl1 x dspl) (Dspl2 x dspl)) Deq
	<- p-strengthen Dspl1 Deq1
	<- p-strengthen Dspl2 Deq2
	<- {x} eq-cong2 tup (Deq1 x) (Deq2 x) (Deq x).

%% LAM
- : p-strengthen ([x] [dsplx] spl2-lam ([y] [dsply] DsplM y dsply x dsplx) : split wor2 (lam _) _) Deq
	<- ({y} {dsply} p-strengthen (DsplM y dsply) Deq).


%% APP
- : c-strengthen ([x] [dspl] spl1-app (Dspl1 x dspl) (Dspl2 x dspl)) Deq
	<- c-strengthen Dspl1 Deq1
	<- c-strengthen Dspl2 Deq2
	<- ({x}{y}{z} eq-cong/lett (Deq2 x) ([x2] [y2] eq-term_) (Deq2' x z y))
	<- {x} eq-cong/lett (Deq1 x) ([y] [z] Deq2' x z y) (Deq x).
- : p-strengthen ([x] [dspl] spl2-app (Dspl1 x dspl) (Dspl2 x dspl)) Deq
	<- p-strengthen Dspl1 Deq1
	<- p-strengthen Dspl2 Deq2
	<- {x} eq-cong2 tup (Deq1 x) (Deq2 x) (Deq x).

%% NEXT
- : c-strengthen ([x] [dspl] spl1-next (Dspl x dspl)) Deq'
	<- p-strengthen Dspl Deq
	<- {x} eq-cong2 tup eq-term_ (Deq x) (Deq' x).

%% PREV
- : p-strengthen ([x] [dspl] spl2-prev (Dspl x dspl)) Deq'
	<- c-strengthen Dspl Deq
	<- {x} eq-cong pi2 (Deq x) (Deq' x).

- : c-strengthen 
		([x] [dspl] spl1-lam ([y][y1][y2][dsply] DsplM x dspl y y1 y2 dsply)) 
		Deq''
	<- ({y}{y1}{y2} {dsply : split wor1 y (pipe (tup y1 ztup) ([_] y2 ))}  
		c-strengthen ([x][splx] DsplM x splx y y1 y2 dsply) (Deq y1))
	<- ({x} eq-cong/lam ([y] Deq y x) (Deq' x))
	<- {x} eq-cong2 tup (Deq' x) eq-term_ (Deq'' x).
%% STRENGTHENING
%worlds (splitting-block) (c-strengthen _ _) (p-strengthen _ _).
%total (Dspl1 Dspl2) (c-strengthen Dspl1 _) (p-strengthen Dspl2 _).

%% SPLITTING IS TOTAL FOR WELL-TYPED TERMS
spl1-total : of+ E A T wor1 -> split wor1 E _ -> type.
%mode spl1-total +Dof -Dspl.
spl2-total : of+ E A T wor2 -> split wor2 E _ -> type.
%mode spl2-total +Dof -Dspl.

%% BLOCKS
%block total-var1 : some {T : ty} {A : ty} block 
	{x:term} {x1:term} {x2:term} {dof : of+ x T A wor1} {dspl : split wor1 x (pipe (tup x1 ztup) ([_] x2))} {dtot : spl1-total dof dspl}.
%block total-var2 : some {T : ty} {A : ty} block 
	{x:term} {dof : of+ x T A wor2} {dspl : split wor2 x (pipe ztup ([_] x))} {dtot : spl2-total dof dspl}.
%block total-block = (total-var1 | total-var2).

%% MAIN PROOF OF TOTALITY
- : spl1-total of+ztup spl1-ztup.
- : spl2-total of+ztup spl2-ztup.
- : spl1-total (of+tup Dof1 Dof2) (spl1-tup Dspl1 Dspl2)
	<- spl1-total Dof1 Dspl1
	<- spl1-total Dof2 Dspl2.
- : spl2-total (of+tup Dof1 Dof2) (spl2-tup Dspl1 Dspl2)
	<- spl2-total Dof1 Dspl1
	<- spl2-total Dof2 Dspl2.
- : spl1-total (of+pi1 Dof) (spl1-pi1 Dspl)
	<- spl1-total Dof Dspl.
- : spl2-total (of+pi1 Dof) (spl2-pi1 Dspl)
	<- spl2-total Dof Dspl.
- : spl1-total (of+pi2 Dof) (spl1-pi2 Dspl)
	<- spl1-total Dof Dspl.
- : spl2-total (of+pi2 Dof) (spl2-pi2 Dspl)
	<- spl2-total Dof Dspl.
- : spl1-total (of+lam+ Dwf Dof) (spl1-lam Dspl')
	<- ({x : term} {x1}{x2} {dof : of+ x unit A wor1} {dspl : split wor1 x (pipe (tup x1 ztup) ([_] x2))}
		spl1-total dof dspl ->
		spl1-total (Dof x dof) (Dspl x x1 x2 dspl))
	<- separation Dspl Dspl'.
- : spl2-total (of+lam Dwf Dof) (spl2-lam Dspl')
	<- ({x : term} {dof : of+ x unit A wor2} {dspl : split wor2 x (pipe ztup ([_] x))} 
		spl2-total dof dspl ->
		spl2-total (Dof x dof) (Dspl x dspl))
	<- p-strengthen Dspl Deq
	<- {x} {spl} split-resp (Dspl x spl) (Deq x) ([_] eq-term_) (Dspl' x spl).
- : spl1-total (of+app+ Dof1 Dof2) (spl1-app Dspl1 Dspl2)
	<- spl1-total Dof1 Dspl1
	<- spl1-total Dof2 Dspl2.
- : spl2-total (of+app Dof1 Dof2) (spl2-app Dspl1 Dspl2)
	<- spl2-total Dof1 Dspl1
	<- spl2-total Dof2 Dspl2.
- : spl1-total (of+next Dof) (spl1-next Dspl)
	<- spl2-total Dof Dspl.
- : spl2-total (of+prev Dof) (spl2-prev Dspl)
	<- spl1-total Dof Dspl.
%worlds (total-block) (spl1-total _ _) (spl2-total _ _).
%total (Dspl1 Dspl2) (spl1-total Dspl1 _) (spl2-total Dspl2 _).
