%{ splitting.elf }%

%% SPLITTING RESIDUALS, VALUES, AND TERMS
splitres : term lang0 -> term lang2 -> type. %name splitres Dsplr.
%mode splitres +Q -Q'.

splr-ztup : splitres ztup ztup.
splr-pi1 : splitres (pi1 E) (pi1 E')
			<- splitres E E'.
splr-pi2 : splitres (pi2 E) (pi2 E')
			<- splitres E E'.
splr-tup : splitres (tup E1 E2) (tup E1' E2')
			<- splitres E2 E2'
			<- splitres E1 E1'.
splr-lam : splitres (lam M) (lam M')
			<- {x}{x2} splitres x x2 -> splitres (M x) (M' x2).
splr-app : splitres (app E1 E2) (app E1' E2')
			<- splitres E2 E2'
			<- splitres E1 E1'.
splr-let : splitres (let E M) (let E' M')
			<- ({x}{x2} splitres x x2 -> splitres (M x) (M' x2))
			<- splitres E E'.

%% SPLITTING RESIDUALS, VALUES, AND TERMS
splitval : term lang0 -> term lang1 -> term lang2 -> type. %name splitval Dsplv.
%mode splitval +E -I -Q.
split : wor -> term lang0 -> seperated -> type. %name split Dspl.
%mode split +W +E -P.



splv-ztup 	: splitval ztup ztup ztup.
splv-next	: splitval (next E) ztup E'
			<- splitres E E'.
splv-tup 	: splitval (tup E1 E2) (tup I1 I2) (tup Q1 Q2)
			<- splitval E2 I2 Q2
			<- splitval E1 I1 Q1.
splv-lam	: splitval (lam M) (lam C) (lam ([xl] lett xl R))
			<- {x}{x1}{x2} splitval x x1 x2 -> split wor1 (M x) (pipe (C x1) ([l] R x2 l)). 


spl1-exv	: split wor1 (exv V) (pipe (tup I ztup) ([_] Q))
			<- splitval V I Q.
%{spl1-ztup	: split wor1 ztup (pipe (tup ztup ztup) ([_] ztup)).}%
spl1-tup	: split wor1 (tup E1 E2) 
				(pipe 
					(lett C1 ([y1] [z1] lett C2 ([y2] [z2] tup (tup y1 y2) (tup z1 z2)))) 
					([l] lett l ([l1] [l2] tup (R1 l1) (R2 l2)))
				)
			<- split wor1 E2 (pipe C2 R2)
			<- split wor1 E1 (pipe C1 R1).
spl1-pi1	: split wor1 (pi1 E) (pipe (lett C ([y] [z] tup (pi1 y) z)) ([l] pi1 (R l)))
			<- split wor1 E (pipe C R).
spl1-pi2	: split wor1 (pi2 E) (pipe (lett C ([y] [z] tup (pi2 y) z)) ([l] pi2 (R l)))
			<- split wor1 E (pipe C R).
spl1-app	: split wor1 (app E1 E2) 
				(pipe
					(lett C1 ([y1] [z1] lett C2 ([y2] [z2] lett (app y1 y2) ([y3] [z3] tup (y3) (tup (tup z1 z2) z3)))))
					([l] lett l ([l12] [l3] lett l12 ([l1] [l2] app (R1 l1) (tup (R2 l2) l3))))
				)
			<- split wor1 E2 (pipe C2 R2)
			<- split wor1 E1 (pipe C1 R1).
spl1-next	: split wor1 (next E) (pipe (tup ztup P) R)
			<- split wor2 E (pipe P R).

spl2-exv	: split wor2 (exv Q) (pipe ztup ([_] Q'))
				<- splitres Q Q'.
spl2-ztup	: split wor2 ztup (pipe ztup ([_] ztup)). 
spl2-tup	: split wor2 (tup E1 E2) (pipe (tup P1 P2) ([l] lett l ([l1] [l2] tup (R1 l1) (R2 l2))))
			<- split wor2 E2 (pipe P2 R2)
			<- split wor2 E1 (pipe P1 R1).
spl2-pi1	: split wor2 (pi1 E) (pipe P ([l] pi1 (R l)))
			<- split wor2 E (pipe P R).
spl2-pi2	: split wor2 (pi2 E) (pipe P ([l] pi2 (R l)))
			<- split wor2 E (pipe P R).
spl2-lam	: split wor2 (lam M) (pipe P ([l] lam ([x] R x l)))
			<- {x}{x2} splitres x x2 -> split wor2 (M x) (pipe P ([l] R x2 l)).
spl2-app	: split wor2 (app E1 E2) (pipe (tup P1 P2) ([l] lett l ([l1] [l2] app (R1 l1) (R2 l2))))
			<- split wor2 E2 (pipe P2 R2)
			<- split wor2 E1 (pipe P1 R1).
spl2-prev 	: split wor2 (prev E) (pipe (pi2 C) R)
			<- split wor1 E (pipe C R).

%{spl1-let	: split wor1 (let E M) 
				(pipe
					(lett C1 ([x] [z1] lett (C2 x) ([y] [z2] tup y (tup z1 z2)))) 
					([l] lett l ([l1] [l2] let (R1 l1) ([x] R2 x l2)))
				)
			<- ({x : term} split wor1 x (pipe x ([_] x)) -> split wor1 (M x) (pipe (C2 x) ([l] R2 x l)))
			<- split wor1 E (pipe C1 R1).}%
spl2-let	: split wor2 (let E M) (pipe (tup P1 P2) ([l] lett l ([l1][l2] let (R1 l1) ([x] R2 x l2))))
			<- ({x}{x2} splitres x x2 -> split wor2 (M x) (pipe P2 ([l] R2 x2 l)))
			<- split wor2 E (pipe P1 R1).


%block splitting-var1 : block {x:term lang0}{x1:term lang1}{x2:term lang2} {dspl : splitval x x1 x2}.
%block splitting-var2 : block {x:term lang0}{x2:term lang2} {dspl : splitres x x2}.
%block splitting-block = (splitting-var1 | splitting-var2).

%worlds (splitting-block) (splitres _ _).
%unique splitres +E -1Q.
%worlds (splitting-block) (splitval _ _ _) (split _ _ _).
%unique (splitval +E -1I -1Q) (split +W +E -1P).



%block any-splitres : some {E : term lang0} {Q : term lang2} block {dsplr : splitres E Q}.
%block any-splitval : some {E : term lang0} {I : term lang1} {Q : term lang2} block {dsplr : splitval E I Q}.
%block any-split = (any-splitres | any-splitval).

%%block any-splitting : 	some {W : wor} {E : term} {P : term} {R : term -> term}	block {dspl : split W E (pipe P R)}.


%% SPLITRES RESPECTS IDENTITY
splitres-resp : splitres E Q -> eq-term E E' -> eq-term Q Q' -> splitres E' Q' -> type.
%mode splitres-resp +Dspl +Deq1 +Deq2 -Dspl'.
- : splitres-resp Dspl eq-term_ eq-term_ Dspl.
%worlds (term-block | any-split) (splitres-resp _ _ _ _).
%total (Deq) (splitres-resp _ Deq _ _).

%% SPLITTING RESPECTS IDENTITY
split-resp : split W E (pipe P R) -> eq-term E E' -> eq-term P P' -> ({l} eq-term (R l) (R' l)) -> split W E' (pipe P' R') -> type.
%mode split-resp +Dspl +Deq1 +Deq2 +Deq3 -Dspl'.
- : split-resp Dspl eq-term_ eq-term_ ([l] eq-term_) Dspl.
%worlds (term-block | any-split) (split-resp _ _ _ _ _).
%total (Deq) (split-resp _ Deq _ _ _).