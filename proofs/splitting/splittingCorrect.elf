

%% VALUE SPLITTING PRODUCES VALUES
val-to-val : splitval E I Q -> val I -> type.
%mode val-to-val +Dsplv -Dval.
- : val-to-val splv-ztup val-ztup.
- : val-to-val (splv-next _) val-ztup.
- : val-to-val (splv-tup Dsplv1 Dsplv2) (val-tup Dval1 Dval2)
	<- val-to-val Dsplv1 Dval1
	<- val-to-val Dsplv2 Dval2.
- : val-to-val (splv-lam _) val-lam.
%worlds () (val-to-val _ _).
%total (D) (val-to-val D _).



%% LIFTING CORRECTNESS

lc :  lstep E Q E' -> split wor1 E (pipe C R) -> splitres Q Q' -> ({x}{x2} splitres x x2 -> split wor1 (E' x) (pipe C (R' x2))) -> type.
%mode lc +Dstep +DsplE -DsplrQ -DsplE'.
%% LIFT RULES
- : lc (ls-next-r _) (spl1-next (spl2-exv Dsplr)) Dsplr ([x][x2][s] spl1-exv (splv-next s)).
- : lc (ls-tup-s1 Dstep) (spl1-tup DsplA DsplB) Dsplr ([x][x2][s] spl1-tup (DsplA' x x2 s) DsplB)
	<- lc Dstep DsplA Dsplr DsplA'.
- : lc (ls-tup-s2 Dstep) (spl1-tup DsplA DsplB) Dsplr ([x][x2][s] spl1-tup DsplA (DsplB' x x2 s))
	<- lc Dstep DsplB Dsplr DsplB'.
- : lc (ls-pi1-s Dstep) (spl1-pi1 Dspl) Dsplr ([x][x2][s] spl1-pi1 (Dspl' x x2 s))
	<- lc Dstep Dspl Dsplr Dspl'.
- : lc (ls-pi2-s Dstep) (spl1-pi2 Dspl) Dsplr ([x][x2][s] spl1-pi2 (Dspl' x x2 s))
	<- lc Dstep Dspl Dsplr Dspl'.
- : lc (ls-app-s1 Dstep) (spl1-app DsplA DsplB) Dsplr ([x][x2][s] spl1-app (DsplA' x x2 s) DsplB)
	<- lc Dstep DsplA Dsplr DsplA'.
- : lc (ls-app-s2 Dstep) (spl1-app DsplA DsplB) Dsplr ([x][x2][s] spl1-app DsplA (DsplB' x x2 s))
	<- lc Dstep DsplB Dsplr DsplB'.
%worlds () (lc _ _ _ _).
%total (D) (lc D _ _ _).

%% USES UNIQUENESS OF SPLITTING TO SHOW REDUCTION RESPECTS IT
split-eval-resp : split W E (pipe C _) -> split W E (pipe C' _) -> mred C V -> mred C' V -> type.
%mode split-eval-resp +Dspl +Dspl' +Dred -Dred'.
- : split-eval-resp _ _ Dred Dred.
%worlds () (split-eval-resp _ _ _ _).
%total {} (split-eval-resp _ _ _ _).


%% LEMMAS
sc1/app-r : of^ E A wor1 dot-t -> mstep wor1 E E' -> split wor1 E' (pipe C' _) -> mred C' (tup I _) -> split wor1 E (pipe C _) -> mred C (tup I _) -> type.


%% SPLITTING CORRECTNESS
sc1 : of^ E A wor1 dot-t -> mstep wor1 E E' -> split wor1 E' (pipe C' _) -> mred C' (tup I _) -> split wor1 E (pipe C _) -> mred C (tup I _) -> type.
%mode sc1 +Dof +Dstep +Dspl' +Dred' -Dspl -Dred.
sc2 : of^ E A wor2 dot-t -> mstep wor2 E E' -> split wor2 E' (pipe P' _) -> mred P' _ -> split wor2 E (pipe P _) -> mred P _ -> type.
%mode sc2 +Dof +Dstep +Dspl' +Dred' -Dspl -Dred.

%% STAGE ONE REDUCTION RULES

- : sc1 (of^-pi1 (of^-exv (of^-tup _ Dof2)) _) ms-pi1-r
	(spl1-exv Dspl1) (mred-tup Dred1 mred-ztup)
	(spl1-pi1 (spl1-exv (splv-tup Dspl1 Dspl2)))
	(mred-lett 
		(mred-tup (mred-pi1 (mred-tup Didem1 Didem2)) mred-ztup) 
		(mred-tup (mred-tup Dred1 Didem2) mred-ztup))
	<- idem Dred1 Didem1
	<- splv-total Dof2 Dspl2
	<- val-to-val Dspl2 Dval2
	<- val-auto Dval2 Didem2.
- : sc1 (of^-pi2 (of^-exv (of^-tup Dof1 _)) _) ms-pi2-r
	(spl1-exv Dspl2) (mred-tup mred-ztup Dred2)
	(spl1-pi2 (spl1-exv (splv-tup Dspl1 Dspl2)))
	(mred-lett 
		(mred-tup (mred-pi2 (mred-tup Didem1 Didem2)) mred-ztup) 
		(mred-tup (mred-tup Didem1 Dred2) mred-ztup))
	<- idem Dred2 Didem2
	<- splv-total Dof1 Dspl1
	<- val-to-val Dspl1 Dval1
	<- val-auto Dval1 Didem1.
- : sc1 Dof ms-app-r
	Dspl Dred
	(spl1-app (spl1-exv (splv-lam DsplM)) (spl1-exv DsplV))
	(mred-lett 
		(mred-lett 
			(mred-lett 
				(mred-tup DautoI (mred-tup (mred-tup mred-ztup mred-ztup) DautoB))
				(mred-app Dred'' mred-lam DautoV)
				)
			(mred-tup DautoV mred-ztup)
			)
		(mred-tup mred-lam mred-ztup)
		)
	<- spl1-total Dof (spl1-app (spl1-exv (splv-lam DsplM)) (spl1-exv (DsplV : splitval V Vi Vq)))
	<- split-eval-resp Dspl (DsplM V Vi Vq DsplV) Dred Dred''
	<- idem Dred (mred-tup DautoI DautoB)
	<- val-to-val DsplV DvalV
	<- val-auto DvalV DautoV.


%% STAGE ONE DONENESS MARKING
- : sc1 _ ms-tup-d 
		(spl1-exv (splv-tup Dsplv1 Dsplv2))	
		(mred-tup (mred-tup Dred1 Dred2) mred-ztup)
		(spl1-tup (spl1-exv Dsplv1) (spl1-exv Dsplv2)) 
		(mred-lett 
			(mred-lett 
				(mred-tup (mred-tup Didem1 Didem2) (mred-tup mred-ztup mred-ztup))
				(mred-tup Dred2 mred-ztup))
			(mred-tup Dred1 mred-ztup))
	<- idem Dred1 Didem1
	<- idem Dred2 Didem2.
%{- : sc1 (ms-next-d _)
		(spl1-exv splv-next) 
		(mred-tup mred-ztup mred-ztup)
		(spl1-next (spl2-exv Dsplr)) 
		(mred-tup mred-ztup mred-ztup).}%


%% STAGE ONE SUBSTEPS
- : sc1 (of^-pi1 Dof _) (ms-pi1-s Dstep) (spl1-pi1 Dspl') 
		(mred-lett 
			(mred-tup (mred-pi1 (DredI' : mred I' (tup I _))) _)
			(DredC' : mred C' (tup I' _))
		)
		(spl1-pi1 Dspl) (mred-lett (mred-tup (mred-pi1 DautoII2) DautoB) DredC)
	<- idem DredC' (mred-tup (DautoI' : mred I' I') _)
	<- mred-unique DautoI' DredI' (Deq : eq-term I' (tup I _))
	<- eq-cong2 tup Deq eq-term_ (Deq' : eq-term (tup I' _) (tup (tup I _) _))
	<- mred-resp DredC' eq-term_ Deq' (DredC2' : mred C' (tup (tup I _) _))
	<- sc1 Dof Dstep Dspl' DredC2' Dspl (DredC : mred C (tup (tup I _) B))
	<- idem DredC (mred-tup DautoII2 DautoB).
- : sc1 (of^-pi2 Dof _) (ms-pi2-s Dstep) (spl1-pi2 Dspl') 
		(mred-lett 
			(mred-tup (mred-pi2 (DredI' : mred I' (tup _ I))) _)
			(DredC' : mred C' (tup I' _))
		)
		(spl1-pi2 Dspl) (mred-lett (mred-tup (mred-pi2 DautoII2) DautoB) DredC)
	<- idem DredC' (mred-tup (DautoI' : mred I' I') _)
	<- mred-unique DautoI' DredI' (Deq : eq-term I' (tup _ I))
	<- eq-cong2 tup Deq eq-term_ (Deq' : eq-term (tup I' _) (tup (tup _ I) _))
	<- mred-resp DredC' eq-term_ Deq' (DredC2' : mred C' (tup (tup _ I) _))
	<- sc1 Dof Dstep Dspl' DredC2' Dspl (DredC : mred C (tup (tup _ I) B))
	<- idem DredC (mred-tup DautoII2 DautoB).

%% STAGE TWO DONENESS MARKING
- : sc2 _ ms-tup-d 
		(spl2-exv (splr-tup Dsplr1 Dsplr2)) mred-ztup
		(spl2-tup (spl2-exv Dsplr1) (spl2-exv Dsplr2)) (mred-tup mred-ztup mred-ztup).
- : sc2 _ ms-pi1-d 
		(spl2-exv (splr-pi1 Dsplr)) mred-ztup
		(spl2-pi1 (spl2-exv Dsplr)) mred-ztup.
- : sc2 _ ms-pi2-d 
		(spl2-exv (splr-pi2 Dsplr)) mred-ztup
		(spl2-pi2 (spl2-exv Dsplr)) mred-ztup.
- : sc2 _ ms-lam-d 
		(spl2-exv (splr-lam Dsplr)) mred-ztup
		(spl2-lam ([x][x2][splx] spl2-exv (Dsplr x x2 splx))) mred-ztup.
- : sc2 _ ms-app-d 
		(spl2-exv (splr-app Dsplr1 Dsplr2)) mred-ztup
		(spl2-app (spl2-exv Dsplr1) (spl2-exv Dsplr2)) (mred-tup mred-ztup mred-ztup).
- : sc2 _ ms-let-d 
		(spl2-exv (splr-let DsplrE DsplrM)) mred-ztup
		(spl2-let (spl2-exv DsplrE) ([x][x2][splx] spl2-exv (DsplrM x x2 splx))) (mred-tup mred-ztup mred-ztup).

%% STAGE TWO SUBSTEPS
- : sc2 (of^-pi1 Dof _) (ms-pi1-s Dstep) (spl2-pi1 Dspl') Dred' (spl2-pi1 Dspl) Dred
	<- sc2 Dof Dstep Dspl' Dred' Dspl Dred.
- : sc2 (of^-pi2 Dof _) (ms-pi2-s Dstep) (spl2-pi2 Dspl') Dred' (spl2-pi2 Dspl) Dred
	<- sc2 Dof Dstep Dspl' Dred' Dspl Dred.
- : sc2 (of^-tup Dof _) (ms-tup-s1 Dstep) (spl2-tup DsplA' DsplB) (mred-tup DredA' DredB) (spl2-tup DsplA DsplB) (mred-tup DredA DredB)
	<- sc2 Dof Dstep DsplA' DredA' DsplA DredA.
- : sc2 (of^-tup _ Dof) (ms-tup-s2 Dstep) (spl2-tup DsplA DsplB') (mred-tup DredA DredB') (spl2-tup DsplA DsplB) (mred-tup DredA DredB)
	<- sc2 Dof Dstep DsplB' DredB' DsplB DredB.
- : sc2 (of^-app Dof _ _) (ms-app-s1 Dstep) (spl2-app DsplA' DsplB) (mred-tup DredA' DredB) (spl2-app DsplA DsplB) (mred-tup DredA DredB)
	<- sc2 Dof Dstep DsplA' DredA' DsplA DredA.
- : sc2 (of^-app _ Dof _) (ms-app-s2 Dstep) (spl2-app DsplA DsplB') (mred-tup DredA DredB') (spl2-app DsplA DsplB) (mred-tup DredA DredB)
	<- sc2 Dof Dstep DsplB' DredB' DsplB DredB.
- : sc2 (of^-prev Dof) (ms-prev-s Dstep) (spl2-prev Dspl') (mred-pi2 Dred') (spl2-prev Dspl) (mred-pi2 Dred)
	<- sc1 Dof Dstep Dspl' Dred' Dspl Dred.
%{- : sc2 (ms-prev-ls Dstep) 
	(spl2-let (spl2-exv Dsplr) ([x][splx] spl2-prev (Dspl' x splx))) (mred-tup mred-ztup (mred-pi2 Dred')) 
	(spl2-prev Dspl) (mred-pi2 Dred) 
	<- lc Dstep Dspl' Dsplr Dred' Dspl Dred.}%

%worlds ()   (sc1 _ _ _ _ _ _) (sc2 _ _ _ _ _ _).
%total (D E) (sc1 D _ _ _ _ _) (sc2 E _ _ _ _ _).