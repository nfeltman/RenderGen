
%% TYPE WELL-FORMED
ty^wf : ty -> wor -> type.
%mode ty^wf +T +W.
ty^wf-unit	: ty^wf unit W.
ty^wf-prod	: ty^wf (prod A B) W
				<- ty^wf B W
				<- ty^wf A W.
ty^wf-arr	: ty^wf (arr A B) W
				<- ty^wf B W
				<- ty^wf A W.
ty^wf-fut	: ty^wf (fut A) wor1
				<- ty^wf A wor2.
%{ty^wf-curr	: ty^wf (curr T) wor1
				<- ty^wf T worM.}%
%worlds () (ty^wf _ _).

%% TYPING JUDGMENT
of^ : term -> ty -> wor -> type. %name of^ Dof.
%mode of^ +E -T +W.
of^-ztup	: of^ ztup unit W.
of^-tup	: of^ (tup E1 E2) (prod A B) W
			<- of^ E2 B W
			<- of^ E1 A W.
of^-pi1	: of^ (pi1 E) A W
			<- of^ E (prod A B) W.
of^-pi2	: of^ (pi2 E) B W
			<- of^ E (prod A B) W.
of^-lam 	: of^ (lam A ([x] M x)) (arr A B) W
			<- ({x: term} of^ x A W -> of^ (M x) B W)
			<- ty^wf A W.
of^-app  : of^ (app E1 E2) B W
			<- of^ E2 A W
			<- of^ E1 (arr A B) W.
%{of^-let  : of^ (let E ([x] M x)) B wor2
			<- of^ E A wor2
			<- ({x:term} of^ x A wor2 -> of^ (M x) B wor2). }%
of^-next	: of^ (next E) (fut A) wor1
			<- of^ E A wor2.
%{of^-letn : of^ (letn E M) B wor1
			<- of^ E (fut A) wor1
			<- ({x:term} of^ x A wor2 -> of^ (M x) B wor1).}% 
of^-prev	: of^ (prev E) A wor2
			<- of^ E (fut A) wor1.
%{of^-mono : of^ (mono E) (curr T) wor1
			<- of^ E T worM.
of^-letm : of^ (letm E M) T2 wor1
			<- of^ E (curr T1) wor1
			<- ({x:term} of^ x T1 worM -> of^ (M x) T2 wor1).}%

%block var-of : some {A : ty} {W : wor} block {x:term} {_ : of^ x A W}.
%worlds (var-of) (of^ _ _ _).

%% OUTPUTS OF TYPING ARE WELL-FORMED
of^-wf : of^ E T W -> ty^wf T W -> type.
%mode of^-wf +D1 -D2. 
- : of^-wf of^-ztup ty^wf-unit.
- : of^-wf (of^-tup Dof1 Dof2) (ty^wf-prod DwfA DwfB)
	<- of^-wf Dof1 DwfA
	<- of^-wf Dof2 DwfB.
- : of^-wf (of^-pi1 Dof) DwfA
	<- of^-wf Dof (ty^wf-prod DwfA DwfB).
- : of^-wf (of^-pi2 Dof) DwfB
	<- of^-wf Dof (ty^wf-prod DwfA DwfB).
- : of^-wf (of^-lam Dwf1 DofM) (ty^wf-arr Dwf1 Dwf2)
	<- ({x:term} {Dof : of^ x A W} {_ : of^-wf Dof Dwf1} of^-wf (DofM x Dof) Dwf2).
- : of^-wf (of^-app Dof1 Dof2) Dwf
	<- of^-wf Dof1 (ty^wf-arr _ Dwf). 
%{- : of^-wf (of^-let DofM DofE) Dwf2
	<- of^-wf DofE Dwf1
	<- ({x:term} {Dof : of^ x A wor2} {_ : of^-wf Dof Dwf1} of^-wf (DofM x Dof) Dwf2).}%
- : of^-wf (of^-next Dof) (ty^wf-fut Dwf)
	<- of^-wf Dof Dwf.
%{- : of^-wf (of^-letn DofM DofE) Dwf2
	<- of^-wf DofE (ty^wf-fut Dwf1)
	<- ({x:term} {Dof : of^ x A wor2} {_ : of^-wf Dof Dwf1} of^-wf (DofM x Dof) Dwf2).}%
- : of^-wf (of^-prev Dof) Dwf
	<- of^-wf Dof (ty^wf-fut Dwf).
%{- : of^-wf (of^-mono Dof) (ty^wf-curr Dwf)
	<- of^-wf Dof Dwf.
- : of^-wf (of^-letm DofM DofE) DwfM
	<- of^-wf DofE (ty^wf-curr DwfE)
	<- ({x:term} {Dof : of^ x A worM} of^-wf Dof DwfE -> of^-wf (DofM x Dof) DwfM).}%
%block var-of^-wf : 
	some {A : ty} {W : wor} {Dwf : ty^wf A W} 
	block {x:term} {Dof : of^ x A W} {_ : of^-wf Dof Dwf}.
%worlds (var-of^-wf) (of^-wf _ _).
%total D (of^-wf D _).

%% TYPES AT TWO ARE MONOTYPES
wor2-mono : ty^wf A wor2 -> ty-wf A -> type.
%mode wor2-mono +Dwf -Dwf'.
- : wor2-mono ty^wf-unit ty-wf-unit.
- : wor2-mono (ty^wf-prod Dwf1 Dwf2) (ty-wf-prod Dwf1' Dwf2')
	<- wor2-mono Dwf1 Dwf1'
	<- wor2-mono Dwf2 Dwf2'.
- : wor2-mono (ty^wf-arr Dwf1 Dwf2) (ty-wf-arr Dwf1' Dwf2')
	<- wor2-mono Dwf1 Dwf1'
	<- wor2-mono Dwf2 Dwf2'.
%worlds () (wor2-mono _ _).
%total (D) (wor2-mono D _).

%% TYPING RESPECTS IDENTITY
of^-resp : of^ M A W -> idty A B -> of^ M B W -> type.
%mode of^-resp +D1 +D2 -D3.
- : of^-resp Dof idty/refl Dof.
%block ofs-block : some {A : ty} {W : wor} block {x : term} {_ : of^ x A W}.
%worlds (ofs-block) (of^-resp _ _ _).
%total {} (of^-resp _ _ _).

%% LAMBDA VALUE INVERSION LEMMA
lam-inverts : of^ (lam A1 _) (arr A2 _) W -> idty A2 A1 -> type.
- : lam-inverts (of^-lam _ _) idty/refl.
%mode lam-inverts +O -I.
%worlds (ofs-block) (lam-inverts _ _).
%total {} (lam-inverts _ _).

%% LAMBDA ANNOTATION CONSISTENCY
lam-annot : of^ (lam A1 M) (arr A2 B) W -> of^ V A2 W -> of^ (lam A1 M) (arr A1 B) W -> of^ V A1 W -> type. 
- : lam-annot 
		(DofLam' : of^ (lam A1 M) (arr A2 B) W) 											%% \A1.M : A2->B
		(DofV' : of^ V A2 W) 															%% V : A2
		DofLam DofV 
    <- lam-inverts DofLam' (DidtyA : idty A2 A1)										%% A1 = A2
    <- idty-cong-arr DidtyA idty/refl (DidtyArr : idty (arr A2 B) (arr A1 B))			%% A2->B = A1->B
    <- of^-resp DofLam' DidtyArr DofLam													%% \A1.M : A1->B
    <- of^-resp DofV' DidtyA (DofV : of^ V A1 W).											%% V : A1
%mode lam-annot +O1 +O2 -O3 -O4.
%worlds (ofs-block) (lam-annot _ _ _ _).
%total {} (lam-annot _ _ _ _).

%{
%% UNIQUENESS OF TYPING
of^-unique : of^ M T1 W -> of^ M T2 W -> idty T1 T2 -> type.
%mode of^-unique +D1 +D2 -E.
- : of^-unique D D idty/refl.
- : of^-unique of^-ztup of^-ztup idty/refl.
- : of^-unique (of^-lam D1) (of^-lam D2) AtoBeq
    <- ({e:term} {D : of^ e A W} of^-unique (D1 e D) (D2 e D) Beq)
    <- idty-cong-arr idty/refl Beq AtoBeq.
- : of^-unique (of^-app (Mof1 : of^ M (arr A1 B1) W)
                      (Nof1 : of^ N A1 W))
              (of^-app (Mof2 : of^ M (arr A2 B2) W)
                      (Nof2 : of^ N A2 W))
              Beq
    <- of^-unique Mof1 Mof2 AtoBeq
    <- idty-inj-arr AtoBeq _ Beq.
%worlds (var-of) (of^-unique _ _ _).
%total D (of^-unique D _ _).
}%