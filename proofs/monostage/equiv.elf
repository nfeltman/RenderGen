

%% RESIDUAL EQUIVALENCE
reqv : term L -> term L -> type. %name reqv Deqv.
;; : reqv E1 E2 -> reqv E2 E3 -> reqv E1 E3. %infix left 4 ;;.
reqv-id : reqv E E.

reqv-lett-p : reqv (M Q1 Q2) (M' Q1' Q2') -> reqv (lett (exv (tup Q1 Q2)) M) (lett (exv (tup Q1' Q2')) M').
reqv-lett-r2 : reqv A (M Q1 Q2) -> reqv A (lett (exv (tup Q1 Q2)) M).
reqv-pi1 : reqv (pi1 (exv (tup Q1 Q2))) (exv Q1).
reqv-pi2 : reqv (pi2 (exv (tup Q1 Q2))) (exv Q2).
reqv-lett : reqv (lett (exv (tup Q1 Q2)) M) (M Q1 Q2).
reqv-let : reqv (let (exv Q) M) (M Q).
reqv-case-r1 : reqv (case (exv (inj1 Q)) M N) (M Q).
reqv-case-r2 : reqv (case (exv (inj2 Q)) M N) (N Q).
reqv-app : reqv (app (exv (lam M)) (exv V)) (M V).

reqv-tup-d : reqv (tup (exv Q1) (exv Q2)) (exv (tup Q1 Q2)).

reqv-app-s : reqv E1 E1' -> reqv E2 E2' -> reqv (app E1 E2) (app E1' E2').
reqv-let-s : reqv E E' -> ({x : term L} reqv (M x : term L) (M' x)) -> reqv (let E M) (let E' M').
reqv-tup-s :  reqv E1 E1' -> reqv E2 E2' -> reqv (tup E1 E2) (tup E1' E2').
reqv-pi1-s : reqv E E' -> reqv (pi1 E) (pi1 E').
reqv-pi2-s : reqv E E' -> reqv (pi2 E) (pi2 E').
reqv-inj1-s : reqv E E' -> reqv (inj1 E) (inj1 E').
reqv-inj2-s : reqv E E' -> reqv (inj2 E) (inj2 E').
reqv-roll-s : reqv E E' -> reqv (roll E) (roll E').
reqv-unrl-s : reqv E E' -> reqv (unrl E) (unrl E').
reqv-case-s : reqv E E' -> ({x} reqv (M x) (M' x)) -> ({x} reqv (N x) (N' x)) -> reqv (case E M N) (case E' M' N').
reqv-exv-s : reqv E E' -> reqv (exv E) (exv E').
reqv-lam-s : ({x} reqv (M x) (M' x)) -> reqv (lam M) (lam M').
reqv-lett-s2 : ({l1:term L}{l2 : term L} reqv (M l1 l2) (M' l1 l2)) -> reqv (lett E M) (lett E M').

reqv-lift-base : reqv Q (let Q ([x] (exv x))).
reqv-lift-pi1 : reqv A (let Q M) -> reqv (pi1 A) (let Q ([x] (pi1 (M x)))).
reqv-lift-pi2 : reqv A (let Q M) -> reqv (pi2 A) (let Q ([x] (pi2 (M x)))).
reqv-lift-tup1 : reqv A (let Q M) -> ({x} eq-term E (E' x)) -> reqv (tup A E) (let Q ([x] (tup (M x) (E' x)))).
reqv-lift-tup2 : reqv A (let Q M) -> ({x} eq-term E (E' x)) -> reqv (tup E A) (let Q ([x] (tup (E' x) (M x)))).
reqv-lift-app1 : reqv A (let Q M) -> ({x} eq-term E (E' x)) -> reqv (app A E) (let Q ([x] (app (M x) (E' x)))).
reqv-lift-app2 : reqv A (let Q M) -> ({x} eq-term E (E' x)) -> reqv (app E A) (let Q ([x] (app (E' x) (M x)))).
reqv-lift-chain : reqv A (let Q M) -> ({x} eq-term E (E' x)) -> reqv (let A ([_] E)) (let Q ([x] let (M x) ([_] E' x))).
reqv-lift-lett : ({x1:term L}{x2 : term L} reqv (A x1 x2) (let Q ([l] M l x1 x2))) -> reqv (lett E A) (let Q ([l] lett E (M l))).
reqv-lift-case : reqv A (let Q M) -> ({y}{x} eq-term (B1 y) (B1' x y)) -> ({y}{x} eq-term (B2 y) (B2' x y)) -> 
			reqv (case A B1 B2) (let Q ([x] case (M x) (B1' x) (B2' x))).


have-reqv : reqv E V -> reqv E V -> type.
%mode have-reqv +Dred -Dred'.
- : have-reqv Dred Dred.
%worlds (term-block) (have-reqv _ _).
%total {} (have-reqv _ _).


%% RESIDUAL EQUIVALENCE RESPECTS TERM EQUALITY
reqv-resp : reqv E V -> eq-term E E' -> eq-term V V' -> reqv E' V' -> type.
%mode reqv-resp +Dred +DeqE +Didty -Dred'.
- : reqv-resp Dred eq-term_ eq-term_ Dred.
%worlds (term-block) (reqv-resp _ _ _ _).
%total {} (reqv-resp _ _ _ _).

