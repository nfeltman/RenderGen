
%% MULTISTEPS

step* : term -> term -> type.
step*-id : step* E E.
step*-step : step E1 E2 -> step* E2 E3 -> step* E1 E3.

%% MULTISTEP CHAIN
step*/compose : step* E1 E2 -> step* E2 E3 -> step* E1 E3 -> type.
%mode step*/compose +Dchain1 +Dchain2 -Dchain.
- : step*/compose step*-id C C.
- : step*/compose (step*-step S C1) C2 (step*-step S C')
	<- step*/compose C1 C2 C'.
%worlds () (step*/compose _ _ _).
%total D (step*/compose D _ _).

%% MULTISTEP RESPECTS EQUALITY
step*/resp : step* E1 E2 -> eq-term E1 E1' -> eq-term E2 E2' -> step* E1' E2' -> type.
%mode step*/resp +Dchain +Deq1 +Deq2 -Dchain'.
- : step*/resp D eq-term_ eq-term_ D.
%worlds () (step*/resp _ _ _ _).
%total {} (step*/resp _ _ _ _).

%% CHAIN IS A CONGRUENCE FOR SUBSTEP RULES
step*/substep : {F : term -> term} ({e} {e'} step e e' -> step (F e) (F e')) -> step* E E' -> step* (F E) (F E') -> type.
%mode step*/substep +F +R +Dchain -Dchain'.
- : step*/substep F R step*-id step*-id.
- : step*/substep F R (step*-step (Dstep : step E E') Dchain) (step*-step (R E E' Dstep) Dchain')
	<- step*/substep F R Dchain Dchain'.
%worlds () (step*/substep _ _ _ _).
%total {D} (step*/substep _ _ D _).

%% CONFLUENCE
conf : term -> term -> type.
conf_ : step* E1 E -> step* E2 E -> conf E1 E2.

%% CONFLUENCE IS SYMMETRIC
conf/sym : conf E1 E2 -> conf E2 E1 -> type.
%mode conf/sym +Dconf1 -Dconf2.
- : conf/sym (conf_ P1 P2) (conf_ P2 P1).
%worlds () (conf/sym _ _).
%total {} (conf/sym _ _).

%% CONFLUENCE IS TRANSITIVE HELPER (need helper because termination thing)
%{conf/trans/help : step* E1 E2 -> step* E3 E2 -> step* E3 E4 -> step* E5 E4 -> conf E1 E5 -> type.
%mode conf/trans/help +Dpath1 +Dpath2 +Dpath3 +Dpath4 -Dconf.
- : conf/trans/help P1 step*-id P3 P4 (conf_ P P4)
	<- step*/compose P1 P3 P.
- : conf/trans/help P1 P2 step*-id P4 (conf_ P1 P)
	<- step*/compose P4 P2 P.
- : conf/trans/help P1 (step*-step S2 P2) (step*-step S3 P3) P4 Dconf
	<- step/unique S3 S2 Deq
	<- step*/resp P3 Deq eq-term_ P3'
	<- conf/trans/help P1 P2 P3' P4 Dconf.
%worlds () (conf/trans/help _ _ _ _ _).
%total D (conf/trans/help _ D _ _ _).


%% CONFLUENCE IS TRANSITIVE
conf/trans : conf E1 E2 -> conf E2 E3 -> conf E1 E3 -> type.
%mode conf/trans +Dconf1 +Dconf2 -Dconf.
- : conf/trans (conf_ P1 P2) (conf_ P3 P4) Dconf
	<- conf/trans/help P1 P2 P3 P4 Dconf.
%worlds () (conf/trans _ _ _).
%total {} (conf/trans _ _ _).
}%

%% CONFLUENCE IS A CONGRUENCE FOR SUBSTEP RULES
conf/substep : {F : term -> term} ({e} {e'} step e e' -> step (F e) (F e')) -> conf E E' -> conf (F E) (F E') -> type.
%mode conf/substep +F +R +Dcong -Dcong'.
- : conf/substep F R (conf_ P1 P2) (conf_ P1' P2')
	<- step*/substep F R P1 P1'
	<- step*/substep F R P2 P2'.
%worlds () (conf/substep _ _ _ _).
%total {D} (conf/substep _ _ D _).

%% EQUAL THINGS ARE CONFLUENT
conf\eq : eq-term A B -> conf A B -> type.
%mode conf\eq +Deq -Dconf.
- : conf\eq eq-term_ (conf_ step*-id step*-id).
%worlds () (conf\eq _ _).
%total {D} (conf\eq D _).

%% BIGSTEP
step** : term -> term -> type.
step**_ : step* E V -> val V -> step** E V.

%% BIGSTEP IS UNIQUE
step**-unique_ : step* E V -> val V -> step* E V' -> val V' -> eq-term V V' -> type.
%mode step**-unique_ +Dpath +Dval +Dpath' +Dval' -Deq.
- : step**-unique_ step*-id _ step*-id _ eq-term_.
- : step**-unique_ (step*-step Dstep Dpath) Dval (step*-step Dstep' Dpath') Dval' DeqV
	<- step-unique Dstep' Dstep Deq
	<- step*/resp Dpath' Deq eq-term_ Dpath''
	<- step**-unique_ Dpath Dval Dpath'' Dval' DeqV.
- : step**-unique_ step*-id Dval (step*-step Dstep _) _ Deq
	<- excl-val-step Dstep Dval Dfalse
	<- false\eq-term Dfalse _ _ Deq.
- : step**-unique_ (step*-step Dstep _) _ step*-id Dval Deq
	<- excl-val-step Dstep Dval Dfalse
	<- false\eq-term Dfalse _ _ Deq.
%worlds () (step**-unique_ _ _ _ _ _).
%total (D) (step**-unique_ D _ _ _ _).

step**-unique : step** E V -> step** E V' -> eq-term V V' -> type.
%mode step**-unique +Dred +Dred' -Deq.

%% LETT EVAL INVERSION
lett-big-invert_ :  step* (lett E M) V -> val V -> step* E (tup V1 V2) -> val (tup V1 V2) -> step* (M V1 V2) V -> type.
%mode lett-big-invert_ +Dstep +Dval -DstepE -DvalE -DstepM.
- : lett-big-invert_ (step*-step (ss-lett-s Dstep) Dpath) Dval (step*-step Dstep Dpath') Dval' DpathM
	<- lett-big-invert_ Dpath Dval Dpath' Dval' DpathM.
- : lett-big-invert_ (step*-step (ss-lett-r Dval) Dpath) _ step*-id Dval Dpath.
%worlds () (lett-big-invert_ _ _ _ _ _).
%total (D) (lett-big-invert_ D _ _ _ _).

lett-big-invert :  step** (lett E M) V -> step** E (tup V1 V2) -> step** (M V1 V2) V -> type.
%mode lett-big-invert +Dstep -DstepE -DstepM.
- : lett-big-invert (step**_ Dpath Dval) (step**_ Dpath' Dval') (step**_ DpathM Dval)
	<- lett-big-invert_ Dpath Dval Dpath' Dval' DpathM.
%worlds () (lett-big-invert _ _ _).
%total (D) (lett-big-invert D _ _).