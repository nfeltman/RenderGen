%{ monostage.elf }%

%% TABLE ENTRY
variable : term -> type.
%mode variable +E.

%% VALUE
done : wor -> term -> type. %name done Ddone.
%%mode done +W +E.
done-ztup	: done W ztup.
done-tup	: done W (tup E1 E2)
				<- done W E2
				<- done W E1.
val-lam		: done wor1 (lam _ _).
val-next	: done wor1 (next E)
				<- variable E.
res-pi1		: done wor2 (pi1 E)
				<- done wor2 E.
res-pi2		: done wor2 (pi2 E)
				<- done wor2 E.
res-lam		: done wor2 (lam _ M)
				<- {x : term} variable x -> done wor2 x -> done wor2 (M x).
res-app		: done wor2 (app E1 E2)
				<- done wor2 E2
				<- done wor2 E1.
res-let		: done wor2 (let E M)
				<- done wor2 E
				<- {x:term} variable x -> done wor2 x -> done wor2 (M x).


%% M STEP - SUBSTEP RULES
mstep : wor -> term -> term -> type.
%%mode mstep +W +E -E'.
ms-tup-s1	: mstep W (tup E1 E2) (tup E1' E2)
			<- mstep W E1 E1'.
ms-tup-s2	: mstep W (tup E1 E2) (tup E1 E2')
			<- done W E1
			<- mstep W E2 E2'.
ms-pi1-s	: mstep W (pi1 E) (pi1 E')
			<- mstep W E E'.
ms-pi2-s	: mstep W (pi2 E) (pi2 E')
			<- mstep W E E'.
ms-app-s1	: mstep W (app E1 E2) (app E1' E2)
			<- mstep W E1 E1'.
ms-app-s2	: mstep W (app E1 E2) (app E1 E2')
			<- done W E1
			<- mstep W E2 E2'.
ms-let-s1	: mstep W (let E M) (let E' M)
			<- mstep W E E'.
ms-lett-s1	: mstep W (lett E M) (lett E' M)
			<- mstep W E E'.
ms-lam-s	: mstep wor2 (lam T M) (lam T M')
			<- {x:term} variable x -> done wor2 x -> mstep wor2 (M x) (M' x).
ms-let-s2	: mstep wor2 (let E M) (let E M')
			<- done wor2 E
			<- {x:term} variable x -> done wor2 x -> mstep wor2 (M x) (M' x).

%% M STEP - REDUCTION RULES
ms-pi1-r	: mstep wor1 (pi1 (tup E1 E2)) E1
			<- done wor1 (tup E1 E2).
ms-pi2-r	: mstep wor1 (pi2 (tup E1 E2)) E2
			<- done wor1 (tup E1 E2).
ms-app-r	: mstep wor1 (app (lam _ M) E) (M E)
			<- done wor1 E.
ms-let-r	: mstep wor1 (let E M) (M E)
			<- done wor1 E.

			
%% SECOND-STAGE VARIABLE STEP
mstep* : term -> term -> (term -> term) -> type.
%%mode mstep* +E -Q -E'.
ms*-tup-s1	: mstep* (tup E1 E2) Q ([x] tup (E1' x) E2)
			<- mstep* E1 Q E1'.
ms*-tup-s2	: mstep* (tup E1 E2) Q ([x] tup E1 (E2' x))
			<- done wor1 E1
			<- mstep* E2 Q E2'.
ms*-pi1-s	: mstep* (pi1 E) Q ([x] pi1 (E' x))
			<- mstep* E Q E'.
ms*-pi2-s	: mstep* (pi2 E) Q ([x] pi2 (E' x))
			<- mstep* E Q E'.
ms*-app-s1	: mstep* (app E1 E2) Q ([x] app (E1' x) E2)
			<- mstep* E1 Q E1'.
ms*-app-s2	: mstep* (app E1 E2) Q ([x] app E1 (E2' x))
			<- done wor1 E1
			<- mstep* E2 Q E2'.
ms*-let-s1	: mstep* (let E M) Q ([x] let (E' x) M)
			<- mstep* E Q E'.

			
%% STAGING FEATURES
ms-next-s	: mstep wor1 (next E) (next E')
			<- mstep wor2 E E'.
ms*-next-r	: mstep* (next E) E ([x:term] next x)
			<- done wor2 E.
ms-prev-s	: mstep wor2 (prev E) (prev E')
			<- mstep wor1 E E'.
ms-prev-s*	: mstep wor2 (prev E) (let Q ([x] prev (E' x)))
			<- mstep* E Q E'.
ms-prev-r	: mstep wor2 (prev (next E)) E
			<- done wor2 E. %% should be a stricter criterion
			
			
%%  USEFUL BLOCKS
%block spec-block : some {A : ty} block {x:term} {dvar : variable x} {dof : of x A wor2} {ddone : done wor2 x}.