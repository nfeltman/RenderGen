%{ liftr.elf }%

%% TYPES
ty : type. %name ty T.
unit	: ty.
prod	: ty -> ty -> ty.
arr		: ty -> ty -> ty.
arr+	: ty -> ty -> ty -> ty.
fut		: ty -> ty.
curr	: ty -> ty.
%freeze ty.

%% LANG (little trick that makes translations a lot easier later)
lang : type.
lang0 : lang.
lang1 : lang.
lang2 : lang.
%freeze lang.

%% TERMS
term : lang -> type. %name term E.
ztup  : term L.
tup   : term L -> term L -> term L.
pi1   : term L -> term L.
pi2   : term L -> term L.
lam   : (term L -> term L) -> term L.
app   : term L -> term L -> term L.
let   : term L -> (term L -> term L) -> term L.
lett  : term L -> (term L -> term L -> term L) -> term L.
next  : term L -> term L.
%{letn  : term L -> (term L -> term L) -> term L.}%
prev  : term L -> term L.
%{mono  : term L -> term L.}%
%{letm  : term L -> (term L -> term L) -> term L.}%
exv   : term L -> term L.

%block term-block : some {L : lang} block {x : term L}.
%worlds (term-block) (term _).
%freeze term.

%% HOLES
lett-hole = ([x] lett x M).
tup-hole-1 = ([x] tup x E).
tup-hole-2 = ([x] tup E x).

%% TERM EQUALITY
eq-term  : term L -> term L -> type. %name eq-term Deq.
eq-term_ : eq-term E E.

%abbrev `eq-term_ = ([x : term L] eq-term_ : eq-term E E).
%abbrev ``eq-term_ = ([x : term L][y : term L] eq-term_ : eq-term E E).

%% FALSE YIELDS ANY EQUALITY
false\eq-term : false -> {E} {E'} eq-term E E' -> type.
%mode false\eq-term +E +E' +Dfalse -Deq.
%worlds (term-block) (false\eq-term _ _ _ _).
%total {} (false\eq-term _ _ _ _).

eq-term-sym : eq-term A B -> eq-term B A -> type.
%mode eq-term-sym +D1 -D2.
- : eq-term-sym eq-term_ eq-term_.
%worlds (term-block) (eq-term-sym _ _).
%total {} (eq-term-sym _ _).

eq-term-trans : eq-term A B -> eq-term B C -> eq-term A C -> type.
%mode eq-term-trans +D1 +D2 -D3.
- : eq-term-trans eq-term_ eq-term_ eq-term_.
%worlds (term-block) (eq-term-trans _ _ _).
%total {} (eq-term-trans _ _ _).

%% TERM EQUALITY IS A CONGRUENCE
eq-cong/lam : ({x} eq-term (M x) (M' x)) -> eq-term (lam M) (lam M') -> type.
%mode eq-cong/lam +Deq -Deq'.
- : eq-cong/lam ([x] eq-term_) eq-term_.
%worlds (term-block) (eq-cong/lam _ _).
%total {} (eq-cong/lam _ _).

eq-cong/1 : {F : (term L -> term L) -> term L} ({x} eq-term (M x) (M' x)) -> eq-term (F M) (F M') -> type.
%mode eq-cong/1 +F +Deq -Deq'.
- : eq-cong/1 F ([x] eq-term_) eq-term_.
%worlds (term-block) (eq-cong/1 _ _ _).
%total {} (eq-cong/1 _ _ _).

eq-cong/let : eq-term E1 E1' -> ({x} eq-term (E2 x) (E2' x)) -> eq-term (let E1 E2) (let E1' E2') -> type.
%mode eq-cong/let +Deq +E -Deq'.
- : eq-cong/let eq-term_ _ eq-term_.
%worlds (term-block) (eq-cong/let _ _ _).
%total {} (eq-cong/let _ _ _).

eq-cong/lett : eq-term E1 E1' -> ({x}{y} eq-term (E2 x y) (E2' x y)) -> eq-term (lett E1 E2) (lett E1' E2') -> type.
%mode eq-cong/lett +Deq +E -Deq'.
- : eq-cong/lett eq-term_ _ eq-term_.
%worlds (term-block) (eq-cong/lett _ _ _).
%total {} (eq-cong/lett _ _ _).

eq-cong : {F : term L -> term L} eq-term E E' -> eq-term (F E) (F E') -> type.
%mode eq-cong +F +Deq -Deq'.
- : eq-cong _ eq-term_ eq-term_.
%worlds (term-block) (eq-cong _ _ _).
%total {} (eq-cong _ _ _).

eq-cong2 : {F : term L -> term L -> term L} eq-term E1 E1' -> eq-term E2 E2' -> eq-term (F E1 E2) (F E1' E2') -> type.
%mode eq-cong2 +F +Deq1 +De2 -Deq'.
- : eq-cong2 _ eq-term_ eq-term_ eq-term_.
%worlds (term-block) (eq-cong2 _ _ _ _).
%total {} (eq-cong2 _ _ _ _).

eq-cong/0/2 : {F : term L -> (term L -> term L -> term L) -> term L} 
  (eq-term E1 E1') -> 
  ({x}{y} eq-term (E2 x y) (E2' x y)) -> 
  (eq-term (F E1 E2) (F E1' E2')) -> type.
%mode eq-cong/0/2 +F +Deq1 +De2 -Deq'.
- : eq-cong/0/2 _ eq-term_ ([x][y] eq-term_) eq-term_.
%worlds (term-block) (eq-cong/0/2 _ _ _ _).
%total {} (eq-cong/0/2 _ _ _ _).

eq-cong/1/1 : {F : (term L -> term L) -> (term L -> term L) -> term L} 
  ({x} eq-term (E1 x) (E1' x)) -> 
  ({y} eq-term (E2 y) (E2' y)) -> 
  (eq-term (F E1 E2) (F E1' E2')) -> type.
%mode eq-cong/1/1 +F +Deq1 +De2 -Deq'.
- : eq-cong/1/1 _ ([x] eq-term_) ([y] eq-term_) eq-term_.
%worlds (term-block) (eq-cong/1/1 _ _ _ _).
%total {} (eq-cong/1/1 _ _ _ _).

%% TERM EQUALITY IS WHATEVER THE OPPOSITE OF A CONGRUENCE IS

eq-gnoc/tup : eq-term (tup E1 E2) (tup E1' E2') -> eq-term E1 E1' -> eq-term E2 E2' ->  type.
%mode eq-gnoc/tup +Deq1 -De2 -Deq'.
- : eq-gnoc/tup eq-term_ eq-term_ eq-term_.
%worlds (term-block) (eq-gnoc/tup _ _ _).
%total {} (eq-gnoc/tup _ _ _).

eq-gnoc/lam : eq-term (lam M) (lam M') -> ({x} eq-term (M x) (M' x)) -> type.
%mode eq-gnoc/lam +Deq1 -Deq'.
- : eq-gnoc/lam eq-term_ ([x] eq-term_).
%worlds (term-block) (eq-gnoc/lam _ _).
%total {} (eq-gnoc/lam _ _).


%% TYPE IDENTITY 
eq-ty : ty -> ty -> type.
eq-ty_ : eq-ty T T.

eq-ty-sym : eq-ty A B -> eq-ty B A -> type.
%mode eq-ty-sym +D1 -D2.
- : eq-ty-sym eq-ty_ eq-ty_.
%worlds () (eq-ty-sym _ _).
%total {} (eq-ty-sym _ _).

eq-ty-cong :
  {F : ty -> ty -> ty}
  eq-ty A1 A2 ->
  eq-ty B1 B2 ->
  eq-ty (F A1 B1) (F A2 B2) -> type.
%mode eq-ty-cong +D1 +D2 +F -D3.
- : eq-ty-cong _ eq-ty_ eq-ty_ eq-ty_.
%worlds () (eq-ty-cong _ _ _ _).
%total {} (eq-ty-cong _ _ _ _).

eq-ty-cong3 :
  {F : ty -> ty -> ty -> ty}
  eq-ty A1 A2 ->
  eq-ty B1 B2 ->
  eq-ty C1 C2 ->
  eq-ty (F A1 B1 C1) (F A2 B2 C2) -> type.
%mode eq-ty-cong3 +D1 +D2 +D3 +F -D3.
- : eq-ty-cong3 _ eq-ty_ eq-ty_ eq-ty_ eq-ty_.
%worlds () (eq-ty-cong3 _ _ _ _ _).
%total {} (eq-ty-cong3 _ _ _ _ _).


eq-ty-inj-arr :
  eq-ty (arr A1 B1) (arr A2 B2) ->
  eq-ty A1 A2 ->
  eq-ty B1 B2 -> type.
%mode eq-ty-inj-arr +D1 -D2 -D3.
- : eq-ty-inj-arr eq-ty_ eq-ty_ eq-ty_.
%worlds () (eq-ty-inj-arr _ _ _).
%total {} (eq-ty-inj-arr _ _ _).

%% LANGUAGE EQUALITY
eq-lang : lang -> lang -> type.
eq-lang_ : eq-lang L L.
neq-lang : lang -> lang -> type.
neq-lang_01 : neq-lang lang0 lang1.
neq-lang_02 : neq-lang lang0 lang2.
neq-lang_10 : neq-lang lang1 lang0.
neq-lang_12 : neq-lang lang1 lang2.
neq-lang_20 : neq-lang lang2 lang0.
neq-lang_21 : neq-lang lang2 lang1.

%% THINGS CAN'T BE BOTH EQUAL AND NOT-EQUAL
excl-eq-neq-lang : eq-lang L1 L2 -> neq-lang L1 L2 -> false -> type.
%mode excl-eq-neq-lang +Deq +Dneq -Dfalse.
%worlds () (excl-eq-neq-lang _ _ _).
%total {} (excl-eq-neq-lang _ _ _).


%% TERMS CANNOT DEPEND ON TERMS OF A DIFFERENT LANGUAGE
lang-indep : neq-lang L1 L2 -> {E : term L1 -> term L2} ({x : term L1} eq-term (E x) E') -> type.
%mode lang-indep +Dneq +E -Deq.
- : lang-indep Dneq _ ([x] eq-term_).
- : lang-indep Dneq ([x] tup (E1 x) (E2 x)) Deq
  <- lang-indep Dneq E1 Deq1
  <- lang-indep Dneq E2 Deq2
  <- {x} eq-cong2 tup (Deq1 x) (Deq2 x) (Deq x).
- : lang-indep Dneq ([x] pi1 (E x)) Deq'
  <- lang-indep Dneq E Deq
  <- {x} eq-cong pi1 (Deq x) (Deq' x).
- : lang-indep Dneq ([x] pi2 (E x)) Deq'
  <- lang-indep Dneq E Deq
  <- {x} eq-cong pi2 (Deq x) (Deq' x).
- : lang-indep Dneq ([x] lam ([y] E y x)) Deq'
  <- ({y} lang-indep Dneq (E y) ([x] Deq x y))
  <- {x} eq-cong/lam (Deq x) (Deq' x).
- : lang-indep Dneq ([x] app (E1 x) (E2 x)) Deq
  <- lang-indep Dneq E1 Deq1
  <- lang-indep Dneq E2 Deq2
  <- {x} eq-cong2 app (Deq1 x) (Deq2 x) (Deq x).
- : lang-indep Dneq ([x] let (E x) ([y] M y x)) Deq
  <- lang-indep Dneq E DeqE
  <- ({y} lang-indep Dneq (M y) ([x] DeqM x y))
  <- {x} eq-cong/let (DeqE x) (DeqM x) (Deq x).
- : lang-indep Dneq ([x] lett (E x) ([y][z] M y z x)) Deq
  <- lang-indep Dneq E DeqE
  <- ({y}{z} lang-indep Dneq (M y z) ([x] DeqM x y z))
  <- {x} eq-cong/lett (DeqE x) (DeqM x) (Deq x).
- : lang-indep Dneq ([x] next (E x)) Deq'
  <- lang-indep Dneq E Deq
  <- {x} eq-cong next (Deq x) (Deq' x).
- : lang-indep Dneq ([x] prev (E x)) Deq'
  <- lang-indep Dneq E Deq
  <- {x} eq-cong prev (Deq x) (Deq' x).
- : lang-indep Dneq ([x] exv (E x)) Deq'
  <- lang-indep Dneq E Deq
  <- {x} eq-cong exv (Deq x) (Deq' x).

%worlds (term-block) (lang-indep _ _ _).
%total (D) (lang-indep _ D _).