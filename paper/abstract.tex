Staged programming languages assign a stage to each expression and
evaluate each expression in its assigned stage.  For example, in a
two-staged program, some expressions are evaluated in the first stage
and others in the second stage.  Programming languages, evaluation
strategies, and type systems for staged programs where stages roughly
correspond to the arrival order of inputs have been studied
extensively in the areas of partial evaluation and meta programming.

In this paper, we consider staged programs written in a typed lambda
calculus with a $\fut$ modality denoting computation in a later
stages and present techniques for splitting them into multi-pass
programs. Such multi-pass programs evaluate in a sequence of
evaluations of unstaged, conventional programs each of which
corresponds to a pass.  Conceived in the 80's by J{\o}rring and
Scherlis, this {\em pass-separation} technique has been studied, but
existing techniques are either manual or applicable only to simple programs
that lack important features such as recursion and first-class
functions.


% We make no restrictions on the kinds of programs that can
% be written.  We also present an implementation.
% %

Since we build on a lambda calculus, our techniques enable the
programmer to write staged programs by using powerful programming
abstractions in a composable and modular fashion. Our splitting
transformation maps such programs into multi-pass programs that can
run significantly more efficiently by assigning frequent computations
to earlier passes so that they can be reused (cheaply) later.  Our
experiments based on a prototype implementation show that our
splitting algorithm is able perform highly non-trivial algorithmic
transformations, sometimes automatically improving efficiency
asymptotically by nearly a linear factor.  Since splitting
transformation takes place at compile time, these benefits are
achieved without significant run-time penalty.

% The motivations for pass separation are 1) improvements in efficiency
% by assigning frequent computations to earlier passes so that they can
% be re-used (cheaply) later and, 2) performing such scheduling
% statically at compile time without loss of any generality.  To assess
% the effectiveness of our techniques for pass separation, we consider
% several examples and demonstrate that our implementation is able to
% perform pass separation statically as expected.  In a particularly
% interesting example, involving recursion and recursive data, we show
% that our techniques perform highly non-trivial algorithmic
% transformations, improving efficiency asymptotically by nearly a
% linear factor.




% Many algorithms can perform useful work before receiving all of their inputs.
% If we regard those inputs as arriving at different \emph{stages} of the
% computation, then we can \emph{split} those algorithms into, for each stage, a
% function performing all the work dependent only on the available inputs.

% Prior work on splitting has been limited to simple, imperative languages; in
% this paper, we extend splitting to \lang, a typed lambda calculus equipped with
% a modal staging operator, allowing us to split recursive and higher-order
% functions.

% These new features allow us to express some familiar algorithms which, when
% split, yield asymptotic improvements; for example, quickselect of the $k$th
% smallest element of a list $l$ splits into (1) sorting $l$ into a binary search
% tree, then (2) finding the tree's $k$th leftmost element.

% % something about compositional, cross-cutting code
