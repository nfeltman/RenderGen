%!TEX root = paper.tex

Staged programming languages assign a stage to each program expression
and evaluate each expression in its assigned stage. A common use of
staged languages is to describe programs where inputs arrive at
different times or rates. In this paper we present an algorithm for
statically {\em splitting} these mixed-staged programs into two
unstaged, but dependent, programs where the outputs of the first
program can be efficiently reused across multiple invocations of the
second. While previous algorithms for performing this transformation
(also called \emph{pass separation} and \emph{data specialization})
were limited to operate on simpler, imperative languages, we define a
splitting algorithm for an explicitly-two-stage, typed lambda
calculus \lang\ with a $\fut$ modality denoting computation at a later
stage, and a $\curr$ modality noting purely first-stage code.  Most
notably, the algorithm splits mixed-stage recursive and higher-order
functions.  We prove the dynamic correctness of our splitting
algorithm with respect to a partial-evaluation semantics, and
mechanize this proof in Twelf. We also implement the algorithm
in a prototype compiler, and demonstrate that the ability to split
programs in a language featuring recursion and higher-order features
enables non-trivial algorithmic transformations that
improve code efficiency and also facilitates modular 
expression of staged programs.

% todo: static transformation carried out prior to any of the programs
% inputs being available, and thus has low runtime overhead (and,
% unline partial evaluation, is applicable when dynamic code
% generation is not possible)
