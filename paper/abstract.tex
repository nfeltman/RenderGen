A staged program is a program where expressions are assigned to a
stage corresponding to their order of evaluation.  For example, in a
two-staged program, some of the inputs become available in stage-1 and
others in stage-2.  Evaluation of such a program proceeds by
evaluating all the stage-1 expressions to construct a stage-2
expression, which is then evaluated in stage-2.  Programming
languages, evaluation strategies, and type systems for staged programs
have been studied extensively in the areas of partial evaluation and
meta programming.

In this paper, we present techniques for splitting staged programs
into a multi-pass program, where each pass consists of an un-staged,
conventional program.  To evaluate a multi-pass program, we evaluate
each pass, passing the output to next pass; the final pass produces
the result.  This technique, called {\em pass separation} was
conceived in the 80`s but J{\o}rring and Scherlis and has been studied
but previously proposed technique all apply only to simple programs
that lack important features such as recursion and first-class
functions.  Our techniques, formalized by considering a staged lambda
calculus, make no restrictions on the kinds of programs that can be
written.  We also present an implementation. 

The motivations for pass separation are 1) improvements in efficiency
by assigning frequent computations to earlier passes so that they can
be re-used (cheaply) later and, 2) performing such scheduling
statically at compile time without loss of any generality.  To assess
the effectiveness of our techniques for pass separation, we consider
several examples and demonstrate that our implementation is able to
perform pass separation statically as expected.  In a particularly
interesting example, involving recursion and recursive data, we show
that our techniques perform highly non-trivial algorithmic
transformations, improving efficiency asymptotically by nearly a
linear factor.




% Many algorithms can perform useful work before receiving all of their inputs.
% If we regard those inputs as arriving at different \emph{stages} of the
% computation, then we can \emph{split} those algorithms into, for each stage, a
% function performing all the work dependent only on the available inputs.

% Prior work on splitting has been limited to simple, imperative languages; in
% this paper, we extend splitting to \lang, a typed lambda calculus equipped with
% a modal staging operator, allowing us to split recursive and higher-order
% functions.

% These new features allow us to express some familiar algorithms which, when
% split, yield asymptotic improvements; for example, quickselect of the $k$th
% smallest element of a list $l$ splits into (1) sorting $l$ into a binary search
% tree, then (2) finding the tree's $k$th leftmost element.

% % something about compositional, cross-cutting code
