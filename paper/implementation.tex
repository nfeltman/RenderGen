%!TEX root = paper.tex

\section {Implementation}
\label{sec:implementation}

\begin{abstrsyn}
We have a Standard ML implementation of the \lang\ language, a staged
interpreter, the splitting algorithm, and an interpreter for split programs.
This implementation extends the language described in \ref{sec:semantics} with 
\rmint{}s,
\rmbool{}s,
\texttt{let} statements,
$n$-ary sums and products,
datatype and function declarations, and
deep pattern matching (including $\next{}$ and $\pure{}$ patterns).
The code snippets in this paper are written in our concrete syntax, using 
these additional features when convenient.

We allow staging annotations around declarations. For example,
\begin{lstlisting}
1`atsigngrnd{
  datatype list = Empty | Cons of int * list
  fun part (...) = ...
}
fun qsStaged (...) = ...`
\end{lstlisting}
declares the \texttt{list} datatype and \texttt{part} function at world \bbonep,
by elaborating into:
\begin{lstlisting}
1`val grnd{Empty} = grnd{roll (inj ...)}
val grnd{Cons}  = grnd{fn (...) => roll (inj ...)}
val grnd{part}  = grnd{fn (...) => ...}
val qsStaged    = fn (...) => ...`
\end{lstlisting}

We also have a number of optimizations which drastically improve the readability
of split programs. We split patterns directly, rather than translating them into
lower-level constructs. Finally, we perform many local simplifications during
the splitting algorithm, most notably, not pairing precomputations when one is
known to be $\tup{}$.

%Specifically, our implemention includes parsers, printers, and interpreters

%Its main notable property is that world boundaries are always noted by braces.

%We also emit tuple patterns liberally in split programs.

\end{abstrsyn}
