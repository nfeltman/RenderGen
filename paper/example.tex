\section {Example: Staged Quickselect in \texorpdfstring{\lang}{Î»12}}
\label{sec:staging}

\ur{
\begin{itemize}
\item 
I find it hard to distinguish between blue and black on printed paper.
\item
$\pause$ should be called ``promote'' or something like that. I
  believe this is what Taha calls cross stage persistence.  THat work should
  be cited.
\item the splitting example should shed more light to the techniques
  and try to give more insight.
\end{itemize}
}

\crem{
Outline:
\begin{enumerate}
\item Say we want to run a bunch of quickselect queries on a single list.
\item We observe that some of the code depends only on the list.
\item We can write this code in \lang\ to make that dependency clear.
\item We can intuitively split into two functions.
\item This is asymptotically better.
\end{enumerate}
}

\input{figures/quickselect}

Staging is a technique for using language constructs and types to
explicitly divide a computation according to the frequency or the
arrival time of data.  

Suppose that we wish to issue order statistics queries on a collection of items
represented as a list \texttt{l}. We can use quickselect \cite{quickselect}, an
expected linear time algorithm which takes a list \texttt{l} and a rank
\texttt{k} and returns the element with rank \texttt{k} in \texttt{l}.

Quickselect, which we define in \ref{fig:qs-unstaged}, first partitions the list
by using the first element as a pivot%
\footnote{We assume that the list is prepermuted to guarantee the expected
linear time behavior.}
and then recurs on one of the two resulting sides to find the desired element. The
side chosen is determined by the relationship of \texttt{k} to the size of the
first half \texttt{n}, which is returned by the \texttt{partition} function
along with the two sides.

Now, consider an application where we perform many order statistics queries
on the same collection \texttt{l}, but with $m$ different ranks \texttt{k}:
%
\begin{lstlisting}
quickselect l 1
quickselect l 2
 @$\ldots$@ 
quickselect l @$m$@.
\end{lstlisting}
%
To take advantage of this, we can \emph{stage} quickselect so that the parts of
the computation that depend on the collection~\texttt{l} is performed once, and
the desired result is computed by using~\texttt{k} and the results from this
prior stage.

%% There has been the extensive research into the question of how to
%% automatically add staging annotations to unstaged code.  This process
%% is known as {\em binding time analysis}, and we do not consider it
%% here.  Instead, we assume that all input programs are properly staged
%% according to some programmer's intent.

\crem{missing text}

Using techniques essentially the same as
prior work, we can stage our quickselect code by using staged typing
and inserting three keywords~\texttt{next, prev, hold} into the
appropriate places in the code as shown in \ref{fig:qs-staged}. To
write the staged version, the programmer first observes that the
rank~\texttt{k} has now the type $\fut\rmint$ (read ``circle int'')
rather than $\rmint$, indicating that it will be available in the
second stage.  All types that are not of circle type are available in
the first stage.  Naturally the output type, representing the $k$th
largest element of the list, is also $\fut\rmint$, since it is not
computed until the second stage. 

\crem{explain circle types}

The construct $\next$ occurs in a stage \bbone\ context and indicates that the
contents of its block are stage \bbtwo, whereas $\prev$ occurs in a stage
\bbtwo\ context and indicates that the contents of its block is stage \bbone.
(We adopt the convention that the top-level context is stage \bbone.) 

Informally speaking, the $\next$ construct enables operating on second stage
computations in the first stage essentially by treating them as boxes that can
be moved around, stored in data structures, and passed to functions, and the
$\prev$ construct enables unwrapping the contents of such a box to use in the
second stage. 

For convenience, the code also uses $\pause$ blocks.  This construct
has same stage signature as $\prev$, but instead of ``unwrapping''
$\fut$ types it simply promotes integers from stage~\bbone\ to
stage~\bbtwo.%
\footnote{$\pause$ can be implemented from our other language features, with
some effort. We provide it as a primitive to shorten examples. Furthermore, it
would be wise to extend $\pause$ to other base types, if we had them, and to
products and sums thereof.  This is related to the notion of {\em mobility} in
\cite{murphy05} and {\em stability} in \cite{krishnaswami13}.}

We note that given the type signature of staged quickselect, there are several
ways to insert the staging annotations.  The version we presented here maximizes
the work done at stage~\bbone.

The type system guarantees that all first-stage computations depend only on the
first stage values and can indeed be computed in the absence of second-stage
values.  

\crem{partial evaluation requires compile-time access to first stage, whereas we
don't}

\crem{introduce boundary terminology}

Here, we wish to derive two functions, \texttt{quickselect1} and
\texttt{quickselect2}, that are semantically equivalent to quickselect in
the sense that:
\\
\texttt{quickselect l k = quickselect2 (quickselect1 l) k}.
\\
\crem{and moreover they correspond to the stages}

Since \texttt{quickselect1} requires only on a first stage
argument~\texttt{l}, we can run it once to produce a boundary data
structure that can be used for all subsequent queries on~\texttt{l},
e.g.,  the code consisting of $m$ calls 
\begin{lstlisting}
quickselect l 1
quickselect l 2
 @$\ldots$@ 
quickselect l @$m$@
\end{lstlisting}
%
can be replaced by 
%
\begin{lstlisting}
b = quickselect1 l
quickselect2 b 1
quickselect b 2
@$\ldots$@ 
quickselect b @$m$@.
\end{lstlisting}

In this paper, we show that it is possible to generalize data
specialization to a fully general language with recursion and
recursive types.  The key ideas behind our approach are: ...

\crem{walk through manual example here}

The final version, cleaned up and given better datatype names, is shown in
\ref{fig:qssplit}.  Observe that \texttt{qSelect1} essentially builds a binary
search tree from the input list, and \texttt{qSelect2} searches that tree for
the correct index.

Assuming that the list~\texttt{l} contains $n$ elements, this optimization
changes the asymptotic complexity from expected (randomized) $\Theta(n \cdot m)$
to $\Theta(n\log{n} + m\log{n})$, which for any $m \approx n$ reduces the
complexity from $\Theta (n^2)$ to $\Theta(n\log{n})$---a near linear time
improvement. 

Note that the desired optimized code shows above is intellectually more
sophisticated than the code that we have started with: the optimized code is
able to create a data structure, a balanced binary tree augmented with indexing
information, and use a binary search technique over this tree to compute the
result asymptotically more efficiently.
%In fact, based our teaching experience, we can imagine this kind of problem to
%be a moderately difficult exam question in an undergraduate algorithms class, as
%it not only requires understanding of data structures such as binary search
%trees but also requires modifying them to augment with indexing information to
%support rank-based search.

This paper formally describes and analyzes the splitting transformation
exemplified above.  (I also want to make it clear that recognizing \lang's
appropriateness for this is itself is a contribution.)

\input{figures/quickselect-split}
