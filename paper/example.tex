\section {Example: Staged Quickselect in \texorpdfstring{\lang}{Î»12}}
\label{sec:staging}

\begin{figure*}
\begin{subfigure}{0.5\textwidth}
\begin{lstlisting} 
datatype list = Empty | Cons of int * list
fun partition (p : int, l : list) 
  : (int*list*list) =
  case unroll l of 
    Empty => (0,Empty, Empty) 
  | Cons (h,t) =>
      let (s,left,right) = partition (p,t) in
      if h<p 
      then (s+1,Cons(h,left),right)
      else (s,left,Cons(h,right))

fun qSelect (l : list, k : int) : int = 
  case l of
    Empty => 0
  | Cons (h,t) => 
      let (left,right,n) = partition h t in
        case compare k n of
          LT => qSelect (left, k)
        | EQ => h
        | GT => qSelect (right, k-n-1)
\end{lstlisting}
\caption{Unstaged implementation of quickselect.}
\label{fig:quickselect}
\end{subfigure}%
\begin{subfigure}{0.5\textwidth}
\begin{lstlisting} 
1`datatype list = Empty | Cons of int * list
fun partition (p : int, l : list) = ...

fun qsStaged (l : list, k : $`2`int`1`) : $`2`int`1` = 
  case l of
    Empty => next {`2`0`1`}
  | Cons (h,t) => 
      let (left,right,n) = partition h t in
      next{
        `2`let n = hold{`1`n`2`} in
          case compare prev{`1`k`2`} n of
            LT => prev {`1`qsStaged (left k)`2`}
          | EQ => hold {`1`h`2`}
          | GT => prev {`1`qsStaged (right, 
                             next{prev{k}-n-1)}`2`}`1`
      }`
\end{lstlisting}
\caption{Staged implementation of quickselect in \lang.}
\label{fig:qsstaged}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\begin{lstlisting}
1`datatype list = Empty | Cons of int * list
fun partition (p : int, l : list) = ...`
	
datatype tree = Branch of int * int * tree * tree
                | Leaf

1`fun qSelect1 (l : list) : tree =
  case l of
    Empty => Leaf
  | Cons (h,t) => 
      let (left,right,n) = partition h t in
      Branch (n, h, qSelect1 left, qSelect1 right)`

2`fun qSelect2 (p : tree, k : int) : int = 
  case unroll p of
    Leaf => 0
  | Branch (n,h,p1,p2) => 
      case compare k n of
        LT => qSelect2 (p1,k)
      | EQ => h
      | GT => qSelect2 (p2,k-n-1)`
\end{lstlisting}
\caption{Split (two-phase) implementation of quickselect.}
\label{fig:qssplit}
\end{subfigure}
\caption{Caption place holder}
\end{figure*}

As an example of an algorithm amenable to staging techniques,
consider the implementation of quickselect shown in \ref{fig:quickselect}.
Quickselect is an algorithm for finding the $k$-th largest element in a list.
It works by partitioning the input list into sublists containing elements less than and greater than the head element, 
then recurring on the sublist containing the desired element.

One notable property of quickselect is that the partitioning of the list, 
even through its recursive calls, depends only on the values of list elements, and not on the value of $k$.
To illustrate this, we present colorized version of \texttt{qSelect}:

\begin{lstlisting} 
1`datatype list = Empty | Cons of int * list
fun partition (p : int, l : list) = ... `

fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  case l of
    Empty => `2`0`1`
  | Cons (h,t) => 
      let (left,right,n) = partition h t in`2`
      case compare k n of
        LT => `qSelect 1`left `2`k
      | EQ => h
      | GT => `qSelect 1`right `2`(k-n-1)`
\end{lstlisting}

Here, the input $k$ and all parts of the computation that depend on it are colored blue,
whereas all of the parts of the computation that do not depend on $k$ are colored red.
The \texttt{qSelect} variable itself, due to its status as a function with a mixed-color body, is left black.

To be precise, our coloring strategy respects data dependence, but not control dependence---the 
first arguments to the recursive calls to \texttt{qSelect} are colored red,
despite appearing underneath a blue case statement.
Because of this coloring strategy and the definition of data dependence, 
information can flow from red code to blue code but not vice versa.

Observe the that helper function \texttt{partition} is colored entirely red.
This is where much of the work of the quickselect algorithm takes place, and it doesn't even depend on $k$!

This suggests an optimization: we can split \texttt{qSelect} into two functions, 
one for all of the red code and another for all of the blue code. 
We'll call them \texttt{qSelect1} and \texttt{qSelect2}.
Because of the dependence properties stated above, 
\texttt{qSelect2} will need only depend on the results of \texttt{qSelect1} and the input index $k$,
whereas \texttt{qSelect1} will only depend on the input list $l$.
Of course, the meaning of \texttt{qSelect1} appropriately composed with \texttt{qSelect2} should be the same as \texttt{qSelect}, too.
Equationally, we can represent this relationship as simply 
\[
\mathtt{qSelect~l~k} \equiv \mathtt{qSelect2~(qSelect1~l)~k}
\]

With this goal in mind, we now set about deriving \texttt{qSelect1} and \texttt{qSelect2} from \texttt{qSelect}.
Because the original function is recursive,
the first step in this process is to assume this conclusion at the call sites.
This is performed in place:
\begin{lstlisting} 
fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  case l of
    Empty => `2`0`1`
  | Cons (h,t) => 
      let (left,right,n) = partition h t in`2`
      case compare k n of
        LT => qSelect2 (`1`qSelect1 left`2`) k
      | EQ => h
      | GT => qSelect2 (`1`qSelect1 right`2`) (k-n-1)`
\end{lstlisting}
We then pull the stage \bbone\ portion of each branch of the comparison up into a single tuple.
\begin{lstlisting} 
fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  case l of
    Empty => `2`0`1`
  | Cons (h,t) => 
      let (left,right,n) = partition h t in
      let p = `1`(h,qSelect1 left,qSelect1 right) in`2`
      case compare k n of
        LT => qSelect2 (pi2 p) k
      | EQ => pi1 p
      | GT => qSelect2 (pi3 p) (k-n-1)`
\end{lstlisting}
This last step is necessary, but we can perform it only because we're willing to ignore the control dependence.
We continue to pull up the precomputation and include more in it:

\begin{lstlisting} 
fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  case l of
    Empty => `2`0`1`
  | Cons (h,t) => 
      let p =
        let (left,right,n) = partition h t in
        `1`(n,h,qSelect1 left,qSelect1 right)
      in`2`
      case compare k (pi1 p) of
        LT => qSelect2 (pi3 p) k
      | EQ => pi2 p
      | GT => qSelect2 (pi4 p) (k-n-1)`
\end{lstlisting}

This completes the splitting of the cons branch.  
The empty branch can also be split, though in a trivial way:

\begin{lstlisting} 
fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  case l of
    Empty => let p = () in `2`0`1`
  | Cons (h,t) => 
      let p =
        let (left,right,n) = partition h t in
        `1`(n,h,qSelect1 left,qSelect1 right)
      in`2`
      case compare k (pi1 p) of
        LT => qSelect2 (pi3 p) k
      | EQ => pi2 p
      | GT => qSelect2 (pi4 p) (k-n-1)`
\end{lstlisting}

To continue splitting the case statement, we need to generate a sum type in the precomputation
to remind the code what branch its in.

\begin{lstlisting} 
fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  let p = 
    case l of
      Empty => Top ()
    | Cons (h,t) =>
        let (left,right,n) = partition h t in`1`
        Bot (n,h,qSelect1 left,qSelect1 right)
  in`2`
  case p of 
    Top () => 0
  | Bot p => 
      case compare k (pi1 p) of
        LT => qSelect2 (pi3 p) k
      | EQ => pi2 p
      | GT => qSelect2 (pi4 p) (k-n-1)`
\end{lstlisting}

We finish where we start, splitting \texttt{qSelect} into
\texttt{qSelect1} and \texttt{qSelect2}.  
Omitting a few type annotations, that is:

\begin{lstlisting} 
1`fun qSelect1 (l : list) = 
    case l of
      Empty => Top ()
    | Cons (h,t) =>
        let (left,right,n) = partition h t in
        Bot (n,h,qSelect1 left,qSelect1 right)
`2`
fun qSelect2 p (k : int) : int = 
  case p of 
    Top () => 0
  | Bot p => 
      case compare k (pi1 p) of
        LT => qSelect2 (pi3 p) k
      | EQ => pi2 p
      | GT => qSelect2 (pi4 p) (k-n-1)`
\end{lstlisting}

The final version, cleaned up and given better datatype names, is shown in \ref{fig:qssplit}.
Observe that \texttt{qSelect1} essentially builds a binary search tree from the input list, 
and \texttt{qSelect2} searches that tree for the correct index.
The benefits of this decomposition are substantial: for a randomly ordered list of length $n$, 
the original \texttt{qSelect} takes expected $O(n)$ time per lookup, 
whereas \texttt{qSelect2} takes $O(\log n)$ time.
Since \texttt{qSelect1} does not depend on $k$, its $O(n\log n)$ cost can be amortized over many lookups.

\nr{There's something else I need to say right here before the contribution statement below. 
I want the reader to be thinking "yeah, this splitting business does seem cool."
Bonus points if I also have them thinking "but it would be cooler if it were formal."}

This paper formally describes and analyzes the splitting transformation exemplified above.
(I also want to make it clear that recognizing \lang's appropriateness for this is itself is a contribution.)

We start by defining a simple staged language, called \lang, to express the input to our splitting algorithm.  
\lang\ unambiguously specifies how its terms should be split
% and features a type system that ensures valid splittings exist.
% only minimal refactoring should be required to write terms within this language,
%and from there, the type system should be enough to prove that a valid splitting exists.
by identifying each with one of two {\em stages}, namely \bbone\ or \bbtwo.
Intuitively, the stage of a \lang\ term expresses \emph{when} to evaluate it---all stage-\bbone\
subexpressions are evaluated before stage-\bbtwo\ ones.  
After splitting, those parts of the \lang\ term that were identified with stage \bbone\ 
will end up in the stage \bbone\ function ({\tt qSelect1}), 
and those parts identified with stage \bbtwo\ will end up in the stage \bbtwo\ function ({\tt qSelect2}).
Typing rules for \lang\ ensure a valid splitting exists.  That is, 
within well-typed terms, information can flow from stage \bbone\ to stage \bbtwo\ portions,
but never from \bbtwo\ to \bbone.

\ref{fig:qsstaged} shows a staged implementation of quickselect in \lang.
As before, the function accepts as input the list to select from and a value of $k$,
but now the latter is represented with the type $\fut\rmint$ rather than $\rmint$.
The difference here is that an $\rmint$ is an integer available at the current stage (stage \bbone), 
whereas a $\fut\rmint$ is an integer available only at the next stage (stage \bbtwo).
Naturally the output type, representing the $k$th largest element of the list,
is also $\fut\rmint$, since it is not computed until stage \bbtwo.

Each construct in the body of quickselect is now associated with a stage via an interleaving of $\next$ and $\prev$ blocks.  
Specifically, $\next$ occurs in a stage \bbone\ context and indicates that the contents of its block are stage \bbtwo, 
whereas $\prev$ occurs in a stage \bbtwo\ context and indicates that the contents of its block is stage \bbone.
(We adopt the convention that the top-level context is stage \bbone.)
The output type of a $\next$ block is the $\fut$'d version of the type of its stage \bbtwo\ contents.  
For example, \verb|next{0}| from above has the type $\fut\rmint$.
Correspondingly, $\prev$ requires that its stage \bbone\ contents have a $\fut$ type, and it eliminates the wrapper.
For example, \verb|prev{k}| from above has type $\rmint$ at stage \bbtwo, since $k$ is bound to a $\fut\rmint$ at stage \bbone.
These type restrictions essentially enforce that ``later stage content" is always treated hygienically at stage \bbone,
which is necessary to admit a properly staged implementation.

The code also contains two $\pause$ blocks.  
This construct has same stage signature as $\prev$,
but instead of ``unwrapping" $\fut$ types it simply promotes integers from stage~\bbone\ to stage~\bbtwo.
\footnote{It will turn out that $\pause$ is implementable---though it takes some effort---from our other language features.
We instead provide it as a primitive to shorten examples.  
Furthermore, it would be wise to extend $\pause$ to other base types, if we had them, and to products and sums thereof.
This is related to the notion of {\em mobility} in \cite{murphy05} and {\em stability} in \cite{krishnaswami13}.}

But for the $\fut$, $\next$, $\prev$, and $\pause$ constructs, 
the staged version of quickselect in \ref{fig:qsstaged} is virtually identical to the unstaged version in \ref{fig:quickselect}.
The constructs that were added were placed in order to maximize the work done at stage~\bbone\ while still conforming to the type signature.
It would have also been valid to simply move the whole input list unchanged into stage~\bbtwo\ at the very beginning, 
but that would not be particularly interesting since it would result in an effectively trivial split 
that's just the identity at stage~\bbone\ and plus quickselect at stage~\bbtwo.
There has been the extensive research into the question of how to automatically add staging annotations to unstaged code.
This process is known as {\em binding time analysis}, and we do not consider it here.
Instead, we assume that all input programs are properly staged according to some programmer's intent.
