\section {Example: Staged Quickselect in \texorpdfstring{\lang}{Î»12}}
\label{sec:staging}

\begin{figure*}
\begin{subfigure}{0.5\textwidth}
\begin{lstlisting} 
datatype list = Empty | Cons of int * list
fun partition (p : int, l : list) 
  : (int*list*list) =
  case unroll l of 
    Empty => (0,Empty, Empty) 
  | Cons (h,t) =>
      let (s,left,right) = partition (p,t) in
      if h<p 
      then (s+1,Cons(h,left),right)
      else (s,left,Cons(h,right))

fun qSelect (l : list, k : int) : int = 
  case l of
    Empty => 0
  | Cons (h,t) => 
      let (left,right,n) = partition h t in
        case compare k n of
          LT => qSelect (left, k)
        | EQ => h
        | GT => qSelect (right, k-n-1)
\end{lstlisting}
\caption{Unstaged implementation of quickselect.}
\label{fig:quickselect}
\end{subfigure}%
\begin{subfigure}{0.5\textwidth}
\begin{lstlisting} 
1`datatype list = Empty | Cons of int * list
fun partition (p : int, l : list) = ...

fun qsStaged (l : list, k : $`2`int`1`) : $`2`int`1` = 
  case l of
    Empty => next {`2`0`1`}
  | Cons (h,t) => 
      let (left,right,n) = partition h t in
      next{
        `2`let n = hold{`1`n`2`} in
          case compare prev{`1`k`2`} n of
            LT => prev {`1`qsStaged (left k)`2`}
          | EQ => hold {`1`h`2`}
          | GT => prev {`1`qsStaged (right, 
                             next{prev{k}-n-1)}`2`}`1`
      }`
\end{lstlisting}
\caption{Staged implementation of quickselect in \lang.}
\label{fig:qsstaged}
\end{subfigure}
\begin{subfigure}{0.5\textwidth}
\begin{lstlisting}
1`datatype list = Empty | Cons of int * list
fun partition (p : int, l : list) = ...`
	
datatype tree = Branch of int * int * tree * tree
                | Leaf

1`fun qSelect1 (l : list) : tree =
  case l of
    Empty => Leaf
  | Cons (h,t) => 
      let (left,right,n) = partition h t in
      Branch (n, h, qSelect1 left, qSelect1 right)`

2`fun qSelect2 (p : tree, k : int) : int = 
  case unroll p of
    Leaf => 0
  | Branch (n,h,p1,p2) => 
      case compare k n of
        LT => qSelect2 (p1,k)
      | EQ => h
      | GT => qSelect2 (p2,k-n-1)`
\end{lstlisting}
\caption{Split (two-phase) implementation of quickselect.}
\label{fig:qssplit}
\end{subfigure}
\caption{Caption place holder}
\end{figure*}

As an example of an algorithm amenable to staging techniques,
consider the implementation of quickselect shown in \ref{fig:quickselect}.
Quickselect is an algorithm for finding the $k$-th largest element in a list.
It works by partitioning the input list into sublists containing elements less than and greater than the head element, 
then recurring on the sublist containing the desired element.

One notable property of quickselect is that the partitioning of the list, even through its recursive calls, depends only on the values of list elements, not on the value of $k$ 
\footnote{There is a control-dependence on $k$ -- that is $k$ determines what splits are made but not how they are made -- we ignore this for now.}.  Therefore, if quickselect were to be evaluated many times on the same list, this independence admits a familiar optimization where the algorithm is split into two functions: one which precomputes \emph{all partitions} of the input list needed for any value of $k$ (resulting in a binary search tree---see \texttt{qSelect1} in \ref{fig:qssplit}),
and another which, given $k$, uses the tree to perform accelerated lookup of the $k$-th element (essentially performing binary search of a sorted list---see \texttt{qSelect2}).  
Equationally, we can represent this relationship as 
\[
\mathtt{qSelect(l,k)} \equiv \mathtt{qSelect2(qSelect1(l),k)}
\]

The benefits of this decomposition are substantial: for a randomly ordered list of length $n$, 
the original \texttt{qSelect} takes expected $O(n)$ time per lookup, 
whereas \texttt{qSelect2} takes $O(\log n)$ time.
Since \texttt{qSelect1} does not depend on $k$, its $O(n\log n)$ cost can be amortized over many lookups.
%One advantage of splitting the algorithm into two phases is that the search tree can be constructed for a list once
%and then used to accelerate many future lookups for any value of $k$.

This paper defines how to statically perform splitting transformations, like the one described above, on programs written in a simple staged language we call \lang.  \lang\ unambiguously specifies how its terms should be split
% and features a type system that ensures valid splittings exist.
% only minimal refactoring should be required to write terms within this language,
%and from there, the type system should be enough to prove that a valid splitting exists.
by identifying each with one of two {\em stages}, namely \bbone\ or \bbtwo.
Intuitively, the stage of a \lang\ term expresses \emph{when} to evaluate it---all stage-\bbone\
subexpressions are evaluated before stage-\bbtwo\ ones.  
After splitting, those parts of the \lang\ term that were identified with stage \bbone\ 
will end up in the stage \bbone\ function ({\tt qSelect1}), 
and those parts identified with stage \bbtwo\ will end up in the stage \bbtwo\ function ({\tt qSelect2}).
Typing rules for \lang\ ensure a valid splitting exists.  That is, 
within well-typed terms, information can flow from stage \bbone\ to stage \bbtwo\ portions,
but never from \bbtwo\ to \bbone.

\ref{fig:qsstaged} shows a staged implementation of quickselect in \lang.
As before, the function accepts as input the list to select from and a value of $k$,
but now the latter is represented with the type $\fut\rmint$ rather than $\rmint$.
The difference here is that an $\rmint$ is an integer available at the current stage (stage \bbone), 
whereas a $\fut\rmint$ is an integer available only at the next stage (stage \bbtwo).
Naturally the output type, representing the $k$th largest element of the list,
is also $\fut\rmint$, since it is not computed until stage \bbtwo.

Each construct in the body of quickselect is now associated with a stage via an interleaving of $\next$ and $\prev$ blocks.  
Specifically, $\next$ occurs in a stage \bbone\ context and indicates that the contents of its block are stage \bbtwo, 
whereas $\prev$ occurs in a stage \bbtwo\ context and indicates that the contents of its block is stage \bbone.
(We adopt the convention that the top-level context is stage \bbone.)
The output type of a $\next$ block is the $\fut$'d version of the type of its stage \bbtwo\ contents.  
For example, \verb|next{0}| from above has the type $\fut\rmint$.
Correspondingly, $\prev$ requires that its stage \bbone\ contents have a $\fut$ type, and it eliminates the wrapper.
For example, \verb|prev{k}| from above has type $\rmint$ at stage \bbtwo, since $k$ is bound to a $\fut\rmint$ at stage \bbone.
These type restrictions essentially enforce that ``later stage content" is always treated hygienically at stage \bbone,
which is necessary to admit a properly staged implementation.

The code also contains two $\pause$ blocks.  
This construct has same stage signature as $\prev$,
but instead of ``unwrapping" $\fut$ types it simply promotes integers from stage~\bbone\ to stage~\bbtwo.
\footnote{It will turn out that $\pause$ is implementable---though it takes some effort---from our other language features.
We instead provide it as a primitive to shorten examples.  
Furthermore, it would be wise to extend $\pause$ to other base types, if we had them, and to products and sums thereof.
This is related to the notion of {\em mobility} in \cite{murphy05} and {\em stability} in \cite{krishnaswami13}.}

But for the $\fut$, $\next$, $\prev$, and $\pause$ constructs, 
the staged version of quickselect in \ref{fig:qsstaged} is virtually identical to the unstaged version in \ref{fig:quickselect}.
The constructs that were added were placed in order to maximize the work done at stage~\bbone\ while still conforming to the type signature.
It would have also been valid to simply move the whole input list unchanged into stage~\bbtwo\ at the very beginning, 
but that would not be particularly interesting since it would result in an effectively trivial split 
that's just the identity at stage~\bbone\ and plus quickselect at stage~\bbtwo.
There has been the extensive research into the question of how to automatically add staging annotations to unstaged code.
This process is known as {\em binding time analysis}, and we do not consider it here.
Instead, we assume that all input programs are properly staged according to some programmer's intent.
