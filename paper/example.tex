\section {Example: Staged Quickselect in \texorpdfstring{\lang}{Î»12}}
\label{sec:staging}

\begin{concretesyntax}

\ur{
\begin{itemize}
\item 
I find it hard to distinguish between blue and black on printed paper.
\item
$\pause$ should be called ``promote'' or something like that. I
  believe this is what Taha calls cross stage persistence.  THat work should
  be cited.
\end{itemize}
}

\crem{
Notes from 1/16:
\begin{itemize}
\item We are modeling computations where some inputs arrive at stage 1 and
others arrive at stage 2. As a result, some subcomputations can be performed at
stage 1, and others at stage 2.
\item \emph{Statics}: M12 is a language with three worlds: 1, 2, and M.
We model the computations described above as functions in world M.
\item \emph{Dynamics}: We describe how to perform all of the stage 1
subcomputations in an M12 program. Our semantics are mutually defined in terms
of how to reduce terms in each of the three worlds.
\end{itemize}
}

\input{figures/quickselect}

Suppose that we wish to issue order statistics queries on a collection of items
represented as a list \texttt{l}. We can use quickselect \cite{quickselect}, an
expected linear time algorithm which takes a list \texttt{l} and a rank
\texttt{k} and returns the element with rank \texttt{k} in \texttt{l}.

Quickselect, which we define in \ref{fig:qs-unstaged}, first partitions the list
by using the first element as a pivot%
\footnote{We assume that the list is prepermuted to guarantee the expected
linear time behavior.}
and then recurs on one of the two resulting sides to find the desired element.
The side chosen is determined by the relationship of \texttt{k} to the size of
the first half \texttt{n}, which is returned by the \texttt{partition} function
along with the two sides themselves.

Now, consider an application where we perform many order statistics queries on
the same collection \texttt{l}, but with $m$ different ranks
$\mathtt{k_1},\dots,\mathtt{k_m}$.
Certainly, it is possible to implement this with $m$ calls to
\texttt{quickselect}:
%
\begin{lstlisting}
quickselect l @$\mathtt{k_1}$@
quickselect l @$\mathtt{k_2}$@
 @$\vdots$@ 
quickselect l @$\mathtt{k_m}$@.
\end{lstlisting}
%
Can we do better?

\subsection{Staging}

An astute programmer might notice that much of the code in \texttt{quickselect}
does \emph{not} depend on the rank \texttt{k}; for example, the list is
partitioned before \texttt{k} is ever used. Moreover, while the recursive calls
to \texttt{qSelect} are guarded by a comparison to \texttt{k}, \texttt{k} does
not determine the arguments to those recursive calls---it only determines which
call is made. Thus, if we are willing to change the evaluation order of the
language (and evaluate under the \texttt{case} statement), it should be possible
to set things up so that \emph{all} the computation involving \texttt{l} is
performed before \emph{any} of the computation involving \texttt{k}.

We can formalize this intuition by writing quickselect in a \emph{staged}
language. In this paper, we choose \lang\ (\ref{sec:semantics}), a staged, typed
lambda calculus. This allows us to directly express the idea that the argument
\texttt{l} is known at the \emph{first} stage of the computation, while the
argument \texttt{k} is only known at the \emph{second}, and all
first-stage computation occurs before any second-stage computation.

We define a staged version of quickselect in \ref{fig:qs-staged}, writing
first-stage computations in red, and second-stage computations in blue. While
\texttt{qSelect} sends a \textrm{list} and \rmint\ to an \rmint,
\texttt{qsStaged} has a more precise type---it is a first-stage function which
takes a \textrm{list} and a $\fut\rmint$ (an $\rmint$ \emph{in the future}), and
returns a $\fut\rmint$. 

\crem{Next three paragraphs are waiting on exact code for \ref{fig:qs-staged}.
Use three colors?}

The stage \bbone\ portions of \texttt{qsStaged} look like \texttt{qSelect}: any
term of non-circle type is available for immediate use. Indeed, we case on
\texttt{l} as usual, and in the \texttt{Cons} branch, \texttt{partition} it.

The next part of the original \texttt{qSelect} function depends on \texttt{k},
which has type $\fut\rmint$, indicating that it is only available to stage
\bbtwo\ computations. Since \texttt{qsStaged} itself produces a $\fut\rmint$,
the remainder of the function is stage \bbtwo\ code.

The $\next$ wraps a stage \bbtwo\ expression of type $\rmint$ (the \texttt{case}
expression) as a stage \bbone\ expression of type $\fut\rmint$ (the result type
of \texttt{qsStaged}). Inside the \texttt{LT} and \texttt{GT} branches, the
$\prev$ unwraps stage \bbone\ $\fut\rmint$s (the results of the recursive calls
to \texttt{qsStaged}) as stage \bbtwo\ $\rmint$s. In the \texttt{EQ} branch,
$\pause$ promotes an integer at stage \bbone\ (the head of \texttt{l}) directly
to an integer at stage \bbtwo.%
\footnote{$\pause$ can be implemented from our other language features, with
some effort. We provide it as a primitive to shorten examples. Furthermore, it
would be wise to extend $\pause$ to other base types, if we had them, and to
products and sums thereof.  This is related to the notion of {\em mobility} in
\cite{murphy05} and {\em stability} in \cite{krishnaswami13}.}

The process of adding staging annotations ($\fut$ types, $\next$, $\prev$, and
$\pause$) to unstaged code has been the subject of extensive research under the
name of \emph{binding time analysis}. In this paper, we assume that these
annotations have been provided by the programmer (or perhaps a binding time
analysis tool), and do not consider the problem of generating such annotations.
There are many ways to annotate any program, including \texttt{qSelect}; we
chose annotations which maximize the work performed in the first stage.

%The purpose of writing quickselect in \lang\ is that, because \texttt{qsStaged}
%typechecks, it is a valid way of dividing the program into two stages, where the
%stage \bbone\ computations can all be performed prior to the stage \bbtwo\
%computations. In \ref{sec:semantics} we provide an evaluation strategy for
%\lang\ which validates that claim.

%(We adopt the convention that the top-level context is stage \bbone.) 

%pass around opaque stage \bbtwo\ computations at stage \bbone

\subsection{Splitting Staged Programs}

\input{figures/quickselect-split}

An astute programmer, having noticed that \texttt{quickselect} can be staged in
this fashion, might try to split it into a pair of functions, one which performs
all the work depending only on \texttt{l} (the first stage), and one which uses
\texttt{k} and the result of that work on \texttt{l} to compute the element with
rank \texttt{k} in \texttt{l}. 

Intuitively, \texttt{l} determines the result of all calls to
\texttt{partition}, and \texttt{k} only determines which calls are made. So we
can preprocess \texttt{l} by recursively dividing it into halves smaller and
greater than the pivot---that is, building a binary search tree. Then, once we
have \texttt{k}, we can recur on this tree, choosing whichever branch has the
\texttt{k}${}^\textit{th}$ leftmost element until we reach a leaf. Crucially,
because \texttt{partition} has no stage \bbtwo\ content, we need not perform any
of its work at stage \bbtwo!

\crem{Use $\bbonep$ to explain the above.}

We have implemented this splitting of quickselect in \ref{fig:qs-split}.
\texttt{qSelect1} builds a binary search tree from the list \texttt{l}, and
\texttt{qSelect2} takes such a tree and a rank \texttt{k} and computes the
answer. This allows us to efficiently perform many order statistics queries on
\texttt{l} by caching the tree and reusing it for many different ranks
$\mathtt{k_1},\dots,\mathtt{k_m}$:
%
\begin{lstlisting}
let b = qSelect1 l in
  qSelect2 b @$k_1$@
  qSelect2 b @$k_2$@
   @$\vdots$@ 
  qSelect2 b @$k_m$@.
\end{lstlisting}

Assuming \texttt{l} contains $n$ elements, this optimization changes the
asymptotic complexity from expected (randomized) $\Theta(n \cdot m)$ to
$\Theta(n\log{n} + m\log{n})$, which for any $m \approx n$ reduces the
complexity from $\Theta (n^2)$ to $\Theta(n\log{n})$---a near linear time
improvement. 

In this paper, we develop a splitting algorithm
(\ref{sec:splitting,sec:implementation}) which, for any term $e$ in \lang,
produces a pair of terms $e_1,e_2$ containing respectively all the first- and
second-stage content of $e$, such that $e_2~e_1$ is equivalent to $e$.
(Such a splitting is always possible because $e$ is well-typed in \lang.) In the
case of \texttt{qsStaged}, our splitting algorithm produces the algorithm
described above.

%\texttt{qSelect l k = qSelect2 (qSelect1 l) k}.

%Because the tree passes information across the stage boundary, we call it the
%\emph{boundary data structure}.

%Note that the desired optimized code shows above is intellectually more
%sophisticated than the code that we have started with: the optimized code is
%able to create a data structure, a balanced binary tree augmented with indexing
%information, and use a binary search technique over this tree to compute the
%result asymptotically more efficiently.

%In fact, based our teaching experience, we can imagine this kind of problem to
%be a moderately difficult exam question in an undergraduate algorithms class, as
%it not only requires understanding of data structures such as binary search
%trees but also requires modifying them to augment with indexing information to
%support rank-based search.

%(I also want to make it clear that recognizing \lang's appropriateness for this
%is itself is a contribution.)

\end{concretesyntax}