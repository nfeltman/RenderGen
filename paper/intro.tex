\section{Introduction}

It is a common observation that some computations can be performed efficiently by using {\em staging}, wherein the execution of a program is split over two or more discrete points in time ({\em i.e.} stages).  This most often arises when we want to evaluate a multivariate function several times, with some inputs dynamic (varying across invocations) and some static (constant across invocations).  Examples include:
\begin{itemize}
\item Computing $b^e$, where $b$ varies and $e$ is constant.
\item Finding the $i$th largest element in a list, where the list is constant and $i$ varies.
\item Computing the shading of a surface in a 3D rendering, where some contributors to the final pixel color can be approximated as constant over  pixel blocks.  
\end{itemize}

With these goals in mind, our initial concern is how to express multistage programs. To this end, we have created \lang, a typed multi-stage lambda calculus featuring products, sums, and isorecursive types. An important property of \lang\ is that the staging of a well-typed program is apparent without resorting to any variable analysis, contra standard binding time analysis.  

Once we have appropriately written {\em multi-stage} programs, we then must execute them in a way that respects the staging.  In this paper, we explore two techniques for this: {\em partial evaluation} and {\em stage-splitting}.  

The main idea of the former technique is to evaluate all of the constant portions of the program and embed the partial results into a {\em residual} program that depends only on the varying inputs.  This is an old and well-explored idea, though the typical setup of partial evaluation implies a more powerful binding time analysis than is necessary for our language.

The main idea of the latter technique is to statically compile the multi-stage program into several smaller programs, one per stage, and then to execute those in a standard way once inputs are available.  This has previously been explored as an optimization technique for languages with fewer features (notably, no functions) or a more constrained staging model than \lang. Prior examples include the ``data specialization" work of Knoblock and Ruf\,\cite{knoblock96} as well as the compilation of high-level shading languages for computer graphics such as RTSL\,\cite{Proudfoot:2001} and Spark\,\cite{Foley:2011}.  Unlike partial evaluation, stage splitting is purely a static program transformation and is not dependent on the input data.

\TODO motivate this example

\TODO integrate the following text into the new intro

Recall that partial evaluators operate on multivariate functions $f$, whose
inputs are each labeled either {\em static} or {\em dynamic}. Once the static
inputs are provided, partial evaluation of $f$ produces a residual depending on
only the dynamic input. Mathematically, a partial evaluator is any $p$ such
that
\[
	\forall f,x. \exists f_x. \left[p(f,x) = f_x \text{ and } \forall y.\llbracket f \rrbracket(x,y)=\llbracket f_x \rrbracket(y)\right]
\]
where $\llbracket \cdot \rrbracket$ translates the text of a function to its
mathematical interpretation (a la \cite{jones96}). Here, $x$ is the static
input, $y$ is the dynamic input, and $f_x$ is the residual, that is, \emph{$f$
specialized to $x$}.

\ur{  Based on this definition, it
  might be good and correct to argue that this is more or less an
  orthogonal problem.}

Much like partial evaluation, the goal of stage-splitting is to separate the evaluation of a multi-stage function into distinct phases.
However, where partial evaluation requires the value of some inputs to be known, stage splitting is a static transformation performed
before {\em any arguments} are available.
Taking a multivariate function $f$ as input, stage-splitting produces two functions $f_1$ and $f_2$,
where $f_1$ uses the stage-\bbone\ input to produce a data structure, 
and $f_2$ consumes that data structure and the stage-\bbtwo\ input to produce the final output.  
More precisely, a stage splitter is any $s$ such that
\[
	\forall f. \exists f_1,f_2. 
	\left[
		\begin{array}{l}
		s(f) = (f_1,f_2) \text{ and } \\
		\forall x,y.\llbracket f \rrbracket(x,y)=\llbracket f_2 \rrbracket(\llbracket f_1 \rrbracket(x),y)
		\end{array}
	\right]
\]
with the same $\llbracket \cdot \rrbracket$ notation as before.
Notice that $x$ here is bound underneath the existential $f_1$ and $f_2$,
meaning that the stage splitting operation does not depend on the stage-\bbone\ input.
This stands in contrast to the definition of partial evaluation, where $f_x$ does depend on $x$.




\Cref{sec:semantics} describes the grammar and type system of \lang, as well as a reference semantics which is essentially a partial evaluator that respects staging. \Cref{sec:splitting} describes a stage-splitting transformation for \lang\ and proves its equivalence to the reference semantics.
Finally, \Cref{sec:examples} gives several examples of how stage-splitting terms in \lang\ can be used to derive classic data structures, and discusses the effectiveness and limitations of this technique.  Notably, these examples make use of the stage-splitting features not available in prior work.


