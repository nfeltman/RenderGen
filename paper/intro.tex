\section{Introduction}

Multi-argument functions can frequently perform useful work before receiving all
of their inputs, or are often called numerous times with one argument fixed. An
important program optimization is therefore to \emph{specialize} such a function
$f$ to its fixed argument $a$, by executing those computations in $f$ which
depend only on $a$. This ensures that calls to the specialized function require
only computations which depend on its varying argument.

\emph{Program specialization}, or partial evaluation \cite{futamura71,jones96},
is a well-known specialization technique which, given $a$, transforms $f$ into a
new function $f_a(-)$ which computes $f(a,-)$. This transformation essentially
substitutes $a$ for the first argument of $f$, then evaluates in place any
subexpressions of $f$ depending only on that argument.

\emph{Data specialization} \cite{knoblock96,jorring86} 
is a technique for specializing $f$ \emph{without} the fixed argument $a$,
instead splitting $f$ into a pair of functions $f_1$ and $f_2$. $f_1(a)$
produces a data structure containing the results of the computations which
depend only on $a$; $f_2$ then completes the computation, given this data
structure and the varying argument; that is, $f_2(f_1(a),-)$ computes $f(a,-)$.

Previous work on data specialization has been limited to simple, imperative
languages. In this paper, we extend data specialization to a typed lambda
calculus, allowing us to specialize more interesting programs.

When splitting certain recursive functions, like \texttt{quickselect}, our
algorithm synthesizes recursive data structures and traversal algorithms which
yield asymptotic speedups over the original function. Splitting higher-order
combinators, like \texttt{map}, provides compositional reasoning at the source
level while cross-cutting fixed runtime stages, as in graphical shading
languages like Spark~\cite{Foley:2011}.

We start in \ref{sec:example} with an extended example of splitting
\texttt{quickselect}.
In \ref{sec:semantics}, we describe our staged language \lang, including its
type system and operational semantics.
In \ref{sec:splitting,sec:implementation}, we describe our stage-splitting
algorithm for performing data specialization.
Finally, in \ref{sec:examples}, we show how our stage-splitting algorithm
transforms a variety of other programs.
