
\section{\texorpdfstring{\lang}{Î»12} Statics and Dynamics}
\label{sec:semantics}

\input {figures/grammars}
\input {figures/statics}

\lang\ is a typed two-stage lambda calculus with products, sums, and isorecursive types.
Its statics are adapted from the linear temporal logic given by \cite{davies96},
restricted to two stages and extended with general sums and recursion.%
\footnote{This restriction to two stages is made primarily for simplicity of
presentation. All of these techniques could feasibly be extended to more
complicated stage systems.}
%The grammar (\cref{fig:grammar}) and type system of \lang\ are an adaptation of those of 
%, as language to define and analyze the splitting transform.

%The following subsections provide a brief overview of the type system for \lang,
%and highlight important differences in its semantics from this prior work.

\subsection{Statics}

In \lang, the $\next$ constructor includes a stage \bbtwo\ term in a
stage~\bbone\ term. To ensure that the staging features are only applied to
valid terms, we index our judgments not only by a type, but also a stage $w$.

The type validity judgment $\Delta \vdash A \istypewor$, defined in
\cref{fig:validTypes}, ensures that a type $A$ exists at stage $w$; for
example, any type $\fut A$ only exists at stage \bbone.  The typing judgment
$\typeswor e A$ says that $e$ has type $A$ at stage $w$, in the context
$\Gamma$, and is defined in \cref{fig:statics}.  As one would expect, the
typing judgment only produces valid types.
%(by induction on the derivation of the typing judgment).
% under the assumptions in $\Delta$. This context is only augmented by recursive types.

Except for the staging features $\next$, $\prev$, and $\pause$, the language
features are essentially agnostic to stage. Variables in the context are
annotated with the stage at which they were introduced and can only be used at
the same stage.

Note that there is no way to eliminate a term of type $\fut A$ into a stage
\bbone\ term---the only elimination form is $\prev$, which results in a stage
\bbtwo\ term. This is why well-typed terms cannot have any information flow
from stage \bbtwo\ to stage \bbone, and what makes splitting possible.

\subsection{Dynamics}
\label{sec:stagedsemantics}

In the quickselect example, stage~\bbone\ terms are contained within
stage~\bbtwo\ terms---for example, in the recursive call to {\tt qsStaged}. In
this case, if we use an ordinary evaluation strategy reducing outermost redexes
first, we would no longer have staged evaluation, as stage~\bbtwo\ code would
be evaluated before stage~\bbone\ code. 

Thus, our dynamic semantics for \lang\ evaluates all of a term's stage \bbone\
subexpressions before any of its stage~\bbtwo\ subexpressions. This results in
a stage \bbtwo\ term with no stage~\bbone\ content; we say this is a term in a
monostaged language called \langTwo. Then, at stage~\bbtwo, we complete
evaluating this term with a standard dynamic semantics, $\tworedsym$. (The
rules for this judgment are not shown, but they are standard.)

\subsubsection{Non-Duplicating Stage~\bbone\ Evaluation}

To gain intuition about the challenges of implementing this staged dynamic
semantics, consider the program:
\begin{lstlisting}
#2 (next {f 20}, 2+3)
\end{lstlisting}
This is a stage~\bbone\ expression of type $\rmint$; the pair inside it is a
stage~\bbone\ expression of type $(\fut\rmint)\times\rmint$; and ${\tt f} :
\rmint \to \rmint$ is an expensive stage~\bbtwo\ function which we would like
to avoid evaluating. A conventional call-by-value semantics would fully
evaluate both components of the pair before projecting the second component.
The problem is that, while \verb|next {f 20}| is not a value (in the sense that
additional stage-\bbtwo\ computation steps are necessary to produce a numeral),
evaluating the contents of \verb|next| cannot occur as part of stage~\bbone\
evaluation.

Intuitively, the solution is to designate \verb|next {f 20}| as a value
\emph{in stage \bbone}, even though it requires additional evaluation in stage
\bbtwo. Therefore, the pair evaluates to
\begin{lstlisting}
#2 (next {f 20}, 5)
\end{lstlisting}
and the projection, in turn, immediately evaluates to \verb|5|.

Now consider a more complex example where stage~\bbone\ evaluation must
substitute such a incompletely-evaluated expression. The following
stage-\bbtwo\ term has type $\rmint$:
\begin{lstlisting} 
prev{
  let x = (next {f 20}, 3+4) in
  next{ prev{#1 x} * prev{#1 x} * hold{#2 x} }
}
\end{lstlisting}
Again, this term does not fully reduce at stage~\bbone, because it depends on
the value of \verb|f 20|, which is not reduced until stage \bbtwo.

If we simply treat \verb|(next {f 20}, 7)| as a value during stage~\bbone, and
substitute it for the three occurrences of \verb|x| in the body of the
\verb|let| expression, the stage \bbone\ result would be
\begin{lstlisting} 
prev{
  next{ 
    prev{next {f 20}} * prev{next {f 20}} * 7 
  }
}
\end{lstlisting}
Finally, the $\prev$s and $\next$s cancel to yield the residual:
\begin{lstlisting} 
(f 20) * (f 20) * 7
\end{lstlisting}
But now stage \bbtwo\ must compute the expensive function call \verb|f 20|
twice! To avoid this duplication, instead of treating \verb|next {f 20}| as a
value and substituting it into the body of the \verb|let|, we instead bind
\verb|f 20| to a stage~\bbtwo\ variable $\mathtt{\hat y}$, and substitute that
variable.

More precisely, when evaluating the \verb|next|, we construct an explicit
substitution $\mathtt{[\hat y\mapsto f~20]}$ binding its old contents to the
fresh variable $\mathtt{\hat y}$. This substitution is placed at the top of the
containing $\prev$ block:
\begin{lstlisting} 
prev {
[yhat|->f 20]
  let x = (next{yhat}, 7) in
  next{prev{#1 x} * prev{#1 x} *  hold{#2 x}}
}
\end{lstlisting}
%As a convention, we render the new variable with a %stylish and fashionable
%hat.  
We proceed with stage~\bbone\ evaluation, which now duplicates the variable
$\mathtt{\hat y}$ rather than the expression \verb|f 20|.
\begin{lstlisting} 
prev {
[yhat|->f 20]
  next{
    prev{#1 (next {yhat}, 7)} * 
    prev{#1 (next {yhat}, 7)} *
    hold{#2 (next {yhat}, 7)}
  }
}
\end{lstlisting}
To evaluate the large $\next$, we must first \emph{speculate} inside of it, to
evaluate all the stage~\bbone\ terms contained within $\prev$s. These
necessarily reduce to $\next$ expressions which cancel the $\prev$s, resulting
in:
\begin{lstlisting} 
prev {
[yhat|->f 20]
    next{ yhat * yhat * 7 }
}
\end{lstlisting}
Once again, we lift the contents of the $\next$ into a substitution:
\begin{lstlisting} 
prev {
[yhat|->f 20]
[zhat|->yhat*yhat*7]
    next{ zhat }
}
\end{lstlisting}
Finally, when evaluating the outer $\prev$, we must {\em reify} the contained substitutions into let statements, yielding
\begin{lstlisting} 
let yhat = f 20 in
let zhat = yhat * yhat * 7 in z
\end{lstlisting}

This concludes stage \bbone\ evaluation of the program---we have reduced all
\bbone\ redexes, resulting in a monostaged term in \langTwo. Stage \bbtwo\
evaluation, $\tworedsym$, then reduces this to a numeral.

\subsubsection{Evaluation and Speculation}
\label{ssec:dynamics}

\input{figures/dynamics}

Our dynamics for \lang\ implements the stage \bbone\ evaluation algorithm
described above, using three judgments: $\redonesym$ (evaluation), $\redtwosym$
(speculation), and $\reifysym$ (reification of substitutions into let
bindings).

The algorithm described above creates three different kinds of expressions which
cannot be evaluated further at a particular stage:
\begin{itemize}
\item Partial values ($\pvalsym$s) are stage \bbone\ terms that have been fully
evaluated, but which may contain stage-\bbtwo\ variables wrapped in $\next$
blocks.  In the example above, 
\verb|(|$\next \{\mathtt{\hat y}\}$\verb|,7)|.

\item Residuals ($\ressym$es) are \langTwo\ terms---stage \bbtwo\ terms whose
stage \bbone\ subexpressions have all been fully evaluated. In the example
above,
\verb|(1+2)| and \verb|(let z = y*y*7 in z)|.

%\item Values ($\valsym$s) are \langTwo\ terms which are fully evaluated; these
%are the results of a computation after both stages have been completed. In the
%example above, the term evaluates to \verb|63|.
\end{itemize}


The $\redonesym$ judgment takes an open stage \bbone\ term to a {\em future
environment} $\xi$ and a partial value $v$.  The future environment implements
the explicit substitutions in our example---it maps fresh stage \bbtwo\
variables (which may appear inside $\next$ blocks in $v$) to
residuals. For non-staging features of \lang\ (\ref{fig:diaSemanticsCore}),
$\redonesym$ is essentially standard call-by-value evaluation, and gathers the
subterms' future environments into a single one.


At $\next~e$, in contrast, $\redonesym$ must search through $e$ for any stage
\bbone\ subexpressions, and evaluate them.  (See \ref{fig:diaSemanticsNP}.)
This search process, called \emph{speculation}, is implemented by the
$\redtwosym$ judgment, which takes a stage \bbtwo\ term to a residual. 

For the most part (\ref{fig:diaSemanticsSpec}), speculation simply recurs into
all subexpressions; at $\prev$, however, it resumes $\redonesym$ evaluation,
which produces a future context $\xi$ and (by canonical forms) an expression
$\next\{\hat y\}$. We then reify $\xi$ using $\reifysym$ into a series of let
bindings enclosing $\mathtt{\hat y}$.

Once speculation reduces $e$ to a residual $q$, the output of $\redonesym$ is a
fresh variable wrapped in a $\next$ block ($\next~\hat y$), along with a future
environment which maps that variable to the residual ($\hat y \mapsto q$).

Within speculation lies a subtle---if perhaps unintuitive---feature.  
Observe that speculation will traverse into both branches of a stage-\bbtwo\ {\tt if} or {\tt case} 
statement in its search for stage~\bbone\ code. 
Thus the evaluation of that stage~\bbone\ code will occur {\em regardless of the eventual value of the predicate},
and so a term like 
\begin{lstlisting} 
next{
  if true 
  then hold{1+2} 
  else prev{spin() (* loops forever *)}
}
\end{lstlisting}
will fail to evaluate at stage \bbone.
This behavior is why the judgment is named ``speculation."

The context ($\Gamma$) keeps track of stage \bbtwo\ variables in the input term. 
These both appear in the original program at stage \bbtwo\ and are inserted by the semantics.

As an optimization, we can include the special-case rule,
\begin{mathpar}
\inferdiaone [hat] {\red {\next~\hat y}{\cdot,\next~\hat y}}{\cdot}
\end{mathpar}
to avoid one-for-one variable bindings in the residual.
We used this implicitly in the example in the previous section.

If we change the $\next$ and $\prev$ rules to 
\begin{mathpar}
\infer {\diaone {\next~e}{\cdot,\next~q}} {\diatwo e q} \and
\infer {\diatwo{\prev~e}{v}} {\diaone e {\cdot,\next~v}} 
\end{mathpar}
and treat $\next~q$ as a partial value for any residual $q$,
then our semantics becomes rule-for-rule isomorphic to that from \cite{davies96}. This essentially bypasses the
environment bookkeeping in $\redonesym$, by inlining residuals instead of
hoisting them in \verb|let|-bindings.
From this it's clear that the semantics of \cite{davies96} and ours always produce the same value when they both terminate.
{\em Because \lang's semantics dictate that a reified residual will always be evaluated, regardless of whether its result is consumed, \lang\ programs terminate strictly less often than that of \cite{davies96}}.

\subsubsection {Top-Level Evaluation}
\label{sec:partialeval}

These dynamics allow us to define a partial evaluator.
Recall that partial evaluators operate on multivariate functions $f$, whose
inputs are each labeled either {\em static} or {\em dynamic}. Once the static
inputs are provided, partial evaluation of $f$ produces a residual depending on
only the dynamic input. Mathematically, a partial evaluator is any $p$ such
that
\[
	\forall f,x. \exists f_x. [p(f,x) = f_x \text{ and } \forall y.\llbracket f \rrbracket(x,y)=\llbracket f_x \rrbracket(y)]
\]
where $\llbracket \cdot \rrbracket$ translates the text of a function to its
mathematical interpretation (a la \cite{jones96}). Here, $x$ is the static
input, $y$ is the dynamic input, and $f_x$ is the residual, that is, \emph{$f$
specialized to $x$}.

% KAYVONF: good statement, but hold out for now
%The hope of partial evaluation is that $f_x$ is cheaper to execute than $f$, meaning that we can save work if we must %evaluate it many times.

We define a partial evaluator for \lang\ by identifying static with stage
\bbone\ and dynamic with stage \bbtwo.  Specifically, we encode $f$ as a \lang\
expression with a function type of the form $A\to\fut(B\to C)$.%
%\cprotect\footnote{We can rewrite \texttt{fexp} in this form, or simply apply
%the following higher-order function which makes the adjustment:
%\begin{lstlisting} 
%let adjust (f : $int * int -> $int) =
%  fn (p : int) => 
%    next{
%      fn (b : int) => 
%        prev{f (next {b}, p)}
%    }
%\end{lstlisting}}
%
Here $A$ is the static input, $B$ is the dynamic input, and $C$ is the output.

Once a stage \bbone\ argument $a:A$ is provided, we can evaluate the partially-applied
function:
$\cdot\vdash f~a \mathop{\redonesym} [\xi,v]$.
The result is an environment $\xi$ and a partial value $v$ of type $\fut(B\to
C)$, which by canonical forms must have the form $v = \next~\hat y$. 
Next, we reify this environment into a sequence of \verb|let|-bindings
enclosing $\hat y$, via $\reify\xi{\hat y}{f_a}$. 
Because reification preserves types, the resulting residual $f_a$ has type $B\to C$ in \langTwo, so we can apply it to some $b:B$
and compute the final result of the function, $f_a~b \mathop{\tworedsym} c$.

That this sequence of evaluations is in fact staged follows from our
characterizations of partial values and residuals, that $\redonesym$
outputs a partial value, and that $\reifysym$ outputs an expression in \langTwo.

For example, to specialize quickselect to a particular list, 
\begin{lstlisting}
qsStaged [5,2,7,4,1]
\end{lstlisting}
\TODO finish example

%\begin{remark}
%For any $\colone{e}{A}$ containing no $\next$ subexpressions, $\redonesym$ will
%always compute an empty environment, and a partial value identical to the result
%of call-by-value evaluation of $e$.
%%derivationally equivalent to standard call-by-value evaluation.
%\end{remark}

%\subsection{Metatheory}
%
%Recall that residuals live in \langTwo; we will indicate typing judgments in
%\langTwo\ with $\vdash_\bbtwo$.
%
%%\begin{definition}
%%Context $\Gamma$ is well-formed ($\Gamma\wf$) if it
%%contains only stage-2 variables.
%%\end{definition}
%
%\begin{definition}
%An environment $\xi$ is well-formed ($\Gamma\vdash\xi\wf$) if either:
%\begin{enumerate}
%\item $\xi = \cdot$; or
%\item $\xi = \xi',x:B\mapsto e$ where
%$\Gamma\vdash\xi'\wf$ and
%$\typeslangTwo[\Gamma,\dom{\xi'}] e B$
%%$\Gamma,\dom{\xi'}\vdash \coltwo{e}{B}$ and
%%$\Gamma,\dom{\xi'}\vdash e \res$.
%\end{enumerate}
%\end{definition}
%
%\begin{theorem}
%If $\typeswor e A$ then $\Gamma\wf$ and $A\istypewor$.
%\end{theorem}
%
%\begin{theorem}
%If $\diaonesub$ and $\typesone e A$ then
%\begin{enumerate}
%\item $\Gamma\vdash\xi\wf$;
%\item $\Gamma,\dom\xi\vdash \colone{v}{A}$; and
%\item $\Gamma,\dom\xi\vdash v\pval$.
%\end{enumerate}
%\end{theorem}
%
%\begin{theorem}
%If $\diatwosub$ and $\typestwo e A$ then
%\begin{enumerate}
%\item $\typeslangTwo q A$; and
%\item $\Gamma\vdash_\bbtwo q\val$.
%\end{enumerate}
%\end{theorem}
%
%\begin{theorem}\label{thm:reify-type}
%If $\Gamma\vdash\xi\wf$ and
%$\Gamma,\dom\xi\vdash \colone{\next\ \hat y}{\fut A}$
%then 
%$\reify{\xi}{\hat y}{q}$ and
%$\typeslangTwo q A$.
%\end{theorem}

%\TODO
%Note somewhere how to run stage-one non-$\fut A$ terms. For example, a stage-one
%integer term is guaranteed not to depend on the table, although one might be
%produced. One may either discard the table, or evaluate everything in the table
%(and terminating with the partial value iff everything in the table terminates).


