%!TEX root = paper.tex

\section{\texorpdfstring{\lang}{Î»12} Statics and Dynamics}
\label{sec:semantics}

\input{figures/grammars}

We express two-stage programs as terms in \lang, a typed, modal lambda calculus. 

One of the central concepts in the formalization of \lang\ is the notion of a \emph{world},
which includes and subsumes the concept of a stage.
Our system has three worlds: \bbonem, \bbonep, and \bbtwo.
Whereas there is only one world, \bbtwo, for second-stage computations,
there are two worlds corresponding to the first stage:
\bbonem\ for \emph{mixed} first-stage computations, which may contain second-stage subterms within $\next$ blocks,
and \bbonep\ for \emph{ground} first-stage computations, which may not.
The distinction between these two first-stage worlds is necessitated by our splitting algorithm
and will be discussed in \ref{sec:needGround}.

The abstract syntax of \lang\ is presented as a grammar in \ref{fig:grammar}.  
Note that some production rules are parameterized by world.
Our syntax also distinguishes values from general terms, 
with underline term constructor (``$\exv v$'') explicitly noting the inclusion of values into general terms.
There are three forms of value: \emph{partial values} for \bbonem, \emph{ground values} for \bbonep, and \emph{residuals} for \bbtwo.
All represent computations which have no remaining work in the first stage.

\subsection{Statics}
\label{sec:statics}

\input{figures/statics}

\begin{abstrsyn}

The typing judgment $\typeswor e A$, defined in \ref{fig:statics}, means that
$e$ has type $A$ at world $w$, in the context $\Gamma$. 

All three worlds contain unit, product, and function types defined in the usual fashion;
sum and recursive types are provided for worlds \bbonep\ and \bbtwo.
These ``standard'' features can only be constructed from subterms of the same world,
and variables can only be used at the same world where they were introduced.

Differing worlds (and hence, differing stages of computation) interact by means
of the $\fut$ and $\curr$ type formers.  These modalities are internalizations
of typing at worlds \bbtwo\ and \bbonep, respectively, to typing at \bbonep.
For example, given a term $e$ of type $A$ at world \bbtwo, 
$\next{e}$ has type $\fut A$ at \bbonem. This essentially
encapsulates $e$ as a computation to be evaluated in the future---first-stage
computations can shuffle it around, but not use its result.  The only way to use
a $\fut A$ is to wrap it with $\prev$, yielding an $A$ at \bbtwo.

$\curr A$ is a type in world \bbonem\ which classifies purely-first-stage
computations of type $A$. Given a world \bbonep\ term $e$ of type $A$,
$\pure{e}$ has type $\curr A$ at world \bbonem. ($e$ is guaranteed not to contain
second-stage computations because $\fut$ types are not available in world
\bbonep.)

Although products and functions are restricted to types at the same world,
$\fut$ allows construction of ``mixed-stage'' products and functions.
For example, \texttt{qss} is a function at world \bbonem\ which takes a
$\curr{\rm list} \times \fut\rmint$ (a purely-first-stage list and a
second-stage integer) to a $\fut\rmint$ (a second-stage
computation of an integer).

An $e$ of type $\curr A$ at \bbonem\ can be unwrapped as an $A$ at \bbonep\
using the $\letp xe{e'}$ construct, which binds $\colpure xA$ in a \bbonem\ term
$e'$. This allows us to compute under $\curr$---for example, given a $\colmix
p{\curr(A\times B)}$, the term $\letp{x}{p}{\pure{\pio x}}$ computes its first
projection, of type $\curr A$.

Lastly, to case on a term $e$ of type $\curr(A+B)$ at world \bbonem, we need the
$\caseP{e}{x.e_1}{x.e_2}$ construct, whose branches are world \bbonem\ terms
open on $\curr{A}$ and $\curr{B}$ respectively.

The example code in this paper makes liberal use of $\rmint$s and various
functions on these, as well as a function $\pause$ which takes a $\curr\rmint$
to a $\fut\rmint$.%
\footnote{$\pause$ is definable in \lang\ given an inductive definition of
$\rmint$s. In practice, we provide both $\rmint$s and $\pause$ as primitives.
It is sensible to extend $\pause$ to all base types and to products and sums
thereof. This is related to the notion of {\em mobility} in \cite{murphy05} and
{\em stability} in \cite{krishnaswami13}.}

\end{abstrsyn}


\subsection{Dynamics}
\label{sec:dynamics}

\input{figures/dynamics}

The central tenet of a staged language
is that first stage code should be evaluated entirely before second stage code.
Accordingly, our dynamics operates in two passes.
The first pass takes an input program $\coltwo e A$ and reduces it to a residual,
$\exv q$, and the second pass further reduces this residual.
Since a residual $q$ is a monostage objects, this second pass is just standard monostage evaluation.
Consequently, this paper is concerned only with the first pass of evaluation.

Since $\coltwo e A$ may be constructed out of terms at other worlds, 
our dynamics requires notions of values and steps that are specialized to each world.

\paragraph{World \bbtwo.} Steps at world \bbtwo\ are given by the judgement $\steptwo e {e'}$.
Since no reduction of stage two terms is to take place, this judgement does nothing but search for \prev\ blocks within $e$.
A world \bbtwo\ term is done evaluating when it has the form $\exv q$, where $q$ is a residual. 
To be a residual, a term must have no first stage subterms (equivalently, no $\prev$s), even within the body of a function or branches of a case.
This implies that $\stepsym \bbtwo$ must proceed underneath second stage binders.

\paragraph{World \bbonep.} Since the ground fragment of the language is not dependent on other worlds, the semantics of ground is just that of a monostage language.
Thus, $\steppure e {e'}$ searches for redexes and reduces them in the standard way, and a ground value $u$ comprises only units, injections, tuples, and functions, where the body of the function may be any ground term.

\paragraph{World \bbonem.}
Like its ground counterpart, the \bbonem\ step judgement, $\stepmix e {e'}$, searches for redexes and reduces them in place.
It also descends into $\pure$ and $\next$ blocks, transitioning into one of the other kinds of steps there. 
The value form for \bbonem, called a partial value, comprises units, tuples, functions, $\pure$ blocks of ground values, and $\next$ blocks containing \emph{only a stage two variable}.
This strong requirement ensures that second-stage computations are not duplicated when partial values are substituted for variable,
as they would be in the staged semantics of \cite{taha-thesis-99} and \cite{davies96}.
For example, consider:
\begin{lstlisting}
2`prev{`1`(fn x : $int => e') (next{`2`e`1`})`2`}`
\end{lstlisting}
We could reduce this to $\prev([\next~e/x]e')$, but this may potentially duplicate an
expensive computation $e$. Instead, we choose to \emph{hoist} $e$ outside, binding it
to a temporary variable $\hat{y}$, and substituting that variable instead:
\begin{lstlisting} 
2`let val yhat = e in prev{`1`[next{`2`yhat`1`}/x]e'`2`}`
\end{lstlisting}
This behavior is implemented by the $\lift e {e'}$ judgement, called a hoisting step.
These steps are introduced when a \next\ block has contents that are a residual but not already a variable.
In essence, they operate by ``bubbling up'' a subtitution to the innermost containing \prev,
where it is reified into a {\tt let} statement.

\subsection{Type Safety}

The statics and dynamics of \lang\ are related by a type safety theorem
comprising progress and preservation, again annotated by world.
In all cases below, $\Gamma$ may be any list of variable bindings at world \bbtwo,
representing the second stage binders under which we are evaluating.
\begin{theorem}\leavevmode
\label{thm:progress} 
\begin{itemize} 
\item If $\typesone e A$, then either $e$ has the form $\exv v$, or $\stepmix e {e'}$, or $\lift e {e'}$.
\item If $\typespure e A$, then either $e$ has the form $\exv u$, or $\steppure e {e'}$.
\item If $\typestwo e A$, then either $e$ has the form $\exv q$, or $\steptwo e {e'}$.
\end{itemize}
\end{theorem}
\begin{theorem}\leavevmode
\label{thm:preservation} 
\begin{itemize} 
\item If $\typesone e A$ and $\lift e {e'}$, then $\typestwo q B$ and $\typesone [\Gamma,\coltwo y B] {e'} A$.
\item If $\typeswor e A$ and $\stepwor e {e'}$, then $\typeswor {e'} A$.
\end{itemize}
\end{theorem}

\subsection{Evaluating Staged Programs}

The multistage function \texttt{qss} from \ref{sec:overview} has
type $A\to \fut (B \to C)$ at \bbonem.%
\footnote{We can rewrite \texttt{qss} in this curried form, or apply a
higher-order currying function.}
To apply this function to arguments $\colmix a A$ and $\coltwo b B$, simply
evaluate the program:
\begin{lstlisting}
2`prev{`1`f a`2`} b`
\end{lstlisting}

We can also directly observe the reuse of first-stage computations across
multiple second-stage computations. To run many order statistics queries
$\texttt{k1},\dots,\texttt{km}$ on the same list, run the program:
\begin{lstlisting}
2`let val qs = prev{`1`qss `3`gr{`1`[7,4,2,5,9,...,3]`3`}`2`}`
2`in (qs k1,...,qs km)`
\end{lstlisting}
To see that the partial application of \texttt{qss} is only evaluated once,
observe that after the first stage of evaluation, the residual has the form:
\begin{lstlisting}
2`let val yhat = ...`
2`    val qs = yhat`
2`in (qs k1,...,qs km)`
\end{lstlisting}
where $\hat{y}$ is bound to a function containing no first-stage redexes.
