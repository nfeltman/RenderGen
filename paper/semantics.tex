

\section{A Two-Stage Modal Language}

Introduce the next and prev concepts, along with typesystem.  Introduce binding time analysis here, and explain that we don't care about it.  Show some examples.  Introduce a hold operation.

\section{Semantics}

Previous work (\cite{davies96}) focuses on the correspondence between the type system and existing temporal logics, whereas we care more about operational behavior and cost.  In this section, we'll consider a few proposals for our language before settling on one we like.  All of the proposals are call-by-value, differing primarily in how they handle values of $\fut$ type.

\subsection{The Erasure Semantics}

We first consider the {\em erasure semantics}, so called because it corresponds to what one would get by interpreting \lamStaged as a single-stage language, ignoring all of the $\next$ and $\prev$ terms.  This gives us two judgements, $\erasone$ and $\erastwo$, corresponding to {\em multistage evaluation} at \bbone and at \bbtwo.  We call these judgments  ``multistage'' because they cause work to happen at both stages.

Both judgments behave normally at non-staged features.  We cover their behavior at staged features below:

\begin{mathpar}
\infer {\next~e \erasone \next~v} {e \erastwo v} \and
\infer {\prev~e \erastwo \next~v} {e \erasone v} \and
\infer {\pause~e \erasone \next~i} {e \erasone i}
\end{mathpar}

Essentially, we immediately evaluate under the $\next$, yielding a value for $\fut$ types. The $\prev$ terms remove this wrapper.  As expected, $\pause$ also gives us a way to inject into the wrapper at integers.

The erasure semantics has some undesirable properties.  By intention, it interleaves the execution of stage-\bbone~and stage-\bbtwo~code, so the evaluation can't really be said to be staged (i.e. stage-\bbone~work is done before stage-\bbtwo~work).  Moreover, the erasure semantics cannot be equivalent to any semantics which does have this property!  To see why, consider the following code, which types to int at \bbtwo:

\begin{lstlisting} 
if 5*4*3*2 > 111 then
	prev{ hold (2+4) }
else
	prev{ loopForever () (* does not terminate *) }
\end{lstlisting}

Under the erasure semantics (using $\erastwo$), this code takes the top branch and evaluates to 6.  But in order know that the {\tt loopForever} function need not be called, the predicate had to be evaluated prior.  But the predicate is stage-\bbtwo, whereas {\tt loopForever} is stage-\bbone.  To borrow terminology from \cite{cave14}, this violates causality.  In order to avoid this problem, a valid semantics must {\em speculate} down the branches of any stage-\bbtwo~if or case statement (or similarly into the body of a stage-\bbtwo function) to find and evaluate all of the stage-\bbone~code.  Both of the other semantics we will consider have this property.

The benefit of the erasure semantics is that it's very natural, and has a familiar cost model.  It also {\em obviously} produces the ``correct'' answer, so we can use the erasure semantics as a reference to prove the reasonableness of any other semantics.

\subsection{Meta Semantics}

A different semantics was provided in \cite{davies96}.  We briefly review a two-stage version of that semantics here.

In the erasure semantics, $\next v$ is a value only if $v$ is fully reduced.  But in the meta semantics, $\next e$ is a value only if $e$ has no $\prev$ terms; $v$ is allowed to have unreduced stage-2 computation. 

...

The Davies semantics is comprised of two mutually recursive judgements: $\daviesz$ and $\davieso$.  For some $\colone e A$, the $\daviesz$ judgment evaluates only the first-stage parts of $e$, leaving unevaluated second-stage code within $\next$s.  (... This essentially gives us partial evaluation, and we're left to just evaluate the residual normally to get multi-stage evaluation...) 

The benefit of the meta semantics is that it gives us a very explicit notion of partial evaluation.  This also, by construction, means that the meta semantics does all of the first stage-work {\em before} the second stage work begins. 

The $\next$-by-name behavior of the meta semantics of course means that it happily duplicates second-stage code, which could increase the cost.  This makes reasoning about second-stage cost rather difficult.

\begin{lstlisting} 
let x = next {4+5} in
next{prev{x} * prev{x}}
\end{lstlisting}

\subsection{Our Semantics}

We desire a semantics that meets the following goals:

\begin{enumerate}
\item Modulo termination, it should be equivalent to the erasure semantics.
\item All of the first stage work should be completed before second stage work.  Ideally, it should just have a notion of partial evaluation, like the meta semantics.
\item Should be $\next$-by-value, rather than $\next$-by-name, like the erasure semantics.  
\end{enumerate}

We meet all of these goals.

In this section, we introduce a dynamic semantics for our language.  Although our type system is virtually identical to that in \cite{davies96}, the semantics is different in terms of cost and termination behavior. 

Abstractly, we can think of our evaluation as proceeding in the standard way for stage-1 code. When the evaluator encounters a $\next \{e\}$ expression, it places $e$ off to the side in a table and replaces the whole expression with a reference to the table entry.  These references are then passed around as stage-1 values for $\fut$ types.  But what if $e$ contains $\prev$ expressions?  To ensure that all stage-1 code is evaluated before any stage-2 code, we must evaluate all of the 1-code contained in $e$ before inserting it into the table.  This entails searching $e$ for all contained $\prev$s and evaluating them in place.  

More formally, evaluation comprises the folowing judgments:

\begin{center}
\begin{tabular}{|c|p{2.5cm}|p{2.5cm}|} \hline
Judgment & Reads & Conditions \\ \hline 
$\isvalone e$ & ``$e$ is a $\bbone$-value under context $\Xi$'' & ... \\ \hline 
$\diaonesub$ & ``$e$ evaluates to future table $\xi$ and value $v$'' 
& $\typesone e A$ 
	\newline $\isvalone v$ 
	\newline ... \\ \hline 
$\diatwosub$ & ``$e$ speculates to $q$'' & ... \\ \hline 
...&...&... \\ \hline
\end{tabular}
\end{center}

Evaluation and speculation are the main judgments here, the rest being largely administrative.  The evaluation judgment operates on stage-1 code, whereas the speculation operates on stage-2 code.  Since $\next$ and $\prev$ are the crossover points between 1-code and 2-code, they are correspondingly the only places where the evaluation and speculation judgments depend on the other. 


The evaluation judgment is very similar to standard call-by-value evaluation, as goal 1 would suggest.  The input to evaluation is a stage-1 expression (usually $e$), as well as two administrative contexts ($\Gamma$ and $\Xi$), covered later.  Evaluation has two outputs: the {\em future table} (usually $\xi$) and the {\em partial value} (usually $v$).  We cover the latter first.  The partial value is essentially the result of the first-stage portion of $e$, and must be a 1-value of the same type as $e$.  As usual, this means that $v$ must be composed only of base primitives, tuples, injections, and lambdas (corresponding to base types, products, sums, and functions).  Analogously, the value corresponding to $\fut$ is a construct called a {\em hatted variable} (written $\hat y$), which signifies a reference to some stage-2 computation.  

...

\subsection{Other nice properties}

\begin{enumerate}
\item For some $\colone{e}{A}$ containing no $\next$ expressions, the semantics is derivationally equivalent to standard call-by-value evaluation.
\item Second-stage cost is identical to the erasure semantics.
\item First stage cost is different that erasure, do to speculation.  We always evaluate stage-1 code once, which increases cost, except when that stage-1 code was inside a 2-lambda that got evaluated many times.
\end{enumerate}

\subsection{Metatheory}

\TODO unfinished; where should this go? combine with table above

\noindent\TODO terminology for $\Xi,\Gamma,\xi,v,q$?

\noindent\TODO need to define 1-vals at 1 and 2, and 2-vals at 2. what is the
terminology? (?, residuals, results?)

\noindent\TODO put $\Xi$ and $\Gamma$ in the judgments where appropriate

\noindent\TODO be uniform about which judgments have which contexts, etc

% local macros; put them in macros.tex once they are more finalized
\newcommand{\wf}{\ \mathsf{wf}}
\newcommand{\valoo}{\ \bbone\textsf{-}\mathsf{val} @ \bbone}
\newcommand{\valot}{\ \bbone\textsf{-}\mathsf{val} @ \bbtwo}
\newcommand{\valtt}{\ \bbtwo\textsf{-}\mathsf{val} @ \bbtwo}

\begin{definition}
Contexts $\Xi$ and $\Gamma$ are well-formed ($\Xi\wf$, $\Gamma\wf$) if they
contain only stage-2 variables.
\end{definition}

\noindent\TODO don't call it a table

\noindent\TODO what is the notation for $\xi$s? how do you build them?

\noindent\TODO define reification explicitly as a metafunction

\begin{definition}
A table $\xi$ is well-formed ($\xi\wf$) if either:
\begin{enumerate}
\item $\xi = \cdot$; or
\item $\xi = \xi',x\mapsto e$ where
$\Xi,\dom{\xi'};\Gamma\vdash e : B @ \bbtwo$ and
$\Xi,\dom{\xi'};\Gamma\vdash e \valot$.
\end{enumerate}
\end{definition}

\begin{theorem}
If $\Xi;\typesone e A$ then $\Xi\wf$, $\Gamma\wf$, and $A\istypeone$.
\end{theorem}

\begin{theorem}
If $\diaonesub$ then:
\begin{enumerate}
\item $\typesone e A$ for some 1-type $A$;
\item $\xi\wf$;
\item $\Xi,\dom\xi;\cdot\vdash v : A @ \bbone$; and
\item $\Xi,\dom\xi;\cdot\vdash v\valoo$.
\end{enumerate}
\end{theorem}

\begin{theorem}
If $\diatwosub$ then:
\begin{enumerate}
\item $\typestwo e A$ for some 2-type $A$;
\item $\Xi;\Gamma\vdash q : A @ \bbtwo$; and
\item $\Xi;\Gamma\vdash q\valtt$.
\end{enumerate}
\end{theorem}


