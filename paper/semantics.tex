%!TEX root = paper.tex

\section{\texorpdfstring{\lang}{Î»12} Statics and Dynamics}
\label{sec:semantics}

\input{figures/splitting-overview}

\input {figures/grammars}

We express two-stage programs as terms in \lang, a typed, modal lambda calculus
with products, sums, and isorecursive types. Its type system has three distinct
\emph{worlds} \bbonep, \bbonem, and \bbtwo, which respectively classify
\emph{ground first-stage} computations (\bbonep); 
first-stage computations containing a \emph{mix} of code from each stage
(\bbonem); 
and second-stage computations (\bbtwo).

\subsection{Statics}

\input {figures/statics}

\begin{abstrsyn}

The typing judgment $\typeswor e A$, defined in \ref{fig:statics}, means that
$e$ has type $A$ at world $w$, in the context $\Gamma$. (Variables in the
context are also annotated with the world at which they live.)

All three worlds contain unit, product, sum, function, and recursive types
defined in the usual fashion. For example, given two terms $\typesone{e_1}A$ and
$\typesone{e_2}B$ at world \bbonem, one can form the pair
$\typesone{\texttt{<}e_1,e_2\texttt{>}}{A\times B}$ also at world \bbonem. 

Differing worlds (and hence, differing stages of computation) interact by means
of the $\fut$ and $\curr$ type formers. $\fut A$ is a type in world \bbonem\
which classifies second-stage computations of type $A$. Given a term $e$ of type
$A$ at world \bbtwo, $\next{e}$ has type $\fut A$ at \bbonem. This essentially
encapsulates $e$ as a computation to be evaluated in the future---first-stage
computations can shuffle it around, but not use its result.  The only way to use
a $\fut A$ is to wrap it with $\prev$, yielding an $A$ at \bbtwo.

%This is why well-typed terms cannot have any information flow from stage
%\bbtwo\ to stage \bbone, and what makes splitting possible.

Although our products and functions are restricted to types at the same world,
$\fut$ essentially allows us to build ``mixed-stage'' products and functions.
For example, quickselect is a function at world \bbonem\ which takes a
$\curr{\rm list} \times \fut\rmint$ (a purely-first-stage list and a
second-stage computation of an integer) to a $\fut\rmint$ (a second-stage
computation of an integer).

$\curr A$ is a type in world \bbonem\ which classifies purely-first-stage
computations of type $A$. Given a world \bbonep\ term $e$ of type $A$,
$\pure{e}$ has type $\curr A$ at world \bbonem. ($e$ is guaranteed not to contain
second-stage computations because $\fut$ types are not available in world
\bbonep.)

An $e$ of type $\curr A$ at \bbonem\ can be unwrapped as an $A$ at \bbonep\
using the $\letp xe{e'}$ construct, which binds $\colpure xA$ in a \bbonem\ term
$e'$. This allows us to compute under $\curr$---for example, given a $\colmix
p{\curr(A\times B)}$, the term $\letp{x}{p}{\pure{\pio x}}$ computes its first
projection, of type $\curr A$.

Lastly, to case on a term $e$ of type $\curr(A+B)$ at world \bbonem, we need the
$\caseP{e}{x.e_1}{x.e_2}$ construct, whose branches are world \bbonem\ terms
open on $\curr{A}$ and $\curr{B}$ respectively.

The example code in this paper makes liberal use of $\rmint$s and various
functions on these, as well as a function $\pause$ which takes a $\curr\rmint$
to a $\fut\rmint$.

\end{abstrsyn}

\subsection{Dynamics}
\label{sec:stagedsemantics}

\crem{fold in the next paragraph}

Given a \lang\ term, the dynamic semantics can be used
to reduce the term to a \langmono\ program, called {\em residual} by
using one application of stage-1 evaluation, one application of
reification, followed by one application of stage-2 evaluation.

As is the case in essentially all staged languages, the dynamic
semantics evaluate a term to a residual (a term in the target
language \langTwo) in two stages. In the first stage, all stage-1
terms are evaluated by a relation, called {\em 1-evaluation}; in the
second stage all stage-2 terms are evaluated by a relation
$\redtwosym$, called {\em residualization}.  To eliminate duplication,
our semantics lifts out each stage-2 term nested inside of a stage-1
expressions, into a table which makes it possible for the stage-2
term---more precisely the corresponding residual obtained by reducing
all stage-1 subterms---to be referred to by use a dynamically
generated variable (a label).

\input{figures/dynamics}

Since stage-1 evaluation does not evaluate stage-2 terms and since
stage-2 terms may be nested inside stage-1 terms, 1-evaluation cannot
reduce \lang\ terms to values.  Instead 1-evaluation yields a {\em
  partial value}, which which is a stage~\bbone\ term that have been
evaluated except for its stage-2 subterms, which can only
be~\bbtwo\ variables wrapped in $\next$ blocks.  \ref{fig:grammar}
defines partial values.

In order to avoid duplication of stage-2 computations, 1-evaluation
labels stage-2 computations by generating variable symbols for them as
needed and stores their residuals in a {\em residual table} keyed by
the variable.

The relation 1-evaluation, defined by $\redonesym$ judgment as shown
in \ref{fig:diaSemantics}, takes an stage \bbone\ term%
\footnote{ The input to $\redonesym$ may be open on stage \bbtwo\ variables, but
the type system ensures that those must occur under a $\next$. Consequently
$\redonesym$ will never directly encounter a variable.}
%
to a residual table $\xi$ and a partial value $v$.  For non-staging
features of \lang, $\redonesym$ is essentially standard call-by-value
evaluation but in addition gathers the subterms' residual tables into
a single table. Residual table entries are created by the
evaluation of \next: 1-evaluation reduces a \next\ expression by
reducing the body of the \next\ with residualization to obtain a
residual $q$ and returns a residual table that maps a freshly
generated variable to the residual. 

The relation residualization, defined by $\redtwosym$ judgment, as shows
in \ref{fig:diaSemantics}, takes a stage \bbtwo\ term and reduces it to
a residual.  Apart from the evaluation of \prev\ and \pause, the
evaluation is straightforward. To reduce a \prev\ term, residualization
reduces the body by 1-evaluation to obtain a residual table and a
partial value.  It then reifies the residual table and the partial
value into an residual term, by creating for each variable-residual
pair in the table a corresponding variable binding in the residual,
finally ending with the partial value.

We can use the evaluation relations in the dynamic semantics to
evaluate a term to evaluate a \lang\ term as follows. We first apply
1-evaluation to obtain a partial value and a residual table. We then
construct a 2-term from the partial value and the residual table by
using reification, and then reduce this term to a residual via
residualization.  Finally, we evaluate the residual, which is a term in a
our monostaged target language \langmono, to a value by using  a
standard evaluation relation for \langmono.

%% Umut: superseded by what is above.
%% Version Nov 7, 2014

%% \subsection{Dynamics}
%% \label{sec:stagedsemantics}

%% Specifically, the dynamic semantics consist of two evaluation
%% relations $\redonesym$ and $\redtwosym$, called {\em 1-evaluation} and
%% {\em residualization}, that respectively evaluates stage-1 and stage-2
%% expressions. The relation 1-evaluation maps a stage-1 term to a
%% partial value and a residual table. A {\em partial value}, can be
%% thought as a value except that it might include references to stage-2
%% code stored in the {\em residual table}, which maps variables to
%% residuals.  The relation residualization takes a stage-2 term and maps to
%% a residual.  To generate the residual table, the dynamics semantics
%% relies on a {\em reification} relation, $\reifysym$, that maps a table
%% to a residual, essentially generating a target expression representing
%% the computations in the table.  We can evaluate a \lang\ term as
%% follows: we first apply 1-evaluation to obtain a partial value and a
%% residual table, we then construct a 2-term from the partial value and
%% the residual table by using reification, and then reduce this term to
%% a residual via residualization.


%% In the quickselect example, stage~\bbone\ terms are contained within
%% stage~\bbtwo\ terms---for example, in the recursive call to {\tt qsStaged}. In
%% this case, if we use an ordinary evaluation strategy reducing outermost redexes
%% first, we would no longer have staged evaluation, as stage~\bbtwo\ code would
%% be evaluated before stage~\bbone\ code. 

%% Thus, the dynamic semantics for \lang\ evaluates all of a term's stage \bbone\
%% subexpressions before any of its stage~\bbtwo\ subexpressions. This results in
%% a stage \bbtwo\ term with no stage~\bbone\ content, 
%% which can be described as a term in a monostaged language called \langTwo. 
%% Then, at stage~\bbtwo, we complete
%% evaluating this term with a standard dynamic semantics, $\tworedsym$. (The
%% rules for this judgment are not shown, but they are standard.)

%% \subsubsection{Stage~\bbone\ Evaluation}

%% To gain intuition about the challenges of implementing this staged dynamic
%% semantics, consider the program:
%% \begin{lstlisting}
%% 1`#2 (next {`2`f 20`1`}, 2+3)`
%% \end{lstlisting}
%% This is a stage~\bbone\ expression of type $\rmint~@~\bbone$; the pair inside it is a
%% stage~\bbone\ expression of type $(\fut\rmint)\times\rmint~@~\bbone$; and ${\tt f} :
%% \rmint \to \rmint~@~\bbtwo$ is an expensive stage~\bbtwo\ function which we would like
%% to avoid evaluating. A conventional call-by-value semantics would fully
%% evaluate both components of the pair before projecting the second component.
%% The problem is that, while \verb|next {f 20}| is not a value (in the sense that
%% additional stage-\bbtwo\ computation steps are necessary to produce a numeral),
%% evaluating the contents of \verb|next| cannot occur as part of stage~\bbone\
%% evaluation.

%% Intuitively, the solution is to designate \verb|next {f 20}| as a value
%% \emph{in stage \bbone}, even though it requires additional evaluation in stage
%% \bbtwo. Therefore, the pair evaluates to
%% \begin{lstlisting}
%% 1`(next {`2`f 20`1`}, 5)`
%% \end{lstlisting}
%% and the projection, in turn, immediately evaluates to \verb|5|.

%% Now consider a more complex example where stage~\bbone\ evaluation must
%% substitute such an incompletely-evaluated expression. The following
%% stage-\bbtwo\ term has type $\rmint$:
%% \begin{lstlisting} 
%% 2`prev{`
%%   1`let x = (next {`2`f 20`1`}, 3+4) in
%%   next{` 2`prev{`1`#1 x`2`} * prev{`1`#1 x`2`} * hold{`1`#2 x`2`}` 1`}`
%% 2`}`
%% \end{lstlisting}
%% As with the simpler example, this term does not fully reduce at stage~\bbone, 
%% because it depends on the value of \verb|f 20|, which is not reduced until stage \bbtwo.

%% Again treating \verb|(next {f 20}, 7)| as a value during stage~\bbone, we
%% substitute it for the three occurrences of \verb|x| in the body of the
%% \verb|let| expression, yielding
%% \begin{lstlisting} 
%% 2`prev{`
%%   1`next{` 2`prev{`1`#1 (next {`2`f 20`1`}, 7)`2`} 
%%       * prev{`1`#1 (next {`2`f 20`1`}, 7)`2`} 
%%       * hold{`1`#2 (next {`2`f 20`1`}, 7)`2`} `1`}`2`
%% }`
%% \end{lstlisting}
%% The outermost $\next$ here is not yet a value, because there remains stage~\bbone\ work to do in its body.
%% So to proceed, the semantics must first search the body of the $\next$ for stage~\bbone\ subterms and reduce them in place.
%% This search process is called {\em specialization}.
%% In our example this means reducing all three projections to give,
%% \begin{lstlisting} 
%% 2`prev{`1`
%%   next{`2` 
%%     prev{`1`next {`2`f 20`1`}`2`} * prev{`1`next {`2`f 20`1`}`2`} * 7 
%%   `1`}`2`
%% }`
%% \end{lstlisting}
%% Since all stage~\bbone\ subterms are reduced, the $\prev$s and $\next$s cancel to yield the final residual:
%% \begin{lstlisting} 
%% 2`(f 20) * (f 20) * 7`
%% \end{lstlisting}
%% But now stage \bbtwo\ must compute the expensive function call \verb|f 20| twice! 
%% There are some systems, typically called {\em metaprogramming}, 
%% where this duplication would be considered intended behavior.
%% For our applications, we find the duplication undesirable and avoid it.

%% To get this behavior, we do not treat \verb|next {f 20}| as a value to be substituted, 
%% but instead bind \verb|f 20| to a fresh stage~\bbtwo\ variable $\mathtt{\hat y}$
%% and then substitute that variable.

%% More precisely, when evaluating the \verb|next|, we construct an explicit
%% substitution $\mathtt{[\hat y\mapsto f~20]}$ binding its old contents to the
%% fresh variable $\mathtt{\hat y}$. This substitution is placed at the top of the
%% containing $\prev$ block:
%% \begin{lstlisting} 
%% 2`prev {
%% [yhat|->f 20]
%%   `1`let x = (next{`2`yhat`1`}, 7) in
%%   next{`2`prev{`1`#1 x`2`} * prev{`1`#1 x`2`} * hold{`1`#2 x`2`}`1`}`2`
%% }`
%% \end{lstlisting}
%% %As a convention, we render the new variable with a %stylish and fashionable
%% %hat.  
%% We proceed with stage~\bbone\ evaluation, which now duplicates the variable
%% $\mathtt{\hat y}$ rather than the expression \verb|f 20|.
%% \begin{lstlisting} 
%% 2`prev {
%% [yhat|->f 20]
%%   `1`next{`2`
%%     prev{`1`#1 (next {`2`yhat`1`}, 7)`2`} * 
%%     prev{`1`#1 (next {`2`yhat`1`}, 7)`2`} *
%%     hold{`1`#2 (next {`2`yhat`1`}, 7)`2`}
%%   `1`}`2`
%% }`
%% \end{lstlisting}
%% We then specialize to reduce the projections and cancel the $\next$s and $\prev$s, giving:
%% \begin{lstlisting} 
%% 2`prev {
%% [yhat|->f 20]
%%     `1`next{`2`yhat * yhat * 7`1`}
%% `2`}`
%% \end{lstlisting}
%% Once again, we lift the results of specialization into a substitution:
%% \begin{lstlisting} 
%% 2`prev {
%% [yhat|->f 20,
%%  zhat|->yhat * yhat * 7]
%%     `1`next{`2`zhat`1`}`2`
%% }`
%% \end{lstlisting}
%% Finally, when canceling the last $\next$ and $\prev$, the semantics {\em reifies} the contained substitutions into let statements, yielding
%% \begin{lstlisting} 
%% 2`let yhat = f 20 in
%% let zhat = yhat * yhat * 7 in zhat`
%% \end{lstlisting}

%% This concludes stage \bbone\ evaluation of the program---we have reduced all
%% stage \bbone\ redexes, resulting in a monostaged term in \langTwo. Stage \bbtwo\
%% evaluation, $\tworedsym$, then reduces this to a numeral.

%% \subsubsection{Evaluation and Specialization}
%% \label{ssec:dynamics}

%% \input{figures/dynamics}

%% The dynamics for \lang\ implements the stage \bbone\ evaluation algorithm
%% described above using three judgments: $\redonesym$ (evaluation), $\redtwosym$
%% (specialization), and the auxiliary $\reifysym$ (reification). 
%% Along with these are three judgments identifying forms of values:
%% $\pvalsym$ (partial values), $\ressym$ (residuals), 
%% and the auxiliary $\fcon$ (residual table).
%% These judgments are related as follows:
%% \begin{itemize}
%% \item Evaluation sends a stage~\bbone\ term to a partial value.
%% In order to avoid duplicating subterms, evaluation collects explicit
%% substitutions into a single {\em residual table} that is also the output of
%% evaluation.
%% \item Specialization sends a stage~\bbtwo\ term to a residual.
%% \item Reification sends a single residual and a residual table to another residual.  
%% \item Evaluation depends on specialization for $\next$ terms, which have
%% stage~\bbtwo\ subterms.
%% \item Specialization depends on evaluation for $\prev$ and $\pause$, which have
%% stage~\bbone\ subterms. The residual table produced by evaluation is also
%% reified here.
%% \end{itemize}

%% \emph{Partial values} are stage~\bbone\ terms that have been fully
%% evaluated, but which may contain stage~\bbtwo\ variables wrapped in $\next$
%% blocks.  In the example above, 
%% \begin{lstlisting} 
%% 1`(next {`2`yhat`1`},7)`
%% \end{lstlisting}
%% is a partial value.
%% \emph{Residuals} ($\ressym$es) are \langTwo\ terms---stage \bbtwo\ terms whose
%% stage \bbone\ subexpressions have all been fully evaluated. In the example
%% above,
%% \begin{lstlisting} 
%% 2`let zhat = yhat*yhat*7 in zhat`
%% \end{lstlisting}
%% is a residual.

%% Note that partial values and residuals are both terms for which stage \bbone\
%% computation has completed; however, partial values are stage~\bbone\ terms,
%% while residuals are stage~\bbtwo\ terms.

%% The $\redonesym$ judgment, defined in \ref{fig:diaSemantics}, takes an stage
%% \bbone\ term%
%% \footnote{ The input to $\redonesym$ may be open on stage \bbtwo\ variables, but
%% the type system ensures that those must occur under a $\next$. Consequently
%% $\redonesym$ will never directly encounter a variable.}
%% %
%% to a {\em residual table} $\xi$ and a partial value $v$. The residual
%% table implements the explicit substitutions in our example---it maps fresh
%% stage \bbtwo\ variables (which may appear inside $\next$ blocks in $v$) to
%% residuals. For non-staging features of \lang, $\redonesym$ is essentially
%% standard call-by-value evaluation, and gathers the subterms' residual tables
%% into a single one.

%% At $\next~e$, in contrast, $\redonesym$ specializes into $e$ for stage~\bbone\ 
%% subexpressions to evaluate.  This is implemented by the $\redtwosym$ judgment,
%% which takes a stage \bbtwo\ term to a residual. 
%% For the most part (\ref{fig:diaSemanticsSpec}), specialization simply recurs into
%% all subexpressions; at $\prev$, however, it resumes $\redonesym$ evaluation,
%% which produces a residual table $\xi$ and (by canonical forms) an expression
%% $\next\{\hat y\}$. $\xi$ is then reified using $\reifysym$ into a series of let
%% bindings enclosing $\mathtt{\hat y}$.
%% Once specialization reduces $e$ to a residual $q$, the output of $\redonesym$ is a
%% fresh variable wrapped in a $\next$ block ($\next~\hat y$), along with a residual
%% table which maps that variable to the residual ($\hat y \mapsto q$).

%% Within specialization lies a subtle---if perhaps unintuitive---feature.  
%% Observe that specialization will traverse into both branches of a stage-\bbtwo\ {\tt if} or {\tt case} 
%% statement in its search for stage~\bbone\ code. 
%% Thus the evaluation of that stage~\bbone\ code will occur {\em regardless of the eventual value of the predicate},
%% and so a term like 
%% \begin{lstlisting} 
%% 1`next{
%%   `2`if true 
%%   then hold{`1`3+4`2`} 
%%   else prev{`1`spin() (* loops forever *)`2`}`1`
%% }`
%% \end{lstlisting}
%% will fail to evaluate at stage \bbone.
%% Although it may seem undesirable, this behavior is a deliberate feature.
%% Indeed it is critical to the quickselect example, 
%% wherein all three branches of the $n$-$k$ comparison are evaluated at stage~\bbone.
%% As always, it is the programmer's responsibility to ensure that her staging annotations 
%% do not cause a program to loop forever.  

%% The context ($\Gamma$) keeps track of stage \bbtwo\ variables in the input term. 
%% These both appear in the original program at stage \bbtwo\ and are inserted by the semantics.

%% As an optimization, we can include the special-case rule,
%% \begin{mathpar}
%% \inferdiaone [hat] {\red {\next~\hat y}{\cdot,\next~\hat y}}{\cdot}
%% \end{mathpar}
%% to avoid one-for-one variable bindings in the residual.

%% \subsubsection {Top-Level Evaluation}
%% \label{sec:partialeval}

%% % KAYVONF: good statement, but hold out for now
%% %The hope of partial evaluation is that $f_x$ is cheaper to execute than $f$, meaning that we can save work if we must %evaluate it many times.

%% These dynamics allow us to define a partial evaluator for \lang\ by identifying
%% static with stage \bbone\ and dynamic with stage \bbtwo.  Specifically, we
%% encode $f$ as a \lang\ expression with a function type of the form
%% $A\to\fut(B\to C)$.%
%% %\cprotect\footnote{We can rewrite \texttt{fexp} in this form, or simply apply
%% %the following higher-order function which makes the adjustment:
%% %\begin{lstlisting} 
%% %let adjust (f : $int * int -> $int) =
%% %  fn (p : int) => 
%% %    next{
%% %      fn (b : int) => 
%% %        prev{f (next {b}, p)}
%% %    }
%% %\end{lstlisting}}
%% %
%% Here $A$ is the static input, $B$ is the dynamic input, and $C$ is the output.

%% Once a stage \bbone\ argument $a:A$ is provided, we can evaluate the partially-applied
%% function:
%% $\cdot\vdash f~a \mathop{\redonesym} [\xi,v]$.
%% The result is an environment $\xi$ and a partial value $v$ of type $\fut(B\to
%% C)$, which by canonical forms must have the form $v = \next~\hat y$. 
%% Next, we reify this environment into a sequence of \verb|let|-bindings
%% enclosing $\hat y$, via $\reify\xi{\hat y}{f_a}$. 
%% Because reification preserves types, the resulting residual $f_a$ has type $B\to C$ in \langTwo, so we can apply it to some $b:B$
%% and compute the final result of the function, $f_a~b \mathop{\tworedsym} c$.

%% That this sequence of evaluations is in fact staged follows from our
%% characterizations of partial values and residuals, that $\redonesym$
%% outputs a partial value, and that $\reifysym$ outputs an expression in \langTwo.

%% For example, to specialize quickselect to a particular list, 
%% \begin{lstlisting}
%% qsStaged [5,2,7,4,1]
%% \end{lstlisting}
%% \TODO finish example
