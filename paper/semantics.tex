\section{Terminology and Overview}

\input{figures/splitting-overview}

We present an overview of the formal development along with our
terminology, as summarized in \figref{terminology}.

\figref{terminology}

Our starting point is a two-staged lambda calculus, whose syntax and
types are very similar to the multi-stage languages considered in the
literature on partial evaluation and meta programming.  Specifically,
we consider a two-stage, which we call \lang\, which is variant of
Davies`s multi-stage language.  Apart from the restriction to two
stages instead of multiple stages, there are no significant
differences between our syntax and the static semantics and those of
Davies'. We restrict our attention to two stages, because it
simplifies the (many) details of the splitting problem, without
altering the essence of the problem.  We expect that the techniques
presented here can be extended to multi-stage languages.

The dynamic semantics of \lang\ differs from Davies's approach and
similar approaches in meta programming literature, because it avoids
duplication of staged work. Duplication takes place in meta
programming when a second-stage computation is silently duplicated by
the semantics.  In addition to leading to increases in run time, a
duplicating semantics makes it harder to reason about the splitting
algorithm, whose development and exposition is our main goal.  Apart
from the non-duplication, the dynamic semantics of \lang\ is
essentially identical to  Davies'. 


We define the dynamics semantics of \lang\ not as an explicit
evaluation relation but as a relation that produces a term in an
unstaged, completely standard language, which we refer to as
\langmono\, because it is essentially lambda calculus extended with
product types. Given a \lang\ term, the dynamic semantics can be used
to reduce the term to a \langmono\ program, called {\em residual} by
using one application of stage-1 evaluation, one application of
reification, followed by one application of stage-2 evaluation.

\ur{Splitting...}



\section{\texorpdfstring{\lang}{Î»12} Statics and Dynamics}
\label{sec:semantics}

\input {figures/grammars}
\input {figures/statics}

\subsection{Statics}

In \lang, the $\next$ constructor includes a stage \bbtwo\ term in a
stage~\bbone\ term. To ensure that the staging features are only applied to
valid terms, we index our judgments not only by a type, but also a stage $w$.

The type validity judgment $\Delta \vdash A \istypewor$, defined in
\cref{fig:validTypes}, ensures that a type $A$ exists at stage $w$; for
example, any type $\fut A$ only exists at stage \bbone.  The typing judgment
$\typeswor e A$ says that $e$ has type $A$ at stage $w$, in the context
$\Gamma$, and is defined in \cref{fig:statics}.  As one would expect, the
typing judgment only produces valid types.
%(by induction on the derivation of the typing judgment).
% under the assumptions in $\Delta$. This context is only augmented by recursive types.

Except for the staging features $\next$, $\prev$, and $\pause$, the ordinary
language features (i.e., the introductory and eliminatory forms for product,
sum, and function types) preserve the stage of their subterms, and work at both
stages \bbone\ and \bbtwo. Thus, if we were to remove the staging features,
\lang\ would simply consist of two non-interacting copies of a standard lambda
calculus. Variables in the context are annotated with the stage at which they
were introduced and can only be used at the same stage.

Note that there is no way to eliminate a term of type $\fut A$ into a stage
\bbone\ term---the only elimination form is $\prev$, which results in a stage
\bbtwo\ term. This is why well-typed terms cannot have any information flow
from stage \bbtwo\ to stage \bbone, and what makes splitting possible.

\subsection{Dynamics}
\label{sec:stagedsemantics}

As is the case in essentially all staged language, the dynamic
semantics evaluates a term to a residual (a term in the target
language \langmono) in two stages. In the first stage, all stage-1
terms are evaluated by a relation, called {\em 1-evaluation}; in the
second stage all stage-2 terms are evaluated by a relation
$\redtwosym$, called {\em 2-evaluation}.  To eliminate duplication,
our semantics lifts out each stage-2 term nested inside of a stage-1
expressions, into a table which makes it possible for the stage-2
term---more precisely the corresponding residual obtained by reducing
all stage-1 subterms---to be referred to by use a dynamically
generated variable (a label).

\input{figures/dynamics}

Since stage-1 evaluation does not evaluate stage-2 terms and since
stage-2 terms may be nested inside stage-1 terms, 1-evaluation cannot
reduce \lang\ terms to values.  Instead 1-evaluation yields a {\em
  partial value}, which which is a stage~\bbone\ term that have been
evaluated except for its stage-2 subterms, which can only
be~\bbtwo\ variables wrapped in $\next$ blocks.  \figref{validPvalues}
defines partial values.

In order to avoid duplication of stage-2 computations, 1-evaluation
labels stage-2 computations by generating variable symbols for them as
needed and stores their residuals in a {\em residual table} keyed by
the variable.


The relation 1-evaluation, defined by $\redonesym$ judgment as shown
in \ref{fig:diaSemantics}, takes an stage \bbone\ term%
\footnote{ The input to $\redonesym$ may be open on stage \bbtwo\ variables, but
the type system ensures that those must occur under a $\next$. Consequently
$\redonesym$ will never directly encounter a variable.}
%
to a residual table $\xi$ and a partial value $v$.  For non-staging
features of \lang, $\redonesym$ is essentially standard call-by-value
evaluation but in addition gathers the subterms' residual tables into
a single table. \ur{The syntax of residual tables should be defined in
  the terminology figure} Residual table entries are created by the
evaluation of \next: 1-evaluation reduces a \next expression by
reducing the body of the \next with 2-evaluation to obtain a
residual $q$ and returns a residual table that maps a freshly
generated variable to the residual.  \ur{Variable should be fresh in
  the rule.}


The relation 2-evaluation, defined by $\redtwosym$ judgment, as shows
in \figref{diaSemantics}, takes a stage \bbtwo\ term and reduces it to
a residual.  Apart from the evaluation of \prev and \pause, the
evaluation is straightforward. To reduce a \prev term, 2-evaluation
reduces the body by 1-evaluation to obtain a residual table and a
partial value.  It then reifies the residual table and the partial
value into an residual term, by creating for each variable-residual
pair in the table a corresponding variable binding in the residual,
finally ending with the partial value.
\ur{There seems to be errors in the semantics in the handling of
  recursive types.  I don't see any reason to do any reductions here.
If you want to, the description above needs to be updated.}

...UMUT: UP TO HERE...




 In addition, 1-evaluation {\em reifies} the contents of
the residual table into a residual when changing from stage-2 to stage



%% Note that partial values and residuals are both terms for which stage \bbone\
%% computation has completed; however, partial values are stage~\bbone\ terms,
%% while residuals are stage~\bbtwo\ terms.



 The residual
table implements the explicit substitutions in our example---it maps fresh
stage \bbtwo\ variables (which may appear inside $\next$ blocks in $v$) to
residuals.


In order to avoid duplicating subterms, evaluation collects explicit
substitutions into a single {\em residual table} that is also the output of
evaluation.




 the auxiliary $\reifysym$ (reification). 
Along with these are three judgments identifying forms of values:
$\pvalsym$ (partial values), $\ressym$ (residuals), 
and the auxiliary $\fcon$ (residual table).
These judgments are related as follows:
\begin{itemize}
\item Evaluation sends a stage~\bbone\ term to a partial value.

\item Specialization sends a stage~\bbtwo\ term to a residual.

\item Reification sends a single residual and a residual table to another residual.  


\item Evaluation depends on specialization for $\next$ terms, which have
stage~\bbtwo\ subterms.
\item Specialization depends on evaluation for $\prev$ and $\pause$, which have
stage~\bbone\ subterms. The residual table produced by evaluation is also
reified here.
\end{itemize}











The relation 2-evaluation takes a stage-2 term and maps to a residual.

To generate the residual table, the dynamics semantics relies on a
{\em reification} relation, $\reifysym$, that maps a table to a
residual, essentially generating a target expression representing the
computations in the table.  

We can evaluate a \lang\ term as follows: we first apply 1-evaluation
to obtain a partial value and a residual table, we then construct a
2-term from the partial value and the residual table by using
reification, and then reduce this term to a residual via 2-evaluation.

Thus, the dynamic semantics for \lang\ evaluates all of a term's stage \bbone\
subexpressions before any of its stage~\bbtwo\ subexpressions. This results in
a stage \bbtwo\ term with no stage~\bbone\ content, 
which can be described as a term in a monostaged language called \langTwo. 
Then, at stage~\bbtwo, we complete
evaluating this term with a standard dynamic semantics, $\tworedsym$. (The
rules for this judgment are not shown, but they are standard.)





\crem{Can we cut \ref{fig:diaSemanticsSpec} from the paper? Perhaps just put a
few representative rules into \ref{fig:diaSemantics}?}

At $\next~e$, in contrast, $\redonesym$ specializes into $e$ for stage~\bbone\ 
subexpressions to evaluate.  This is implemented by the $\redtwosym$ judgment,
which takes a stage \bbtwo\ term to a residual. 
For the most part (\ref{fig:diaSemanticsSpec}), specialization simply recurs into
all subexpressions; at $\prev$, however, it resumes $\redonesym$ evaluation,
which produces a residual table $\xi$ and (by canonical forms) an expression
$\next\{\hat y\}$. $\xi$ is then reified using $\reifysym$ into a series of let
bindings enclosing $\mathtt{\hat y}$.
Once specialization reduces $e$ to a residual $q$, the output of $\redonesym$ is a
fresh variable wrapped in a $\next$ block ($\next~\hat y$), along with a residual
table which maps that variable to the residual ($\hat y \mapsto q$).

Within specialization lies a subtle---if perhaps unintuitive---feature.  
Observe that specialization will traverse into both branches of a stage-\bbtwo\ {\tt if} or {\tt case} 
statement in its search for stage~\bbone\ code. 
Thus the evaluation of that stage~\bbone\ code will occur {\em regardless of the eventual value of the predicate},
and so a term like 
\begin{lstlisting} 
1`next{
  `2`if true 
  then hold{`1`3+4`2`} 
  else prev{`1`spin() (* loops forever *)`2`}`1`
}`
\end{lstlisting}
will fail to evaluate at stage \bbone.
Although it may seem undesirable, this behavior is a deliberate feature.
Indeed it is critical to the quickselect example, 
wherein all three branches of the $n$-$k$ comparison are evaluated at stage~\bbone.
As always, it is the programmer's responsibility to ensure that her staging annotations 
do not cause a program to loop forever.  

The context ($\Gamma$) keeps track of stage \bbtwo\ variables in the input term. 
These both appear in the original program at stage \bbtwo\ and are inserted by the semantics.

As an optimization, we can include the special-case rule,
\begin{mathpar}
\inferdiaone [hat] {\red {\next~\hat y}{\cdot,\next~\hat y}}{\cdot}
\end{mathpar}
to avoid one-for-one variable bindings in the residual.

\subsubsection {Top-Level Evaluation}
\label{sec:partialeval}

% KAYVONF: good statement, but hold out for now
%The hope of partial evaluation is that $f_x$ is cheaper to execute than $f$, meaning that we can save work if we must %evaluate it many times.

These dynamics allow us to define a partial evaluator for \lang\ by identifying
static with stage \bbone\ and dynamic with stage \bbtwo.  Specifically, we
encode $f$ as a \lang\ expression with a function type of the form
$A\to\fut(B\to C)$.%
%\cprotect\footnote{We can rewrite \texttt{fexp} in this form, or simply apply
%the following higher-order function which makes the adjustment:
%\begin{lstlisting} 
%let adjust (f : $int * int -> $int) =
%  fn (p : int) => 
%    next{
%      fn (b : int) => 
%        prev{f (next {b}, p)}
%    }
%\end{lstlisting}}
%
Here $A$ is the static input, $B$ is the dynamic input, and $C$ is the output.

Once a stage \bbone\ argument $a:A$ is provided, we can evaluate the partially-applied
function:
$\cdot\vdash f~a \mathop{\redonesym} [\xi,v]$.
The result is an environment $\xi$ and a partial value $v$ of type $\fut(B\to
C)$, which by canonical forms must have the form $v = \next~\hat y$. 
Next, we reify this environment into a sequence of \verb|let|-bindings
enclosing $\hat y$, via $\reify\xi{\hat y}{f_a}$. 
Because reification preserves types, the resulting residual $f_a$ has type $B\to C$ in \langTwo, so we can apply it to some $b:B$
and compute the final result of the function, $f_a~b \mathop{\tworedsym} c$.

That this sequence of evaluations is in fact staged follows from our
characterizations of partial values and residuals, that $\redonesym$
outputs a partial value, and that $\reifysym$ outputs an expression in \langTwo.

For example, to specialize quickselect to a particular list, 
\begin{lstlisting}
qsStaged [5,2,7,4,1]
\end{lstlisting}
\TODO finish example

%% Umut: superseded by what is above.
%% Version Nov 7, 2014
%% \section{\texorpdfstring{\lang}{Î»12} Statics and Dynamics}
%% \label{sec:semantics}

%% \input {figures/grammars}
%% \input {figures/statics}

%% \lang\ is a typed two-stage lambda calculus with products, sums, and
%% isorecursive types.  Its statics are adapted from the linear temporal
%% logic given by \cite{davies96}, restricted to two stages and extended
%% with general sums and recursion.%
%% \footnote{This restriction to two stages is made primarily for simplicity of
%% presentation. All of these techniques could feasibly be extended to more
%% complicated stage systems.} 
%% Although \cite{davies96} was mostly interested in describing partial evaluation,
%% the system is equally apt as an input to splitting.

%% \subsection{Statics}

%% In \lang, the $\next$ constructor includes a stage \bbtwo\ term in a
%% stage~\bbone\ term. To ensure that the staging features are only applied to
%% valid terms, we index our judgments not only by a type, but also a stage $w$.

%% The type validity judgment $\Delta \vdash A \istypewor$, defined in
%% \cref{fig:validTypes}, ensures that a type $A$ exists at stage $w$; for
%% example, any type $\fut A$ only exists at stage \bbone.  The typing judgment
%% $\typeswor e A$ says that $e$ has type $A$ at stage $w$, in the context
%% $\Gamma$, and is defined in \cref{fig:statics}.  As one would expect, the
%% typing judgment only produces valid types.
%% %(by induction on the derivation of the typing judgment).
%% % under the assumptions in $\Delta$. This context is only augmented by recursive types.

%% Except for the staging features $\next$, $\prev$, and $\pause$, the ordinary
%% language features (i.e., the introductory and eliminatory forms for product,
%% sum, and function types) preserve the stage of their subterms, and work at both
%% stages \bbone\ and \bbtwo. Thus, if we were to remove the staging features,
%% \lang\ would simply consist of two non-interacting copies of a standard lambda
%% calculus. Variables in the context are annotated with the stage at which they
%% were introduced and can only be used at the same stage.

%% Note that there is no way to eliminate a term of type $\fut A$ into a stage
%% \bbone\ term---the only elimination form is $\prev$, which results in a stage
%% \bbtwo\ term. This is why well-typed terms cannot have any information flow
%% from stage \bbtwo\ to stage \bbone, and what makes splitting possible.

%% \subsection{Dynamics}
%% \label{sec:stagedsemantics}


%% Specifically, the dynamic semantics consist of two evaluation
%% relations $\redonesym$ and $\redtwosym$, called {\em 1-evaluation} and
%% {\em 2-evaluation}, that respectively evaluates stage-1 and stage-2
%% expressions. The relation 1-evaluation maps a stage-1 term to a
%% partial value and a residual table. A {\em partial value}, can be
%% thought as a value except that it might include references to stage-2
%% code stored in the {\em residual table}, which maps variables to
%% residuals.  The relation 2-evaluation takes a stage-2 term and maps to
%% a residual.  To generate the residual table, the dynamics semantics
%% relies on a {\em reification} relation, $\reifysym$, that maps a table
%% to a residual, essentially generating a target expression representing
%% the computations in the table.  We can evaluate a \lang\ term as
%% follows: we first apply 1-evaluation to obtain a partial value and a
%% residual table, we then construct a 2-term from the partial value and
%% the residual table by using reification, and then reduce this term to
%% a residual via 2-evaluation.


%% In the quickselect example, stage~\bbone\ terms are contained within
%% stage~\bbtwo\ terms---for example, in the recursive call to {\tt qsStaged}. In
%% this case, if we use an ordinary evaluation strategy reducing outermost redexes
%% first, we would no longer have staged evaluation, as stage~\bbtwo\ code would
%% be evaluated before stage~\bbone\ code. 

%% Thus, the dynamic semantics for \lang\ evaluates all of a term's stage \bbone\
%% subexpressions before any of its stage~\bbtwo\ subexpressions. This results in
%% a stage \bbtwo\ term with no stage~\bbone\ content, 
%% which can be described as a term in a monostaged language called \langTwo. 
%% Then, at stage~\bbtwo, we complete
%% evaluating this term with a standard dynamic semantics, $\tworedsym$. (The
%% rules for this judgment are not shown, but they are standard.)

%% \subsubsection{Stage~\bbone\ Evaluation}

%% To gain intuition about the challenges of implementing this staged dynamic
%% semantics, consider the program:
%% \begin{lstlisting}
%% 1`#2 (next {`2`f 20`1`}, 2+3)`
%% \end{lstlisting}
%% This is a stage~\bbone\ expression of type $\rmint~@~\bbone$; the pair inside it is a
%% stage~\bbone\ expression of type $(\fut\rmint)\times\rmint~@~\bbone$; and ${\tt f} :
%% \rmint \to \rmint~@~\bbtwo$ is an expensive stage~\bbtwo\ function which we would like
%% to avoid evaluating. A conventional call-by-value semantics would fully
%% evaluate both components of the pair before projecting the second component.
%% The problem is that, while \verb|next {f 20}| is not a value (in the sense that
%% additional stage-\bbtwo\ computation steps are necessary to produce a numeral),
%% evaluating the contents of \verb|next| cannot occur as part of stage~\bbone\
%% evaluation.

%% Intuitively, the solution is to designate \verb|next {f 20}| as a value
%% \emph{in stage \bbone}, even though it requires additional evaluation in stage
%% \bbtwo. Therefore, the pair evaluates to
%% \begin{lstlisting}
%% 1`(next {`2`f 20`1`}, 5)`
%% \end{lstlisting}
%% and the projection, in turn, immediately evaluates to \verb|5|.

%% Now consider a more complex example where stage~\bbone\ evaluation must
%% substitute such an incompletely-evaluated expression. The following
%% stage-\bbtwo\ term has type $\rmint$:
%% \begin{lstlisting} 
%% 2`prev{`
%%   1`let x = (next {`2`f 20`1`}, 3+4) in
%%   next{` 2`prev{`1`#1 x`2`} * prev{`1`#1 x`2`} * hold{`1`#2 x`2`}` 1`}`
%% 2`}`
%% \end{lstlisting}
%% As with the simpler example, this term does not fully reduce at stage~\bbone, 
%% because it depends on the value of \verb|f 20|, which is not reduced until stage \bbtwo.

%% Again treating \verb|(next {f 20}, 7)| as a value during stage~\bbone, we
%% substitute it for the three occurrences of \verb|x| in the body of the
%% \verb|let| expression, yielding
%% \begin{lstlisting} 
%% 2`prev{`
%%   1`next{` 2`prev{`1`#1 (next {`2`f 20`1`}, 7)`2`} 
%%       * prev{`1`#1 (next {`2`f 20`1`}, 7)`2`} 
%%       * hold{`1`#2 (next {`2`f 20`1`}, 7)`2`} `1`}`2`
%% }`
%% \end{lstlisting}
%% The outermost $\next$ here is not yet a value, because there remains stage~\bbone\ work to do in its body.
%% So to proceed, the semantics must first search the body of the $\next$ for stage~\bbone\ subterms and reduce them in place.
%% This search process is called {\em specialization}.
%% In our example this means reducing all three projections to give,
%% \begin{lstlisting} 
%% 2`prev{`1`
%%   next{`2` 
%%     prev{`1`next {`2`f 20`1`}`2`} * prev{`1`next {`2`f 20`1`}`2`} * 7 
%%   `1`}`2`
%% }`
%% \end{lstlisting}
%% Since all stage~\bbone\ subterms are reduced, the $\prev$s and $\next$s cancel to yield the final residual:
%% \begin{lstlisting} 
%% 2`(f 20) * (f 20) * 7`
%% \end{lstlisting}
%% But now stage \bbtwo\ must compute the expensive function call \verb|f 20| twice! 
%% There are some systems, typically called {\em metaprogramming}, 
%% where this duplication would be considered intended behavior.
%% For our applications, we find the duplication undesirable and avoid it.

%% To get this behavior, we do not treat \verb|next {f 20}| as a value to be substituted, 
%% but instead bind \verb|f 20| to a fresh stage~\bbtwo\ variable $\mathtt{\hat y}$
%% and then substitute that variable.

%% More precisely, when evaluating the \verb|next|, we construct an explicit
%% substitution $\mathtt{[\hat y\mapsto f~20]}$ binding its old contents to the
%% fresh variable $\mathtt{\hat y}$. This substitution is placed at the top of the
%% containing $\prev$ block:
%% \begin{lstlisting} 
%% 2`prev {
%% [yhat|->f 20]
%%   `1`let x = (next{`2`yhat`1`}, 7) in
%%   next{`2`prev{`1`#1 x`2`} * prev{`1`#1 x`2`} * hold{`1`#2 x`2`}`1`}`2`
%% }`
%% \end{lstlisting}
%% %As a convention, we render the new variable with a %stylish and fashionable
%% %hat.  
%% We proceed with stage~\bbone\ evaluation, which now duplicates the variable
%% $\mathtt{\hat y}$ rather than the expression \verb|f 20|.
%% \begin{lstlisting} 
%% 2`prev {
%% [yhat|->f 20]
%%   `1`next{`2`
%%     prev{`1`#1 (next {`2`yhat`1`}, 7)`2`} * 
%%     prev{`1`#1 (next {`2`yhat`1`}, 7)`2`} *
%%     hold{`1`#2 (next {`2`yhat`1`}, 7)`2`}
%%   `1`}`2`
%% }`
%% \end{lstlisting}
%% We then specialize to reduce the projections and cancel the $\next$s and $\prev$s, giving:
%% \begin{lstlisting} 
%% 2`prev {
%% [yhat|->f 20]
%%     `1`next{`2`yhat * yhat * 7`1`}
%% `2`}`
%% \end{lstlisting}
%% Once again, we lift the results of specialization into a substitution:
%% \begin{lstlisting} 
%% 2`prev {
%% [yhat|->f 20,
%%  zhat|->yhat * yhat * 7]
%%     `1`next{`2`zhat`1`}`2`
%% }`
%% \end{lstlisting}
%% Finally, when canceling the last $\next$ and $\prev$, the semantics {\em reifies} the contained substitutions into let statements, yielding
%% \begin{lstlisting} 
%% 2`let yhat = f 20 in
%% let zhat = yhat * yhat * 7 in zhat`
%% \end{lstlisting}

%% This concludes stage \bbone\ evaluation of the program---we have reduced all
%% stage \bbone\ redexes, resulting in a monostaged term in \langTwo. Stage \bbtwo\
%% evaluation, $\tworedsym$, then reduces this to a numeral.

%% \subsubsection{Evaluation and Specialization}
%% \label{ssec:dynamics}

%% \input{figures/dynamics}

%% The dynamics for \lang\ implements the stage \bbone\ evaluation algorithm
%% described above using three judgments: $\redonesym$ (evaluation), $\redtwosym$
%% (specialization), and the auxiliary $\reifysym$ (reification). 
%% Along with these are three judgments identifying forms of values:
%% $\pvalsym$ (partial values), $\ressym$ (residuals), 
%% and the auxiliary $\fcon$ (residual table).
%% These judgments are related as follows:
%% \begin{itemize}
%% \item Evaluation sends a stage~\bbone\ term to a partial value.
%% In order to avoid duplicating subterms, evaluation collects explicit
%% substitutions into a single {\em residual table} that is also the output of
%% evaluation.
%% \item Specialization sends a stage~\bbtwo\ term to a residual.
%% \item Reification sends a single residual and a residual table to another residual.  
%% \item Evaluation depends on specialization for $\next$ terms, which have
%% stage~\bbtwo\ subterms.
%% \item Specialization depends on evaluation for $\prev$ and $\pause$, which have
%% stage~\bbone\ subterms. The residual table produced by evaluation is also
%% reified here.
%% \end{itemize}

%% \emph{Partial values} are stage~\bbone\ terms that have been fully
%% evaluated, but which may contain stage~\bbtwo\ variables wrapped in $\next$
%% blocks.  In the example above, 
%% \begin{lstlisting} 
%% 1`(next {`2`yhat`1`},7)`
%% \end{lstlisting}
%% is a partial value.
%% \emph{Residuals} ($\ressym$es) are \langTwo\ terms---stage \bbtwo\ terms whose
%% stage \bbone\ subexpressions have all been fully evaluated. In the example
%% above,
%% \begin{lstlisting} 
%% 2`let zhat = yhat*yhat*7 in zhat`
%% \end{lstlisting}
%% is a residual.

%% Note that partial values and residuals are both terms for which stage \bbone\
%% computation has completed; however, partial values are stage~\bbone\ terms,
%% while residuals are stage~\bbtwo\ terms.

%% The $\redonesym$ judgment, defined in \ref{fig:diaSemantics}, takes an stage
%% \bbone\ term%
%% \footnote{ The input to $\redonesym$ may be open on stage \bbtwo\ variables, but
%% the type system ensures that those must occur under a $\next$. Consequently
%% $\redonesym$ will never directly encounter a variable.}
%% %
%% to a {\em residual table} $\xi$ and a partial value $v$. The residual
%% table implements the explicit substitutions in our example---it maps fresh
%% stage \bbtwo\ variables (which may appear inside $\next$ blocks in $v$) to
%% residuals. For non-staging features of \lang, $\redonesym$ is essentially
%% standard call-by-value evaluation, and gathers the subterms' residual tables
%% into a single one.

%% \crem{Can we cut \ref{fig:diaSemanticsSpec} from the paper? Perhaps just put a
%% few representative rules into \ref{fig:diaSemantics}?}

%% At $\next~e$, in contrast, $\redonesym$ specializes into $e$ for stage~\bbone\ 
%% subexpressions to evaluate.  This is implemented by the $\redtwosym$ judgment,
%% which takes a stage \bbtwo\ term to a residual. 
%% For the most part (\ref{fig:diaSemanticsSpec}), specialization simply recurs into
%% all subexpressions; at $\prev$, however, it resumes $\redonesym$ evaluation,
%% which produces a residual table $\xi$ and (by canonical forms) an expression
%% $\next\{\hat y\}$. $\xi$ is then reified using $\reifysym$ into a series of let
%% bindings enclosing $\mathtt{\hat y}$.
%% Once specialization reduces $e$ to a residual $q$, the output of $\redonesym$ is a
%% fresh variable wrapped in a $\next$ block ($\next~\hat y$), along with a residual
%% table which maps that variable to the residual ($\hat y \mapsto q$).

%% Within specialization lies a subtle---if perhaps unintuitive---feature.  
%% Observe that specialization will traverse into both branches of a stage-\bbtwo\ {\tt if} or {\tt case} 
%% statement in its search for stage~\bbone\ code. 
%% Thus the evaluation of that stage~\bbone\ code will occur {\em regardless of the eventual value of the predicate},
%% and so a term like 
%% \begin{lstlisting} 
%% 1`next{
%%   `2`if true 
%%   then hold{`1`3+4`2`} 
%%   else prev{`1`spin() (* loops forever *)`2`}`1`
%% }`
%% \end{lstlisting}
%% will fail to evaluate at stage \bbone.
%% Although it may seem undesirable, this behavior is a deliberate feature.
%% Indeed it is critical to the quickselect example, 
%% wherein all three branches of the $n$-$k$ comparison are evaluated at stage~\bbone.
%% As always, it is the programmer's responsibility to ensure that her staging annotations 
%% do not cause a program to loop forever.  

%% The context ($\Gamma$) keeps track of stage \bbtwo\ variables in the input term. 
%% These both appear in the original program at stage \bbtwo\ and are inserted by the semantics.

%% As an optimization, we can include the special-case rule,
%% \begin{mathpar}
%% \inferdiaone [hat] {\red {\next~\hat y}{\cdot,\next~\hat y}}{\cdot}
%% \end{mathpar}
%% to avoid one-for-one variable bindings in the residual.

%% \subsubsection {Top-Level Evaluation}
%% \label{sec:partialeval}

%% % KAYVONF: good statement, but hold out for now
%% %The hope of partial evaluation is that $f_x$ is cheaper to execute than $f$, meaning that we can save work if we must %evaluate it many times.

%% These dynamics allow us to define a partial evaluator for \lang\ by identifying
%% static with stage \bbone\ and dynamic with stage \bbtwo.  Specifically, we
%% encode $f$ as a \lang\ expression with a function type of the form
%% $A\to\fut(B\to C)$.%
%% %\cprotect\footnote{We can rewrite \texttt{fexp} in this form, or simply apply
%% %the following higher-order function which makes the adjustment:
%% %\begin{lstlisting} 
%% %let adjust (f : $int * int -> $int) =
%% %  fn (p : int) => 
%% %    next{
%% %      fn (b : int) => 
%% %        prev{f (next {b}, p)}
%% %    }
%% %\end{lstlisting}}
%% %
%% Here $A$ is the static input, $B$ is the dynamic input, and $C$ is the output.

%% Once a stage \bbone\ argument $a:A$ is provided, we can evaluate the partially-applied
%% function:
%% $\cdot\vdash f~a \mathop{\redonesym} [\xi,v]$.
%% The result is an environment $\xi$ and a partial value $v$ of type $\fut(B\to
%% C)$, which by canonical forms must have the form $v = \next~\hat y$. 
%% Next, we reify this environment into a sequence of \verb|let|-bindings
%% enclosing $\hat y$, via $\reify\xi{\hat y}{f_a}$. 
%% Because reification preserves types, the resulting residual $f_a$ has type $B\to C$ in \langTwo, so we can apply it to some $b:B$
%% and compute the final result of the function, $f_a~b \mathop{\tworedsym} c$.

%% That this sequence of evaluations is in fact staged follows from our
%% characterizations of partial values and residuals, that $\redonesym$
%% outputs a partial value, and that $\reifysym$ outputs an expression in \langTwo.

%% For example, to specialize quickselect to a particular list, 
%% \begin{lstlisting}
%% qsStaged [5,2,7,4,1]
%% \end{lstlisting}
%% \TODO finish example


%\begin{remark}
%For any $\colone{e}{A}$ containing no $\next$ subexpressions, $\redonesym$ will
%always compute an empty environment, and a partial value identical to the result
%of call-by-value evaluation of $e$.
%%derivationally equivalent to standard call-by-value evaluation.
%\end{remark}

%\subsection{Metatheory}
%
%Recall that residuals live in \langTwo; we will indicate typing judgments in
%\langTwo\ with $\vdash_\bbtwo$.
%
%%\begin{definition}
%%Context $\Gamma$ is well-formed ($\Gamma\wf$) if it
%%contains only stage-2 variables.
%%\end{definition}
%
%\begin{definition}
%An environment $\xi$ is well-formed ($\Gamma\vdash\xi\wf$) if either:
%\begin{enumerate}
%\item $\xi = \cdot$; or
%\item $\xi = \xi',x:B\mapsto e$ where
%$\Gamma\vdash\xi'\wf$ and
%$\typeslangTwo[\Gamma,\dom{\xi'}] e B$
%%$\Gamma,\dom{\xi'}\vdash \coltwo{e}{B}$ and
%%$\Gamma,\dom{\xi'}\vdash e \res$.
%\end{enumerate}
%\end{definition}
%
%\begin{theorem}
%If $\typeswor e A$ then $\Gamma\wf$ and $A\istypewor$.
%\end{theorem}
%
%\begin{theorem}
%If $\diaonesub$ and $\typesone e A$ then
%\begin{enumerate}
%\item $\Gamma\vdash\xi\wf$;
%\item $\Gamma,\dom\xi\vdash \colone{v}{A}$; and
%\item $\Gamma,\dom\xi\vdash v\pval$.
%\end{enumerate}
%\end{theorem}
%
%\begin{theorem}
%If $\diatwosub$ and $\typestwo e A$ then
%\begin{enumerate}
%\item $\typeslangTwo q A$; and
%\item $\Gamma\vdash_\bbtwo q\val$.
%\end{enumerate}
%\end{theorem}
%
%\begin{theorem}\label{thm:reify-type}
%If $\Gamma\vdash\xi\wf$ and
%$\Gamma,\dom\xi\vdash \colone{\next\ \hat y}{\fut A}$
%then 
%$\reify{\xi}{\hat y}{q}$ and
%$\typeslangTwo q A$.
%\end{theorem}

%\TODO
%Note somewhere how to run stage-one non-$\fut A$ terms. For example, a stage-one
%integer term is guaranteed not to depend on the table, although one might be
%produced. One may either discard the table, or evaluate everything in the table
%(and terminating with the partial value iff everything in the table terminates).


