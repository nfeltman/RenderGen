%!TEX root = paper.tex

\section{\texorpdfstring{\lang}{Î»12} Statics and Dynamics}
\label{sec:semantics}

\input{figures/grammars}

\input{figures/values}

We express two-stage programs as terms in \lang, a typed, modal lambda calculus
with products, sums, and isorecursive types. Its type system has three distinct
\emph{worlds} \bbonep, \bbonem, and \bbtwo, which respectively classify
\emph{ground first-stage} computations (\bbonep); 
first-stage computations containing a \emph{mix} of code from each stage
(\bbonem); 
and second-stage computations (\bbtwo).

\subsection{Statics}

\input{figures/statics}

\begin{abstrsyn}

The typing judgment $\typeswor e A$, defined in \ref{fig:statics}, means that
$e$ has type $A$ at world $w$, in the context $\Gamma$. (Variables in the
context are also annotated with the world at which they live.)

All three worlds contain fixpoints and unit, product, sum, function, and
recursive types defined in the usual fashion. For example, given two terms
$\typesone{e_1}A$ and $\typesone{e_2}B$ at world \bbonem, one can form the pair
$\typesone{\texttt{<}e_1,e_2\texttt{>}}{A\times B}$ also at world \bbonem. 

Differing worlds (and hence, differing stages of computation) interact by means
of the $\fut$ and $\curr$ type formers. $\fut A$ is a type in world \bbonem\
which classifies second-stage computations of type $A$. Given a term $e$ of type
$A$ at world \bbtwo, $\next{e}$ has type $\fut A$ at \bbonem. This essentially
encapsulates $e$ as a computation to be evaluated in the future---first-stage
computations can shuffle it around, but not use its result.  The only way to use
a $\fut A$ is to wrap it with $\prev$, yielding an $A$ at \bbtwo.

%This is why well-typed terms cannot have any information flow from stage
%\bbtwo\ to stage \bbone, and what makes splitting possible.

Although products and functions are restricted to types at the same world,
$\fut$ allows construction of ``mixed-stage'' products and functions.
For example, quickselect is a function at world \bbonem\ which takes a
$\curr{\rm list} \times \fut\rmint$ (a purely-first-stage list and a
second-stage integer) to a $\fut\rmint$ (a second-stage
computation of an integer).

$\curr A$ is a type in world \bbonem\ which classifies purely-first-stage
computations of type $A$. Given a world \bbonep\ term $e$ of type $A$,
$\pure{e}$ has type $\curr A$ at world \bbonem. ($e$ is guaranteed not to contain
second-stage computations because $\fut$ types are not available in world
\bbonep.)

An $e$ of type $\curr A$ at \bbonem\ can be unwrapped as an $A$ at \bbonep\
using the $\letp xe{e'}$ construct, which binds $\colpure xA$ in a \bbonem\ term
$e'$. This allows us to compute under $\curr$---for example, given a $\colmix
p{\curr(A\times B)}$, the term $\letp{x}{p}{\pure{\pio x}}$ computes its first
projection, of type $\curr A$.

Lastly, to case on a term $e$ of type $\curr(A+B)$ at world \bbonem, we need the
$\caseP{e}{x.e_1}{x.e_2}$ construct, whose branches are world \bbonem\ terms
open on $\curr{A}$ and $\curr{B}$ respectively.

The example code in this paper makes liberal use of $\rmint$s and various
functions on these, as well as a function $\pause$ which takes a $\curr\rmint$
to a $\fut\rmint$.%
\footnote{$\pause$ is definable in \lang\ given an inductive definition of
$\rmint$s. In practice, we provide both $\rmint$s and $\pause$ as primitives.
It is sensible to extend $\pause$ to all base types and to products and sums
thereof. This is related to the notion of {\em mobility} in \cite{murphy05} and
{\em stability} in \cite{krishnaswami13}.}

\crem{blend in the rest of the text in this section:}
%
\texttt{qsStaged} has a more precise type---it is a first-stage function which
takes a $\curr\mathrm{list}$ (an integer list now) and a $\fut\rmint$ (an
$\rmint$ \emph{in the future}), and returns a $\fut\rmint$.

Indeed, we case on the list as usual, and in the \texttt{Cons} branch,
\texttt{part}ition it. The \texttt{case} expression in \texttt{qSelect} depends
on \texttt{k}, whose type $\fut\rmint$ indicates that it is only available to
second-stage computations. Since \texttt{qsStaged} itself produces a
$\fut\rmint$, the remainder of the function is second-stage code.

The $\next$ wraps a second-stage expression of type $\rmint$ (the \texttt{case}
expression) as a first-stage expression of type $\fut\rmint$ (the result 
of \texttt{qsStaged}). Inside the \texttt{LT} and \texttt{GT} branches, the
$\prev$ unwraps first-stage $\fut\rmint$s (the results of the recursive calls
to \texttt{qsStaged}) as second-stage $\rmint$s. In the \texttt{EQ} branch,
$\pause$ promotes a first-stage $\rmint$ (the head of \texttt{l}) directly to a
second-stage $\rmint$.

\end{abstrsyn}

\subsection{Dynamics}
\label{sec:stagedsemantics}

\input{figures/dynamics-overview}

\input{figures/dynamics}

\begin{abstrsyn}

Although the type system of \lang\ (specifically, the opaque nature of $\fut$
types) ensures that we can perform all first-stage computations before any
second-stage ones, the fact that first- and second-stage computations are
interleaved in \lang\ terms means that realizing this notion of staged
evaluation requires some care.

We evaluate \lang\ terms in two stages. The first stage of evaluation has three
mutually recursive modes of operation, depending on the world of the term it is
evaluating. Specifically, first stage evaluation:
\begin{itemize}
\item fully reduces terms in \bbonep, as they are purely first-stage;
\item reduces terms in \bbonem, save for any world \bbtwo\ terms they may
contain (inside \texttt{next}s);
\item scans terms in \bbtwo\ for any world \bbonem\ subterms (inside \texttt{prev}s), 
and reduces those in place.
\end{itemize}
These tasks are accomplished by the $\redsym$, $\redonesym$, and $\redtwosym$
big-step judgments, respectively (defined in \ref{fig:diaSemantics}).

First-stage evaluation ultimately produces a monostaged term, called a \emph{residual}
(\ref{fig:values}), all of whose redexes are second-stage computations. The
second stage of evaluation is therefore just ordinary (unstaged) evaluation of
this residual, which we notate $\redsym$. (For simplicity, we treat residuals
and \bbonep\ terms as living in a single language equipped with a standard
evaluation $\redsym$, whose definition we omit for space reasons.)

Notice that our type system makes it possible to evaluate terms in a staged
fashion, but doing so still requires some machinery, since the stages are
syntactically interleaved within an individual term. For example,
\texttt{qsStaged} contains a first-stage recursive call inside a second-stage
\texttt{case}; thus, an ordinary outermost-first evaluation strategy would not
be properly staged.

\paragraph{First-stage evaluation at \bbonem\ ($\redonesym$).}
The difficulty of evaluating terms at \bbonem\ is that they contain both terms
at \bbonep\ (via $\curr$) and at \bbtwo\ (via $\fut$); the other evaluation
rules are ordinary call-by-value rules. When we encounter $\pure{e}$, we
evaluate $e$ as a monostaged term; \texttt{letg} and \texttt{caseg} simply reach
inside $\pure$ and evaluate like \texttt{let} and \texttt{case}.

$\next{e}$ is trickier, because we should not evaluate $e$ (at \bbtwo) yet.
There are two difficulties---$e$ may contain other code at \bbonem\ (which we
handle with $\redtwosym$, discussed below); and $\next{e}$ may be part of a
first-stage redex, which we \emph{do} need to reduce. For example, in
\begin{lstlisting} 
1`(fn x : $int => e') (next{`2`e`1`})`
\end{lstlisting}
we must reduce this first-stage function application, but cannot reduce $e$ yet.
We could reduce this to $[\next{e}/x]e'$, but this may potentially duplicate an
expensive computation $e$. Instead, we choose to hoist $e$ outside, binding it
to a temporary variable $\hat{y}$, and substituting that variable instead:
\begin{lstlisting} 
2`let val yhat = e in `1`[next{`2`yhat`1`}/x]e'`
\end{lstlisting}
then proceed by evaluating $[\next{\hat{y}}/x]e'$.

We achieve this by threading through a \emph{residual table} $\xi$, which
functions as a top-level sequence of \texttt{let}-bindings of residuals $e$ to
variables $\hat{y}$ in an evaluated \bbonem\ term. Thus, $\redonesym$ evaluation
yields a pair $\rtab \xi v$ of a residual table and a \emph{partial value} $v$
containing variables bound in that table. The grammar of residual tables and
partial values (terms fully evaluated at the first but not second stage) is
given in \ref{fig:values}.

%The input to $\redonesym$ may be open on stage \bbtwo\ variables, but the type
%system ensures that those must occur under a $\next$. Consequently $\redonesym$
%will never directly encounter a variable.

\paragraph{First-stage evaluation at \bbtwo\ ($\redtwosym$).}
Since terms at world \bbtwo\ represent second-stage computations, we should not
evaluate them yet. However, we do need to evaluate any first-stage computations
they contain (inside $\prev$), \emph{even if} those computations are guarded or
underneath binders.

For all constructs other than $\prev{e}$, $\redtwosym$ evaluation proceeds
recursively on all subterms, yielding a monostaged residual $q$. At $\prev{e}$,
we evaluate $e$ using $\redonesym$ to $\rtab \xi v$. Because $\colmix e{\fut A}$,
$v$ must have the canonical form $\next{\hat{y}}$ for some $\hat{y}$ bound in $\xi$. We \emph{reify}
$\xi$ into a sequence of second-stage \texttt{let} bindings around $\hat{y}$,
using the auxiliary judgment $\reify\xi q{q'}$ defined in
\ref{fig:diaSemantics}, then return the resulting residual $q'$.

\end{abstrsyn}

%Note that partial values and residuals are both terms for which stage \bbone\
%computation has completed; however, partial values are stage~\bbone\ terms,
%while residuals are stage~\bbtwo\ terms.

%As an optimization, we can include the special-case rule,
%\begin{mathpar}
%\inferdiaone [hat] {\red {\next~\hat y}{\cdot,\next~\hat y}}{\cdot}
%\end{mathpar}
%to avoid one-for-one variable bindings in the residual.

\subsection{Evaluating Staged Programs}

We consider a staged program to be a closed term $e$ at world \bbtwo. The first
stage of evaluation is $e\mathbin{\redtwosym} q$, which reduces all code at
\bbonem\ and \bbonep\ inside $e$. The second stage of evaluation is $q
\mathbin{\redsym} u$, or monostaged evaluation of the residual $q$, which yields
a value $u$.

A multistage function, such as \texttt{qsStaged} from \ref{sec:examplea}, has
type $A\to \fut (B \to C)$ at \bbonem.%
\footnote{We can rewrite \texttt{qsStaged} in this curried form, or apply a
higher-order currying function.}
To apply this function to arguments $\colmix a A$ and $\coltwo b B$, simply
evaluate the program:
\begin{lstlisting}
2`prev{`1`f a`2`} b`
\end{lstlisting}

We can also directly observe the reuse of first-stage computations across
multiple second-stage computations. To run many order statistics queries
$\texttt{k1},\dots,\texttt{km}$ on the same list, run the program:
\begin{lstlisting}
2`let val qs = prev{`1`qsStaged `3`grnd{`1`[7,4,2,5,9,...,3]`3`}`2`}`
2`in (qs k1,...,qs km)`
\end{lstlisting}
To see that the partial application of \texttt{qsStaged} is only evaluated once,
observe that after the first stage of evaluation, the residual has the form:
\begin{lstlisting}
2`let val yhat = ...`
2`    val qs = yhat`
2`in (qs k1,...,qs km)`
\end{lstlisting}
where $\hat{y}$ is bound to a function containing no first-stage redexes.
