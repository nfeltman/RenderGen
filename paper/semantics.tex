\section{The \lang\ Language}

\input {figures/grammars}
\input {figures/statics}

In this section, we describe \lang, a simple two-stage language
used as the basis for defining and analyzing stage splitting.
%The grammar and type system for \lang\ is given in
%\ref{fig:grammar,fig:statics}.
Every expression in \lang\ has a statically known {\em stage},
either \bbone~or \bbtwo, which defines when it is fully reduced.
%\footnote{Typing judgments and context variables are annotated with stages.}
%
% in addition to a type.
% Just as a type describes \emph{which} values an expression reduces to,
%the expression's stage tells us \emph{when} it will be fully reduced. 
% FIXME why?
%The reason for a two-stage design (as opposed to \cite{davies96}, which allows an infinite number of stages) will be discussed later.
Stage-\bbone\ and stage-\bbtwo\ types include products, sums, functions, and base types.
In addition to these types, stage-\bbone\ expressions may also be of type $\fut A$,
representing an enclosed stage-\bbtwo\ expression of type $A$.
(The type system of \lang\ is adopted directly from that of the modal language \lamCircle\,\cite{davies96}, but is restricted to two stages for simplicity.) $\fut A$ terms must be treated opaquely by stage-\bbone\ code
as they cannot be reduced (to values with type $A$) until stage \bbtwo. Like in \lamCircle\, there is no reciprocal modality.

Although there is a strict one-way dependence between the two stages at the type
level, stage-\bbone\ and stage-\bbtwo\ terms are defined mutually recursively:
the $\next$ construct embeds stage-\bbtwo\ expressions into stage \bbone,
whereas $\prev$ embeds stage-\bbone\ expressions into stage \bbtwo.
The $\next$ and $\prev$ constructs are the only expressions that interact with the stage of a term,
and we surround their arguments with braces in \lang\ syntax to clearly indicate stage boundaries within a program.

The grammar and type system for \lang\ is given in
\ref{fig:grammar,fig:statics}. (Typing judgments and context variables are annotated with stages.)
Only $\fut$ and its introductory and eliminatory forms $\next$ and $\prev$ affect the stage
of a term or type.
%We formulated our typing judgments in the style of \cite{davies96}, where the
%whole judgment is annotated with a stage.  
%The grammar and type system for \lang\ is given in
%\ref{fig:grammar,fig:statics}.
% We annotate typing judgments and context variables with stages;
%This is made manifest as rules which are entirely abstract over stage.
%In addition to determining the stage, $\next$ and $\prev$ are the introduction and elimination forms for $\fut$ types.
Specifically, given an argument with type $A$ at stage \bbtwo, $\next$ forms a $\fut A$ at stage \bbone.  
%That is, it forms the promise of a future $A$ out of a construction for an $A$ at the next timestep.
Stage \bbtwo\ expressions can obtain the original stage \bbtwo\ argument via the $\prev$ construct.  
Since $\prev$ operates at stage \bbtwo, this ensures no violation of causality\,\cite{cave14}.
The $\pause$ construct serves to wrap stage \bbone\ integers for use in stage \bbtwo.  
Although it is possible to implement $\pause$ from other \lang\ features, 
we provide it as a core primitive to simplify our examples. 

\subsection{Staged Evaluation}

As a simple example of expressing staged programs in \lang, consider the following fast exponentiation algorithm, which 
calculates $b^p$ in $\log p$ time:
\[
	\mathit{fexp}(b,p) = \left \{ \begin{array}{ll} 
		1 &  p = 0 \\ 
		\mathit{fexp}(b,p/2)^2 & p \text{ even} \\ 
		b \cdot \mathit{fexp}(b,p-1) & p \text{ odd} \end{array}
	\right .
\]

% Ignoring for the moment how to define recursive functions in \lang,
\noindent
The stage-\bbone\ term below defines the function {\tt fexp} that implements the fast exponentiation algorithm:%
%\footnote{We render $\fut$ as {\tt \$} in code examples.}

\begin{lstlisting} 
let fexp (b : $int, e : int) : $int =
	if e == 0 then
		next{1}
	else if (e mod 2) == 0 then
		next{let x = prev{fexp(b,p/2)} in x*x}
	else
		next{prev{b} * prev{fexp(b,p-1)}}		
\end{lstlisting}

Although the code for {\tt fexp} looks very much like the unstaged mathematical
definition above, it is in fact a staged program: the {\tt if} predicates and exponent
decomposition are all stage-\bbone\ terms, since they occur within $\prev$ blocks.
%\needsfix{Essentially, the type system is sufficient to prove the observation that all of
%the decomposition of the exponent can be done at the stage \bbone\ without
%requiring disruption of the elegant functional structure of the code.}
We note that our work does not consider the problem of {\em binding time analysis}---transforming an unstaged program into a staged \lang\ program by inserting appropriate $\next$, $\prev$, and $\pause$ constructs. We assume that binding time analysis is performed manually by a programmer (as done above) or via automatic analysis of unstaged code to arrive at a valid \lang\ program used as input for subsequent splitting.

A key attribute of the {\tt fexp} code example is the nesting of stage-\bbone\ and stage-\bbtwo\ expressions. Ordinary term evaluation eliminates outermost redexes first, 
however in the case that stage \bbone\ expressions are contained inside
stage \bbtwo\ ones (such as in the example above), this strategy conflicts with the precept of staged execution: that all stage \bbone\ code be evaluated before the evaluation of stage \bbtwo\ code. Therefore, a suitably staged dynamic semantics for \lang\ must evaluate
\emph{all} the stage \bbone\ subexpressions of a term before its stage
\bbtwo\ subexpressions.

To understand how this behavior can be achieved, consider evaluation of the stage-\bbone\ term below. (The term contains nested $\next$ and $\prev$ blocks.):
\begin{lstlisting} 
let x = (next {1+2}, 3+4) in
  next{ prev{#1 x} * prev{#1 x} * prev{hold(#2 x)} }
\end{lstlisting}
One option is to duplicate the contents of the first $\next$ expression, to produce
\begin{lstlisting}
(1+2) * (1+2) * 7
\end{lstlisting}

Here we are essentially treating $\next\{e\}$ as a stage-\bbone\ value, so long
as all the $\prev$ subterms of $e$ are reduced. This is the approach taken by
\cite{davies96}.

We take a different approach in our dynamic semantics, which is to let-bind the
contents of the first $\next$ expression to some variable (here, $x1$) and
duplicate that variable,
\begin{lstlisting} 
let x1 = 1+2 in
  x1 * x1 * 7
\end{lstlisting}

% We think that this interpretation makes more sense from the point of view of cost, 
% since the contents of a $\next$ always appear once in the residual, regardless of how many times the result is used.  
% This is \emph{nearly} equivalent to the first expression, because they have different termination behavior 
% when a non-terminating stage-\bbtwo~expression is declared but never used.

To achieve this behavior, we must start by evaluating the binding for $x$.  We can't evaluate inside the
$\next$ statement, but must still substitute some result into the body of the
\texttt{let}. We replace the contents of $\next$ with a variable and make an
explicit substitution, which then floats up to the top of the containing
$\prev$:
\begin{lstlisting} 
[x1|->1+2]
let x = (next{x1}, 7) in
next{ prev{#1 x} * prev{#1 x} * prev{hold (#2 x)} }
\end{lstlisting}
We're now free to perform the stage-\bbone~substitution for $x$.  
\begin{lstlisting} 
[x1|->1+2]
next{
	prev{#1 (next{x1}, 7)} *
	prev{#1 (next{x1}, 7)} *
	prev{hold (#2 (next{x1}, 7))}
}
\end{lstlisting}
To evaluate the remaining $\next$, we must first partially evaluate the body by finding all of the contained stage-\bbone~terms and reducing them:
\begin{lstlisting} 
[x1|->1+2]
	next{ x1 * x1 * 7 }
\end{lstlisting}
The final step in evaluating the outer $\prev$ is reifying the contained substitutions into let statements, yielding
\begin{lstlisting} 
let x1 = 1+2 in
  x1 * x1 * 7
\end{lstlisting}

Once again, the point here is that we did not duplicate the $1+2$ in our residual.  
Instead we lifted it out into a substitution, leaving a hatted variable [\TODO add hats above] in its place,
and we reified the substitution into a let-binding at the enclosing $\prev$.

\subsection{Dynamics}

\input {figures/dynamics}

%{{{ stuff nico commented out
%Previous work (\cite{davies96}) focuses on the correspondence between the type system and existing temporal logics, whereas we care more about operational behavior and cost.  In this section, we'll consider a few proposals for our language before settling on one we like.  All of the proposals are call-by-value, differing primarily in how they handle values of $\fut$ type.

%\subsection{The Erasure Semantics}
%
%We first consider the {\em erasure semantics}, so called because it corresponds to what one would get by interpreting \lamStaged as a single-stage language, ignoring all of the $\next$ and $\prev$ terms.  This gives us two judgments, $\erasone$ and $\erastwo$, corresponding to {\em multistage evaluation} at \bbone and at \bbtwo.  We call these judgments  ``multistage'' because they cause work to happen at both stages.
%
%Both judgments behave normally at non-staged features.  We cover their behavior at staged features below:
%
%\begin{mathpar}
%\infer {\next~e \erasone \next~v} {e \erastwo v} \and
%\infer {\prev~e \erastwo \next~v} {e \erasone v} \and
%\infer {\pause~e \erasone \next~i} {e \erasone i}
%\end{mathpar}
%
%Essentially, we immediately evaluate under the $\next$, yielding a value for $\fut$ types. The $\prev$ terms remove this wrapper.  As expected, $\pause$ also gives us a way to inject into the wrapper at integers.
%
%The erasure semantics has some undesirable properties.  By intention, it interleaves the execution of stage-\bbone~and stage-\bbtwo~code, so the evaluation can't really be said to be staged (i.e. stage-\bbone~work is done before stage-\bbtwo~work).  Moreover, the erasure semantics cannot be equivalent to any semantics which does have this property!  To see why, consider the following code, which types to int at \bbtwo:
%
%\begin{lstlisting} 
%if 5*4*3*2 > 111 then
%	prev{ hold (2+4) }
%else
%	prev{ loopForever () (* does not terminate *) }
%\end{lstlisting}
%
%Under the erasure semantics (using $\erastwo$), this code takes the top branch and evaluates to 6.  But in order know that the {\tt loopForever} function need not be called, the predicate had to be evaluated prior.  But the predicate is stage-\bbtwo, whereas {\tt loopForever} is stage-\bbone.  To borrow terminology from \cite{cave14}, this violates causality.  In order to avoid this problem, a valid semantics must {\em speculate} down the branches of any stage-\bbtwo~if or case statement (or similarly into the body of a stage-\bbtwo function) to find and evaluate all of the stage-\bbone~code.  Both of the other semantics we will consider have this property.
%
%The benefit of the erasure semantics is that it's very natural, and has a familiar cost model.  It also {\em obviously} produces the ``correct'' answer, so we can use the erasure semantics as a reference to prove the reasonableness of any other semantics.
%
%\subsection{Meta Semantics}
%
%A different semantics was provided in \cite{davies96}.  We briefly review a two-stage version of that semantics here.
%
%In the erasure semantics, $\next v$ is a value only if $v$ is fully reduced.  But in the meta semantics, $\next e$ is a value only if $e$ has no $\prev$ terms; $v$ is allowed to have unreduced stage-2 computation. 
%
%...
%
%The Davies semantics is comprised of two mutually recursive judgments: $\daviesz$ and $\davieso$.  For some $\colone e A$, the $\daviesz$ judgment evaluates only the first-stage parts of $e$, leaving unevaluated second-stage code within $\next$s.  (... This essentially gives us partial evaluation, and we're left to just evaluate the residual normally to get multi-stage evaluation...) 
%
%The benefit of the meta semantics is that it gives us a very explicit notion of partial evaluation.  This also, by construction, means that the meta semantics does all of the first stage-work {\em before} the second stage work begins. 
%
%The $\next$-by-name behavior of the meta semantics of course means that it happily duplicates second-stage code, which could increase the cost.  This makes reasoning about second-stage cost rather difficult.
%
%\begin{lstlisting} 
%let x = next {4+5} in
%next{prev{x} * prev{x}}
%\end{lstlisting}
%
%\subsection{Our Semantics}
%
%We desire a semantics that meets the following goals:
%
%\begin{enumerate}
%\item Modulo termination, it should be equivalent to the erasure semantics.
%\item All of the first stage work should be completed before second stage work.  Ideally, it should just have a notion of partial evaluation, like the meta semantics.
%\item Should be $\next$-by-value, rather than $\next$-by-name, like the erasure semantics.  
%\end{enumerate}
%
%We meet all of these goals.
%}}}
%{{{ stuff carlo commented out
%Abstractly, we can think of our evaluation as proceeding in the standard way for
%stage-1 code. When the evaluator encounters a $\next \{e\}$ expression, it
%places $e$ off to the side in a context and replaces the whole expression with a
%reference to the context entry.  These references are then passed around as
%stage-1 values for $\fut$ types.  But what if $e$ contains $\prev$ expressions?
%To ensure that all stage-1 code is evaluated before any stage-2 code, we must
%evaluate all of the 1-code contained in $e$ before inserting it into the table.
%This entails searching $e$ for all contained $\prev$s and evaluating them in
%place.  

%The evaluation judgment operates on stage-1 code, whereas the
%speculation operates on stage-2 code.  Since $\next$ and $\prev$ are the
%crossover points between 1-code and 2-code, they are correspondingly the only
%places where the evaluation and speculation judgments depend on the other. 

%The evaluation judgment is very similar to standard call-by-value evaluation.
%The input to evaluation is a stage-1 expression (usually
%$e$), as well as two administrative contexts ($\Gamma$ and $\Xi$), covered
%later.  Evaluation has two outputs: the {\em future context} (usually $\xi$) and
%the {\em partial value} (usually $v$).  We cover the latter first.  The partial
%value is essentially the result of the first-stage portion of $e$, and must be a
%\bbone-value of the same type as $e$.  As usual, this means that $v$ must be
%composed only of base primitives, tuples, injections, and lambdas (corresponding
%to base types, products, sums, and functions).  Analogously, the value
%corresponding to $\fut$ is a construct called a {\em hatted variable} (written
%$\hat y$), which signifies a reference to some stage-2 computation.  The mapping
%between these hatted variables and stage-two expressions is
%}}}

% TODO move these to macros.tex once they're finalized
\newcommand{\pval}{\ensuremath{\mathsf{pval}}}
\newcommand{\res}{\ensuremath{\mathsf{res}}}
\renewcommand{\val}{\ensuremath{\mathsf{val}}}

The algorithm described above creates three different kinds of expressions which
cannot be evaluated further at a particular stage:
\begin{itemize}
\item Partial values ($\pval$s) are stage \bbone{} terms whose stage \bbone{}
subexpressions have all been fully evaluated. In the example above,
\verb|next {x1 * x1 * 7}|.
\item Residuals ($\res$es) are stage \bbtwo{} terms whose stage \bbone{}
subexpressions have all been fully evaluated. In the example above,
\verb|1+2|.
\item Values ($\val$s) are stage \bbtwo{} terms which are fully evaluated; these
are the results of a computation after both stages have been completed. In the
example above, the term evaluates to \verb|63|.
\end{itemize}
The $\redonesym$ judgment takes an open stage \bbone{} term to a pair of an
environment $\xi$ mapping newly-created variables to stage \bbtwo{} residuals,
and a partial value $v$ which may refer to those variables. This judgment
necessarily traverse stage \bbtwo{} subexpressions in order to find their stage
\bbone{} subexpressions; we call this process \emph{speculation}. Speculation is
implemented by the $\redtwosym$ judgment, which takes a stage \bbtwo{} term to a
residual.

\TODO finish explaining how the nested evaluation actually works.
explain reification, hatted variables, and contexts.

A function $f$ which accepts inputs at both stages \bbone{} and \bbtwo{} can be
given a type of the form $A\to\fut(B\to C)$.%
\footnote{We can rewrite \texttt{fexp} in this form, or simply apply the following
higher-order function which makes the adjustment:

\TODO write the function here}
Given its stage \bbone{} argument $a:A$, we can evaluate the partially-applied
function:
$\cdot;\cdot\vdash f~a \mathop{\redonesym} [\xi,v]$.
The result is an environment $\xi$ and a partial value $v$ of type $\fut(B\to
C)$. Next, we reify this environment into a sequence of \verb|let|-bindings
enclosing $v$, via $\reify\xi{v}{f_a}$. A canonical forms theorem on $v$
ensures that the resulting $f_a$ has type $B\to C$ in \langTwo.
Finally, given a stage \bbtwo{} argument $b:B$, we can stage-\bbtwo{} evaluate
the ultimate result of the function, $f_a~b \mathop{\tworedsym} c$.

\TODO make sure this is true (haven't written the canonical forms theorems yet)

That this sequence of evaluations is in fact staged follows from our
characterizations of partial values, residuals, and values, that $\redonesym$
outputs a partial value, and that $\reifysym$ outputs an expression in \langTwo.

\begin{remark}
For any $\colone{e}{A}$ containing no $\next$ subexpressions, $\redonesym$ will
always compute an empty environment, and a partial value identical to the result
of call-by-value evaluation of $e$.
%derivationally equivalent to standard call-by-value evaluation.
\end{remark}

\TODO 
If we change the highlighted rules to something slightly different, then we get
precisely the semantics from \cite{davies96}. This essentially bypasses the
environment bookkeeping in $\redonesym$, by inlining residuals instead of
hoisting them in \verb|let|-bindings.

\subsection{Metatheory}

\noindent\TODO terminology for the contexts?

% local macros; put them in macros.tex once they are more finalized
\newcommand{\wf}{\ \mathsf{wf}}
\newcommand{\valoo}{\ \bbone\textsf{-}\mathsf{val} @ \bbone}
\newcommand{\valot}{\ \bbone\textsf{-}\mathsf{val} @ \bbtwo}
\newcommand{\valtt}{\ \bbtwo\textsf{-}\mathsf{val} @ \bbtwo}

\begin{definition}
Contexts $\Xi$ and $\Gamma$ are well-formed ($\Xi\wf$, $\Gamma\wf$) if they
contain only stage-2 variables.
\end{definition}

\begin{definition}
An environment $\xi$ is well-formed ($\xi\wf$) if either:
\begin{enumerate}
\item $\xi = \cdot$; or
\item $\xi = \xi',x\mapsto e$ where
$\Xi,\dom{\xi'};\Gamma\vdash e : B @ \bbtwo$ and
$\Xi,\dom{\xi'};\Gamma\vdash e \valot$.
\end{enumerate}
\end{definition}

\begin{theorem}
If $\Xi;\typesone e A$ then $\Xi\wf$, $\Gamma\wf$, and $A\istypeone$.
\end{theorem}

\begin{theorem}
If $\diaonesub$ then:
\begin{enumerate}
\item $\typesone e A$ for some 1-type $A$;
\item $\xi\wf$;
\item $\Xi,\dom\xi;\cdot\vdash v : A @ \bbone$; and
\item $\Xi,\dom\xi;\cdot\vdash v\valoo$.
\end{enumerate}
\end{theorem}

\begin{theorem}
If $\diatwosub$ then:
\begin{enumerate}
\item $\typestwo e A$ for some 2-type $A$;
\item $\Xi;\Gamma\vdash q : A @ \bbtwo$; and
\item $\Xi;\Gamma\vdash q\valtt$.
\end{enumerate}
\end{theorem}


