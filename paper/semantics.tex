
\section{\texorpdfstring{\lang}{Î»12} Statics and Dynamics}
\label{sec:semantics}

\input {figures/grammars}
\input {figures/statics}

\lang\ is a typed two-stage lambda calculus with products, sums, and isorecursive types.
Its statics are adapted from the linear temporal logic given by \cite{davies96},
restricted to two stages and extended with general sums and recursion.%
\footnote{This restriction to two stages is made primarily for simplicity of
presentation. All of these techniques could feasibly be extended to more
complicated stage systems.} 
Although \cite{davies96} was mostly interested in describing partial evaluation,
the system is equally apt as an input to splitting.

\subsection{Statics}

In \lang, the $\next$ constructor includes a stage \bbtwo\ term in a
stage~\bbone\ term. To ensure that the staging features are only applied to
valid terms, we index our judgments not only by a type, but also a stage $w$.

The type validity judgment $\Delta \vdash A \istypewor$, defined in
\cref{fig:validTypes}, ensures that a type $A$ exists at stage $w$; for
example, any type $\fut A$ only exists at stage \bbone.  The typing judgment
$\typeswor e A$ says that $e$ has type $A$ at stage $w$, in the context
$\Gamma$, and is defined in \cref{fig:statics}.  As one would expect, the
typing judgment only produces valid types.
%(by induction on the derivation of the typing judgment).
% under the assumptions in $\Delta$. This context is only augmented by recursive types.

Except for the staging features $\next$, $\prev$, and $\pause$, the ordinary
language features (i.e., the introductory and eliminatory forms for product,
sum, and function types) preserve the stage of their subterms, and work at both
stages \bbone\ and \bbtwo. Thus, if we were to remove the staging features,
\lang\ would simply consist of two non-interacting copies of a standard lambda
calculus. Variables in the context are annotated with the stage at which they
were introduced and can only be used at the same stage.

Note that there is no way to eliminate a term of type $\fut A$ into a stage
\bbone\ term---the only elimination form is $\prev$, which results in a stage
\bbtwo\ term. This is why well-typed terms cannot have any information flow
from stage \bbtwo\ to stage \bbone, and what makes splitting possible.

\subsection{Dynamics}
\label{sec:stagedsemantics}

In the quickselect example, stage~\bbone\ terms are contained within
stage~\bbtwo\ terms---for example, in the recursive call to {\tt qsStaged}. In
this case, if we use an ordinary evaluation strategy reducing outermost redexes
first, we would no longer have staged evaluation, as stage~\bbtwo\ code would
be evaluated before stage~\bbone\ code. 

Thus, the dynamic semantics for \lang\ evaluates all of a term's stage \bbone\
subexpressions before any of its stage~\bbtwo\ subexpressions. This results in
a stage \bbtwo\ term with no stage~\bbone\ content, 
which can be described as a term in a monostaged language called \langTwo. 
Then, at stage~\bbtwo, we complete
evaluating this term with a standard dynamic semantics, $\tworedsym$. (The
rules for this judgment are not shown, but they are standard.)

\subsubsection{Stage~\bbone\ Evaluation}

To gain intuition about the challenges of implementing this staged dynamic
semantics, consider the program:
\begin{lstlisting}
1`#2 (next {`2`f 20`1`}, 2+3)`
\end{lstlisting}
This is a stage~\bbone\ expression of type $\rmint~@~\bbone$; the pair inside it is a
stage~\bbone\ expression of type $(\fut\rmint)\times\rmint~@~\bbone$; and ${\tt f} :
\rmint \to \rmint~@~\bbtwo$ is an expensive stage~\bbtwo\ function which we would like
to avoid evaluating. A conventional call-by-value semantics would fully
evaluate both components of the pair before projecting the second component.
The problem is that, while \verb|next {f 20}| is not a value (in the sense that
additional stage-\bbtwo\ computation steps are necessary to produce a numeral),
evaluating the contents of \verb|next| cannot occur as part of stage~\bbone\
evaluation.

Intuitively, the solution is to designate \verb|next {f 20}| as a value
\emph{in stage \bbone}, even though it requires additional evaluation in stage
\bbtwo. Therefore, the pair evaluates to
\begin{lstlisting}
1`(next {`2`f 20`1`}, 5)`
\end{lstlisting}
and the projection, in turn, immediately evaluates to \verb|5|.

Now consider a more complex example where stage~\bbone\ evaluation must
substitute such an incompletely-evaluated expression. The following
stage-\bbtwo\ term has type $\rmint$:
\begin{lstlisting} 
2`prev{`
  1`let x = (next {`2`f 20`1`}, 3+4) in
  next{` 2`prev{`1`#1 x`2`} * prev{`1`#1 x`2`} * hold{`1`#2 x`2`}` 1`}`
2`}`
\end{lstlisting}
As with the simpler example, this term does not fully reduce at stage~\bbone, 
because it depends on the value of \verb|f 20|, which is not reduced until stage \bbtwo.

Again treating \verb|(next {f 20}, 7)| as a value during stage~\bbone, we
substitute it for the three occurrences of \verb|x| in the body of the
\verb|let| expression, yielding
\begin{lstlisting} 
2`prev{`
  1`next{` 2`prev{`1`#1 (next {`2`f 20`1`}, 7)`2`} 
      * prev{`1`#1 (next {`2`f 20`1`}, 7)`2`} 
      * hold{`1`#2 (next {`2`f 20`1`}, 7)`2`} `1`}`2`
}`
\end{lstlisting}
The outermost $\next$ here is not yet a value, because there remains stage~\bbone\ work to do in its body.
So to proceed, the semantics must first search the body of the $\next$ for stage~\bbone\ subterms and reduce them in place.
This search process is called {\em speculation}.
In our example this means reducing all three projections to give,
\begin{lstlisting} 
2`prev{`1`
  next{`2` 
    prev{`1`next {`2`f 20`1`}`2`} * prev{`1`next {`2`f 20`1`}`2`} * 7 
  `1`}`2`
}`
\end{lstlisting}
Since all stage~\bbone\ subterms are reduced, the $\prev$s and $\next$s cancel to yield the final residual:
\begin{lstlisting} 
2`(f 20) * (f 20) * 7`
\end{lstlisting}
But now stage \bbtwo\ must compute the expensive function call \verb|f 20| twice! 
There are some systems, typically called {\em metaprogramming}, 
where this duplication would be considered intended behavior.
For our applications, we find the duplication undesirable and avoid it.

To get this behavior, we do not treat \verb|next {f 20}| as a value to be substituted, 
but instead bind \verb|f 20| to a fresh stage~\bbtwo\ variable $\mathtt{\hat y}$
and then substitute that variable.

More precisely, when evaluating the \verb|next|, we construct an explicit
substitution $\mathtt{[\hat y\mapsto f~20]}$ binding its old contents to the
fresh variable $\mathtt{\hat y}$. This substitution is placed at the top of the
containing $\prev$ block:
\begin{lstlisting} 
2`prev {
[yhat|->f 20]
  `1`let x = (next{`2`yhat`1`}, 7) in
  next{`2`prev{`1`#1 x`2`} * prev{`1`#1 x`2`} * hold{`1`#2 x`2`}`1`}
}`
\end{lstlisting}
%As a convention, we render the new variable with a %stylish and fashionable
%hat.  
We proceed with stage~\bbone\ evaluation, which now duplicates the variable
$\mathtt{\hat y}$ rather than the expression \verb|f 20|.
\begin{lstlisting} 
2`prev {
[yhat|->f 20]
  `1`next{`2`
    prev{`1`#1 (next {`2`yhat`1`}, 7)`2`} * 
    prev{`1`#1 (next {`2`yhat`1`}, 7)`2`} *
    hold{`1`#2 (next {`2`yhat`1`}, 7)`2`}
  `1`}`2`
}`
\end{lstlisting}
We then speculate to reduce the projections and cancel the $\next$s and $\prev$s, giving:
\begin{lstlisting} 
2`prev {
[yhat|->f 20]
    `1`next{`2`yhat * yhat * 7`1`}
`2`}`
\end{lstlisting}
Once again, we lift the results of speculation into a substitution:
\begin{lstlisting} 
2`prev {
[yhat|->f 20]
[zhat|->yhat * yhat * 7]
    `1`next{`2`zhat`1`}`2`
}`
\end{lstlisting}
Finally, when canceling the last $\next$ and $\prev$, the semantics {\em reifies} the contained substitutions into let statements, yielding
\begin{lstlisting} 
2`let yhat = f 20 in
let zhat = yhat * yhat * 7 in zhat`
\end{lstlisting}

This concludes stage \bbone\ evaluation of the program---we have reduced all
stage \bbone\ redexes, resulting in a monostaged term in \langTwo. Stage \bbtwo\
evaluation, $\tworedsym$, then reduces this to a numeral.

\subsubsection{Evaluation and Speculation}
\label{ssec:dynamics}

\input{figures/dynamics}

The dynamics for \lang\ implements the stage \bbone\ evaluation algorithm
described above using three judgments: $\redonesym$ (evaluation), $\redtwosym$
(speculation), and the auxiliary $\reifysym$ (reification). 
Along with these are three judgments identifying forms of values:
$\pvalsym$ (partial values), $\ressym$ (residuals), 
and the auxiliary $\fcon$ (future context).
These judgments are related as follows:
\begin{itemize}
\item Evaluation sends a stage~\bbone\ term to a partial value.
In order to avoid duplicating subterms, evaluation collects explicit
substitutions into a single {\em future context} that is also the output of
evaluation.
\item Speculation sends a stage~\bbtwo\ term to a residual.
\item Reification sends a residual and a future context to another residual.  
\item Evaluation depends on speculation for $\next$ terms, which have
stage~\bbtwo\ subterms.
\item Speculation depends on evaluation for $\prev$ and $\pause$, which have
stage~\bbone\ subterms. The future context produced by evaluation is also
reified here.
\end{itemize}

\emph{Partial values} are stage~\bbone\ terms that have been fully
evaluated, but which may contain stage~\bbtwo\ variables wrapped in $\next$
blocks.  In the example above, 
\begin{lstlisting} 
1`(next {`2`yhat`1`},7)`
\end{lstlisting}
is a partial value.
\emph{Residuals} ($\ressym$es) are \langTwo\ terms---stage \bbtwo\ terms whose
stage \bbone\ subexpressions have all been fully evaluated. In the example
above,
\begin{lstlisting} 
2`let zhat = yhat*yhat*7 in zhat`
\end{lstlisting}
is a residual.

Note that partial values and residuals are both terms for which stage \bbone\
computation has completed; however, partial values are stage~\bbone\ terms,
while residuals are stage~\bbtwo\ terms.

The $\redonesym$ judgment, defined in \ref{fig:diaSemantics}, takes an stage
\bbone\ term%
\footnote{ The input to $\redonesym$ may be open on stage \bbtwo\ variables, but
the type system ensures that those must occur under a $\next$. Consequently
$\redonesym$ will never directly encounter a variable.}
%
to a {\em future environment} $\xi$ and a partial value $v$. The future
environment implements the explicit substitutions in our example---it maps fresh
stage \bbtwo\ variables (which may appear inside $\next$ blocks in $v$) to
residuals. For non-staging features of \lang, $\redonesym$ is essentially
standard call-by-value evaluation, and gathers the subterms' future environments
into a single one.

\crem{Can we cut \ref{fig:diaSemanticsSpec} from the paper? Perhaps just put a
few representative rules into \ref{fig:diaSemantics}?}

At $\next~e$, in contrast, $\redonesym$ speculates into $e$ for stage~\bbone\ 
subexpressions to evaluate.  This is implemented by the $\redtwosym$ judgment,
which takes a stage \bbtwo\ term to a residual. 
For the most part (\ref{fig:diaSemanticsSpec}), speculation simply recurs into
all subexpressions; at $\prev$, however, it resumes $\redonesym$ evaluation,
which produces a future context $\xi$ and (by canonical forms) an expression
$\next\{\hat y\}$. $\xi$ is then reified using $\reifysym$ into a series of let
bindings enclosing $\mathtt{\hat y}$.
Once speculation reduces $e$ to a residual $q$, the output of $\redonesym$ is a
fresh variable wrapped in a $\next$ block ($\next~\hat y$), along with a future
environment which maps that variable to the residual ($\hat y \mapsto q$).

Within speculation lies a subtle---if perhaps unintuitive---feature.  
Observe that speculation will traverse into both branches of a stage-\bbtwo\ {\tt if} or {\tt case} 
statement in its search for stage~\bbone\ code. 
Thus the evaluation of that stage~\bbone\ code will occur {\em regardless of the eventual value of the predicate},
and so a term like 
\begin{lstlisting} 
1`next{
  `2`if true 
  then hold{`1`3+4`2`} 
  else prev{`1`spin() (* loops forever *)`2`}`1`
}`
\end{lstlisting}
will fail to evaluate at stage \bbone.
This behavior is why the judgment is named ``speculation."
Although it may seem undesirable, this speculative behavior is a deliberate feature.
Indeed it is critical to the quickselect example, 
wherein all three branches of the $n$-$k$ comparison are evaluated at stage~\bbone.
As always, it is the programmer's responsibility to ensure that her staging annotations 
do not cause a program to loop forever.  

The context ($\Gamma$) keeps track of stage \bbtwo\ variables in the input term. 
These both appear in the original program at stage \bbtwo\ and are inserted by the semantics.

As an optimization, we can include the special-case rule,
\begin{mathpar}
\inferdiaone [hat] {\red {\next~\hat y}{\cdot,\next~\hat y}}{\cdot}
\end{mathpar}
to avoid one-for-one variable bindings in the residual.

\subsubsection {Top-Level Evaluation}
\label{sec:partialeval}

% KAYVONF: good statement, but hold out for now
%The hope of partial evaluation is that $f_x$ is cheaper to execute than $f$, meaning that we can save work if we must %evaluate it many times.

These dynamics allow us to define a partial evaluator for \lang\ by identifying
static with stage \bbone\ and dynamic with stage \bbtwo.  Specifically, we
encode $f$ as a \lang\ expression with a function type of the form
$A\to\fut(B\to C)$.%
%\cprotect\footnote{We can rewrite \texttt{fexp} in this form, or simply apply
%the following higher-order function which makes the adjustment:
%\begin{lstlisting} 
%let adjust (f : $int * int -> $int) =
%  fn (p : int) => 
%    next{
%      fn (b : int) => 
%        prev{f (next {b}, p)}
%    }
%\end{lstlisting}}
%
Here $A$ is the static input, $B$ is the dynamic input, and $C$ is the output.

Once a stage \bbone\ argument $a:A$ is provided, we can evaluate the partially-applied
function:
$\cdot\vdash f~a \mathop{\redonesym} [\xi,v]$.
The result is an environment $\xi$ and a partial value $v$ of type $\fut(B\to
C)$, which by canonical forms must have the form $v = \next~\hat y$. 
Next, we reify this environment into a sequence of \verb|let|-bindings
enclosing $\hat y$, via $\reify\xi{\hat y}{f_a}$. 
Because reification preserves types, the resulting residual $f_a$ has type $B\to C$ in \langTwo, so we can apply it to some $b:B$
and compute the final result of the function, $f_a~b \mathop{\tworedsym} c$.

That this sequence of evaluations is in fact staged follows from our
characterizations of partial values and residuals, that $\redonesym$
outputs a partial value, and that $\reifysym$ outputs an expression in \langTwo.

For example, to specialize quickselect to a particular list, 
\begin{lstlisting}
qsStaged [5,2,7,4,1]
\end{lstlisting}
\TODO finish example

%\begin{remark}
%For any $\colone{e}{A}$ containing no $\next$ subexpressions, $\redonesym$ will
%always compute an empty environment, and a partial value identical to the result
%of call-by-value evaluation of $e$.
%%derivationally equivalent to standard call-by-value evaluation.
%\end{remark}

%\subsection{Metatheory}
%
%Recall that residuals live in \langTwo; we will indicate typing judgments in
%\langTwo\ with $\vdash_\bbtwo$.
%
%%\begin{definition}
%%Context $\Gamma$ is well-formed ($\Gamma\wf$) if it
%%contains only stage-2 variables.
%%\end{definition}
%
%\begin{definition}
%An environment $\xi$ is well-formed ($\Gamma\vdash\xi\wf$) if either:
%\begin{enumerate}
%\item $\xi = \cdot$; or
%\item $\xi = \xi',x:B\mapsto e$ where
%$\Gamma\vdash\xi'\wf$ and
%$\typeslangTwo[\Gamma,\dom{\xi'}] e B$
%%$\Gamma,\dom{\xi'}\vdash \coltwo{e}{B}$ and
%%$\Gamma,\dom{\xi'}\vdash e \res$.
%\end{enumerate}
%\end{definition}
%
%\begin{theorem}
%If $\typeswor e A$ then $\Gamma\wf$ and $A\istypewor$.
%\end{theorem}
%
%\begin{theorem}
%If $\diaonesub$ and $\typesone e A$ then
%\begin{enumerate}
%\item $\Gamma\vdash\xi\wf$;
%\item $\Gamma,\dom\xi\vdash \colone{v}{A}$; and
%\item $\Gamma,\dom\xi\vdash v\pval$.
%\end{enumerate}
%\end{theorem}
%
%\begin{theorem}
%If $\diatwosub$ and $\typestwo e A$ then
%\begin{enumerate}
%\item $\typeslangTwo q A$; and
%\item $\Gamma\vdash_\bbtwo q\val$.
%\end{enumerate}
%\end{theorem}
%
%\begin{theorem}\label{thm:reify-type}
%If $\Gamma\vdash\xi\wf$ and
%$\Gamma,\dom\xi\vdash \colone{\next\ \hat y}{\fut A}$
%then 
%$\reify{\xi}{\hat y}{q}$ and
%$\typeslangTwo q A$.
%\end{theorem}

%\TODO
%Note somewhere how to run stage-one non-$\fut A$ terms. For example, a stage-one
%integer term is guaranteed not to depend on the table, although one might be
%produced. One may either discard the table, or evaluate everything in the table
%(and terminating with the partial value iff everything in the table terminates).


