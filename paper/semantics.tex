%!TEX root = paper.tex

\section{\texorpdfstring{\lang}{Î»12} Statics and Dynamics}
\label{sec:semantics}

\input{figures/grammars}

We express two-stage programs as terms in \lang, a typed, modal lambda calculus. 
Although \lang\ describes computations that occur in two stages,
we find it helpful for the specification of splitting to differentiate terms into three \emph{worlds}.
A world is essentially a slightly finer classification than a stage.
Whereas there is only one world, \bbtwo, for second-stage computations,
there are two worlds corresponding to the first stage:
\bbonem\ for \emph{mixed} first-stage computations, which may contain second-stage subterms within $\next$ blocks,
and \bbonep\ for \emph{ground} first-stage computations, which may not.
The distinction between these two first-stage worlds is necessary for an efficient splitting algorithm
and will be discussed in \ref{sec:needGround}.

The abstract syntax of \lang\ is presented as a grammar in \ref{fig:grammar}.  
Note that some production rules are parameterized by world.
Our syntax also distinguishes values from general terms, 
with the underline term constructor (``$\exv v$'') explicitly noting the inclusion of values into general terms.
There are three forms of value: \emph{partial values} for \bbonem, \emph{ground values} for \bbonep, and \emph{residuals} for \bbtwo.
All represent computations which have no remaining work in the first stage.

\subsection{Statics}
\label{sec:statics}

\input{figures/statics}

\begin{abstrsyn}

The typing judgment $\typeswor e A$, defined in \ref{fig:statics}, means that
$e$ has type $A$ at world $w$, in the context $\Gamma$. 

All three worlds contain unit, product, and function types defined in the usual fashion;
sum and recursive types are provided for worlds \bbonep\ and \bbtwo.
\footnote{We omit sums and recursive types from \bbonem\ to save space, though we do not believe they would present any unique difficulty.}
These ``standard'' features can only be constructed from subterms of the same world,
and variables can only be used at the same world where they were introduced.
Thus differing worlds (and hence, differing stages of computation) only interact by means
of the $\fut$ and $\curr$ type formers.  These modalities are internalizations
of typing at worlds \bbtwo\ and \bbonep, respectively, to typing at \bbonem.

At the term level, {\tt next} blocks can be used to form future computations:
given a term $e$ of type $A$ at world \bbtwo, $\next{e}$ has type $\fut A$ at \bbonem. 
This essentially encapsulates $e$ as a computation that will be evaluated in the future, 
and it provides a handle (of type $\fut A$) now to that eventual value.
Computations at \bbonem\ can shuffle this handle around as a value, but the future result it refers to cannot be accessed.
This is because the only way to eliminate a $\fut$ wrapper is by using a {\tt prev}, which yields an $A$ at \bbtwo.
This feature was adapted from linear temporal logic, via \cite{davies96},
and ensures that there can be no flow of information from the second stage to the first.

$\curr A$ is a type in world \bbonem\ which classifies purely-first-stage
computations of type $A$. Given a world \bbonep\ term $e$ of type $A$,
$\pure{e}$ has type $\curr A$ at world \bbonem. ($e$ is guaranteed not to contain
second-stage computations because $\fut$ types are not available in world
\bbonep.)
An $e$ of type $\curr A$ at \bbonem\ can be unwrapped as an $A$ at \bbonep\
using the $\letp xe{e'}$ construct, which binds $\colpure xA$ in a \bbonem\ term
$e'$. This allows us to compute under $\curr$---for example, given a $\colmix
p{\curr(A\times B)}$, the term $\letp{x}{p}{\pure{\pio x}}$ computes its first
projection, of type $\curr A$.
This elimination form, in contrast to that of $\fut$, does not permit world \bbonem\ subterms
within any world \bbonep\ term.

These features are sufficient to ensure that mixed code does not leak into ground code,
however they also prevent information from ever escaping a $\curr$ wrapper.
So to allow the latter behavior but not the former, we introduce the $\caseP{e}{x.e_1}{x.e_2}$ construct, 
whose predicate is of type $\curr(A+B)$ and
whose branches are world \bbonem\ terms open on $\curr{A}$ and $\curr{B}$ respectively. 
This essentially allows code at \bbonem\ to inspect an injection tag within a $\curr$.

Although products and functions are restricted to types at the same world,
$\fut$ allows construction of ``mixed-stage'' products and functions.
For example, \texttt{qss} is a function at world \bbonem\ which takes a
$\curr{\rm list} \times \fut\rmint$ (a purely-first-stage list and a
second-stage integer) to a $\fut\rmint$ (a second-stage
computation of an integer).

The example code in this paper makes liberal use of $\rmint$s and various
functions on these, as well as a function $\pause$ which takes a $\curr\rmint$
to a $\fut\rmint$.%
\footnote{$\pause$ is definable in \lang\ given an inductive definition of
$\rmint$s. In practice, we provide both $\rmint$s and $\pause$ as primitives.
It is sensible to extend $\pause$ to all base types and to products and sums
thereof. This is related to the notion of {\em mobility} in \cite{murphy05} and
{\em stability} in \cite{krishnaswami13}.}

\end{abstrsyn}


\subsection{Dynamics}
\label{sec:dynamics}

\input{figures/dynamics}
\input{figures/dynamics-overview}

The central tenet of a staged language
is that first stage code should be evaluated entirely before second stage code.
Accordingly, our dynamics operates in two passes.
The first pass takes an input top-level program $\coltwo e A$
and reduces all of its first-stage (worlds \bbonem\ and \bbonep) subterms in place,
eventually resulting in a residual $\exv q$.
The second pass further reduces this residual.
Since a residual $q$ is monostage by definition, this second pass is standard unstaged evaluation
and is not described in further detail in this paper.
Moreover, for the purposes of these dynamics, we consider a top level program to always be typed at world \bbtwo.

Since $\coltwo e A$ may be constructed out of terms at other worlds, 
our dynamics requires notions of values and steps that are specialized to each world.

\paragraph{World \bbtwo.} Steps at world \bbtwo\ are given by the judgement \mbox{$\steptwo e {e'}$}.
Since first pass evaluation should not reduce stage two terms, this judgement does nothing but traverse $e$ to find \prev\ blocks, under which it performs in-place reductions.
A world \bbtwo\ term is done evaluating when it has the form $\exv q$, where $q$ is a residual. 
To be a residual, a term must have no first stage subterms (equivalently, no $\prev$s), even within the body of a function or branches of a case.
This implies that $\stepsym \bbtwo$ must proceed underneath second stage binders.

\paragraph{World \bbonep.} Since the ground fragment of the language is not dependent on other worlds, the semantics of ground is just that of a monostage language.
Thus, $\steppure e {e'}$ traverses into subterms to to find the left-most unevaluated code (compatibility rules) 
where it either performs a beta reduction (reduction rules) or marks the term as being evaluated (value marking rules). 
A ground value $u$ comprises only units, injections, tuples, and functions, where the body of the function may be any ground term.

\paragraph{World \bbonem.}
Like its ground counterpart, the \bbonem\ step judgement, $\stepmix e {e'}$, finds the left-most unevaluated subterm and performs a beta reduction or marks a value.
It also descends into $\pure$ and $\next$ blocks, transitioning into one of the other two steps ($\stepsym \bbonep$ or $\stepsym \bbtwo$) there. 
The value form for \bbonem, called a partial value, comprises units, tuples, functions, $\pure$ blocks of ground values, and $\next$ blocks containing \emph{only a stage two variable}.
This strong requirement ensures that second-stage computations are not duplicated 
when partial values are substituted for a variable.
This is a departure from the staged semantics of \cite{taha-thesis-99} and \cite{davies96}.
Whereas those semantics interpret values of type $\fut A$ to mean ``code of type $A$ that can be executed in the future,''
ours interprets $\fut A$ to mean ``a reference to a value that will be accessible in the future.''
This contrast stems from differing goals: metaprogramming explicitly intends to model code manipulating code,
whereas our applications feel more natural with a eager interpretation of {\tt next}.
One consequence of the stronger requirement on partial values is that a new kind of step is necessary to put terms into that form.
To illustrate, consider:
\begin{lstlisting}
2`prev{`1`(fn x : $int => e') (next{`2`e`1`})`2`}`
\end{lstlisting}
We could reduce this to $\prev([\next~e/x]e')$, but this may potentially duplicate an
expensive computation $e$. Instead, we choose to \emph{hoist} $e$ outside, binding it
to a temporary variable $y$, and substituting that variable instead:
\begin{lstlisting} 
2`let val y = e in prev{`1`[next{`2`y`1`}/x]e'`2`}`
\end{lstlisting}
This behavior is implemented by the $\lift e {e'}$ judgement, called a \emph{hoisting step}.
These steps occur when a \next\ block has contents that are a residual but (to prevent loops) not when those contents are already a variable.
In essence, the rules for hoisting steps operate by ``bubbling up'' a substitution to the innermost containing \prev,
where it is reified into a {\tt let} statement.
\footnote{Because a top-level program is a term at \bbtwo, this {\tt prev} always exists.
Otherwise, the semantics would need a mechanism to accumulate the bindings that hoisting steps create.}

\subsection{Type Safety}

The statics and dynamics of \lang\ are related by the type safety theorems
in \ref{fig:typeSafety}, again annotated by world.
In all cases, $\Gamma$ may be any list of variable bindings at world \bbtwo,
representing the second stage binders under which we are evaluating.


\subsection{Evaluating Staged Programs}

The multistage function \texttt{qss} from \ref{sec:overview} has a
type fitting the pattern \mbox{$A\to \fut (B \to C)$} at \bbonem.%
\footnote{We can rewrite \texttt{qss} in this curried form, or apply a
higher-order currying function.} 
To apply this function to arguments $\colmix a A$ and $\coltwo b B$, simply
evaluate the program:
\begin{lstlisting}
2`prev{`1`f a`2`} b`
\end{lstlisting}

We can also directly observe the reuse of first-stage computations across
multiple second-stage computations. To run many order statistics queries
$\texttt{k1},\dots,\texttt{km}$ on the same list, run the program:
\begin{lstlisting}
2`let val qs = prev{`1`qss `3`gr{`1`[7,4,2,5,9,...,3]`3`}`2`}`
2`in (qs k1,...,qs km)`
\end{lstlisting}
\TODO what?
To see that the partial application of \texttt{qss} is only evaluated once,
observe that after the first stage of evaluation, the residual has the form:
\begin{lstlisting}
2`let val y = ...`
2`    val qs = y`
2`in (qs k1,...,qs km)`
\end{lstlisting}
where $y$ is bound to a function containing no first-stage redexes.
