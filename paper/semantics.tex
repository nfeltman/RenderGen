

\section{A Two-Stage Modal Language}

\input {figures/grammars}
\input {figures/statics}

Every expression in \lang can be understood as having a {\em stage},
either \bbone~or \bbtwo, in addition to a type.
Just as a type describes \emph{which} values an expression reduces to,
the stage tells us \emph{when} it will be fully reduced. 
% FIXME why?
The reason for a two-stage design (as opposed to \cite{davies96}, which allows an infinite number of stages) will be discussed later.

The only types that exist at stage \bbtwo{} are products, sums, functions, and base types.
In addition to this usual set, stage \bbone{} also has one more type: $\fut A$,
where $A$ is a stage-\bbtwo{} type.
This can be understood as \emph{promising} a value of type $A$ at stage \bbtwo.
We'll see shortly that the promise given by $\fut A$ can only be treated opaquely at stage one; 
it cannot be redeemed for an actual $A$ until the second stage.

Although there is a strict one-way dependence between the two stages at the type
level, their terms are defined mutually recursively:
$\next$ embeds stage-\bbtwo{} expressions into stage \bbone,
whereas $\prev$ embeds stage-\bbone{} expressions into stage \bbtwo.
These $\next$ and $\prev$ constructs are the only expressions that interact with the stage of a term,
and we surround their arguments with \{braces\} in our concrete syntax to clearly indicate the stage boundaries with in a program.
The problem of how to turn an unstaged program into a staged one by inserting these constructs is called {\em binding time analysis}.
We do not consider that problem here, and instead assume that it has been solved either automatically or by a programmer. 

The grammar and type system for our language, \lang, are given in
\ref{fig:grammar} and \ref{fig:statics}.
We formulated our typing judgments in the style of \cite{davies96}, where the whole judgment is annotated with a stage.  
Variables in the context are annotated with a stage and must be used at the same stage at which they were declared.
All of the non-stage constructs have the expected type-level behavior.  
This is made manifest as rules which are entirely abstract over stage.

In addition to determining the stage, $\next$ and $\prev$ are the introduction and elimination forms for $\fut$ types.
Specifically, $\next$, given an argument with type $A$ at stage \bbtwo, forms a $\fut A$ at stage \bbone.  
That is, it forms the promise of a future $A$ out of a construction for an $A$ at the next timestep.
This promise can only be redeemed be the $\prev$ construct.  
Since $\prev$ operates at stage \bbtwo, this ensures no violation of causality.

The $\pause$ construct is a mechanism to wrap stage \bbone~integers so that they can be used at stage \bbtwo.  
Although $\pause$ can be implemented from our other features, 
we provide it as a primitive to simplify our examples. 

\subsection {Staged Fast Exponentiation}

Fast exponentiation is a method for calculating $b^p$ in $\log p$ time:
\[
	\mathit{fexp}(b,p) = \left \{ \begin{array}{ll} 
		1 &  p = 0 \\ 
		\mathit{fexp}(b,p/2)^2 & p \text{ even} \\ 
		b \cdot \mathit{fexp}(b,p-1) & p \text{ odd} \end{array}
	\right .
\]

Without going into details of how recursion is handled, we implement staged fast exponentiation in \lang~below.  
We use {\tt \$} in place of $\fut$ in this an other examples.

\begin{lstlisting} 
let fexp (b : $int, e : int) : $int =
	if e == 0 then
		next{1}
	else if (e mod 2) == 0 then
		next{let x = prev{fexp(b,p/2)} in x*x}
	else
		next{prev{b} * prev{fexp(b,p-1)}}		
\end{lstlisting}

Although the code for {\tt fexp} looks very much like the stage-less mathematical definition above, it is in fact a staged program.  
See how the {\tt if}s and exponent decomposition are all at stage \bbone, since they occur within $\prev$ blocks.  
Essentially, the type system is sufficient to prove the observation that all of the decomposition of the exponent can be done at the stage \bbone~without requiring us to disrupt the elegant functional structure of the code.

This example also illustrates how stage \bbone~and stage \bbtwo~code can be arbitrarily nested.  Normal notions of eager evaluation reduce code in a leaf-to-root way, but this conflicts with the precept that we evaluate stage \bbone~before stage \bbtwo.  
To resolve this conflict, we need a formal semantics for \lang.

\subsection{Semantics}

\input {figures/dynamics}

%Previous work (\cite{davies96}) focuses on the correspondence between the type system and existing temporal logics, whereas we care more about operational behavior and cost.  In this section, we'll consider a few proposals for our language before settling on one we like.  All of the proposals are call-by-value, differing primarily in how they handle values of $\fut$ type.

%\subsection{The Erasure Semantics}
%
%We first consider the {\em erasure semantics}, so called because it corresponds to what one would get by interpreting \lamStaged as a single-stage language, ignoring all of the $\next$ and $\prev$ terms.  This gives us two judgments, $\erasone$ and $\erastwo$, corresponding to {\em multistage evaluation} at \bbone and at \bbtwo.  We call these judgments  ``multistage'' because they cause work to happen at both stages.
%
%Both judgments behave normally at non-staged features.  We cover their behavior at staged features below:
%
%\begin{mathpar}
%\infer {\next~e \erasone \next~v} {e \erastwo v} \and
%\infer {\prev~e \erastwo \next~v} {e \erasone v} \and
%\infer {\pause~e \erasone \next~i} {e \erasone i}
%\end{mathpar}
%
%Essentially, we immediately evaluate under the $\next$, yielding a value for $\fut$ types. The $\prev$ terms remove this wrapper.  As expected, $\pause$ also gives us a way to inject into the wrapper at integers.
%
%The erasure semantics has some undesirable properties.  By intention, it interleaves the execution of stage-\bbone~and stage-\bbtwo~code, so the evaluation can't really be said to be staged (i.e. stage-\bbone~work is done before stage-\bbtwo~work).  Moreover, the erasure semantics cannot be equivalent to any semantics which does have this property!  To see why, consider the following code, which types to int at \bbtwo:
%
%\begin{lstlisting} 
%if 5*4*3*2 > 111 then
%	prev{ hold (2+4) }
%else
%	prev{ loopForever () (* does not terminate *) }
%\end{lstlisting}
%
%Under the erasure semantics (using $\erastwo$), this code takes the top branch and evaluates to 6.  But in order know that the {\tt loopForever} function need not be called, the predicate had to be evaluated prior.  But the predicate is stage-\bbtwo, whereas {\tt loopForever} is stage-\bbone.  To borrow terminology from \cite{cave14}, this violates causality.  In order to avoid this problem, a valid semantics must {\em speculate} down the branches of any stage-\bbtwo~if or case statement (or similarly into the body of a stage-\bbtwo function) to find and evaluate all of the stage-\bbone~code.  Both of the other semantics we will consider have this property.
%
%The benefit of the erasure semantics is that it's very natural, and has a familiar cost model.  It also {\em obviously} produces the ``correct'' answer, so we can use the erasure semantics as a reference to prove the reasonableness of any other semantics.
%
%\subsection{Meta Semantics}
%
%A different semantics was provided in \cite{davies96}.  We briefly review a two-stage version of that semantics here.
%
%In the erasure semantics, $\next v$ is a value only if $v$ is fully reduced.  But in the meta semantics, $\next e$ is a value only if $e$ has no $\prev$ terms; $v$ is allowed to have unreduced stage-2 computation. 
%
%...
%
%The Davies semantics is comprised of two mutually recursive judgments: $\daviesz$ and $\davieso$.  For some $\colone e A$, the $\daviesz$ judgment evaluates only the first-stage parts of $e$, leaving unevaluated second-stage code within $\next$s.  (... This essentially gives us partial evaluation, and we're left to just evaluate the residual normally to get multi-stage evaluation...) 
%
%The benefit of the meta semantics is that it gives us a very explicit notion of partial evaluation.  This also, by construction, means that the meta semantics does all of the first stage-work {\em before} the second stage work begins. 
%
%The $\next$-by-name behavior of the meta semantics of course means that it happily duplicates second-stage code, which could increase the cost.  This makes reasoning about second-stage cost rather difficult.
%
%\begin{lstlisting} 
%let x = next {4+5} in
%next{prev{x} * prev{x}}
%\end{lstlisting}
%
%\subsection{Our Semantics}
%
%We desire a semantics that meets the following goals:
%
%\begin{enumerate}
%\item Modulo termination, it should be equivalent to the erasure semantics.
%\item All of the first stage work should be completed before second stage work.  Ideally, it should just have a notion of partial evaluation, like the meta semantics.
%\item Should be $\next$-by-value, rather than $\next$-by-name, like the erasure semantics.  
%\end{enumerate}
%
%We meet all of these goals.


In this section, we discuss the dynamic semantics of our language.  
Before we can get into the details of the semantics, we have to first make some decisions about the behavior we want it to have.  
Similar to \cite{davies96}, we want our semantics to have the form of a judgment that partially evaluates an expression to create a residual that can be evaluated at the second stage in the standard way.  Again like Davies, we choose a call-by-value paradigm as our baseline at both stages.  The only significant freedom that this leaves is how to handle the staging constructs.  

We present here two reasonable interpretations of these staging constructs, 
in the context of the following stage-\bbtwo~example:
\begin{lstlisting} 
prev{
let x = (next {4+5}, 7+8) in
next{
	prev{#1 x} * prev{#1 x} * prev{hold (#2 x)}
}
}
\end{lstlisting}
The first option is to duplicate the contents of the first $\next$ expression to produce,
\begin{lstlisting}
(4+5) * (4+5) * 15
\end{lstlisting}
Essentially, we're treating $\next$ as a value a stage-\bbone, so long as all of its contained $\prev$s are reduced.  
This is the technique of \cite{davies96}.
Instead of this, we take a second, nearly equivalent approach.  
That is to bind the contents of the first $\next$ expression to some variable (here, $x1$) and then duplicate that variable,
\begin{lstlisting} 
let x1 = 4+5 in
x1 * x1 * 15
\end{lstlisting}

We think that this interpretation makes more sense from the point of view of cost, 
since the contents of a $\next$ always appear once in the residual, regardless of how many times the result is used.  
This is {\em nearly} equivalent to the first expression, because they have different termination behavior 
when a non-terminating stage-\bbtwo~expression is declared but never used.

Now that we know {\em what} the behavior is that we want, we can explain {\em how} our semantics achieves that behavior.  We start with the same example:
\begin{lstlisting}
prev {
let x = (next {4+5}, 7+8) in
next{
	prev{#1 x} * prev{#1 x} * prev{hold (#2 x)}
}
}
\end{lstlisting}
The first thing we need to do is evaluate the binding for $x$.  Of course, we can't evaluate inside the $\next$ statement, but we still need to produce a value that will get substituted.  What we do instead is replace the body of the $\next$ by a variable and make an explicit substitution, which then floats up to the top of the containing $\prev$:
\begin{lstlisting} 
prev{
[4+5/x1]
let x = (next{x1}, 15) in
next{
	prev{#1 x} * prev{#1 x} * prev{hold (#2 x)}
}
}
\end{lstlisting}
We're now free to perform the stage-\bbone~substitution for $x$.  
\begin{lstlisting} 
prev{
[4+5/x1]
next{
	prev{#1 (next{x1}, 15)} 
	* prev{#1 (next{x1}, 15)} 
	* prev{hold (#2 (next{x1}, 15))}
}
}
\end{lstlisting}
To evaluate the remaining $\next$, we must first partially evaluate the body by finding all of the contained stage-\bbone~terms and reducing them:
\begin{lstlisting} 
prev{
[4+5/x1]
	next{ x1 * x1 * 15 }
}
\end{lstlisting}
The final step in evaluating the outer $\prev$ is reifying the contained substitutions into let statements, yielding
\begin{lstlisting} 
let x1 = 4+5 in
 x1 * x1 * 15
\end{lstlisting}

Once again, the point here is that we did not duplicate the $4+5$ in our residual.  
Instead we lifted it out into a substitution, leaving a hatted variable [note: add hats above] in its place,
and we reified the substitution into a let-binding at the enclosing $\prev$.

\subsection{more formally...}

Abstractly, we can think of our evaluation as proceeding in the standard way for stage-1 code. When the evaluator encounters a $\next \{e\}$ expression, it places $e$ off to the side in a context and replaces the whole expression with a reference to the context entry.  These references are then passed around as stage-1 values for $\fut$ types.  But what if $e$ contains $\prev$ expressions?  To ensure that all stage-1 code is evaluated before any stage-2 code, we must evaluate all of the 1-code contained in $e$ before inserting it into the table.  This entails searching $e$ for all contained $\prev$s and evaluating them in place.  

More formally, evaluation comprises the following judgments:

\begin{center}
\begin{tabular}{|c|p{2.5cm}|p{2.5cm}|} \hline
Judgment & Reads & Conditions \\ \hline 
$\isvalone e$ & ``$e$ is a $\bbone$-value under context $\Xi$'' & ... \\ \hline 
$\diaonesub$ & ``$e$ evaluates to future table $\xi$ and value $v$'' 
& $\typesone e A$ 
	\newline $\isvalone v$ 
	\newline ... \\ \hline 
$\diatwosub$ & ``$e$ speculates to $q$'' & ... \\ \hline 
...&...&... \\ \hline
\end{tabular}
\end{center}

Evaluation and speculation are the main judgments here, the rest being largely administrative.  The evaluation judgment operates on stage-1 code, whereas the speculation operates on stage-2 code.  Since $\next$ and $\prev$ are the crossover points between 1-code and 2-code, they are correspondingly the only places where the evaluation and speculation judgments depend on the other. 


% FIXME we need a real name for hatted variables
The evaluation judgment is very similar to standard call-by-value evaluation, as goal 1 would suggest.  The input to evaluation is a stage-1 expression (usually $e$), as well as two administrative contexts ($\Gamma$ and $\Xi$), covered later.  Evaluation has two outputs: the {\em future context} (usually $\xi$) and the {\em partial value} (usually $v$).  We cover the latter first.  The partial value is essentially the result of the first-stage portion of $e$, and must be a \bbone-value of the same type as $e$.  As usual, this means that $v$ must be composed only of base primitives, tuples, injections, and lambdas (corresponding to base types, products, sums, and functions).  Analogously, the value corresponding to $\fut$ is a construct called a {\em hatted variable} (written $\hat y$), which signifies a reference to some stage-2 computation.  The mapping between these hatted variables and stage-two expressions is

...

\subsection{Other nice properties}

\begin{enumerate}
\item For some $\colone{e}{A}$ containing no $\next$ expressions, the semantics is derivationally equivalent to standard call-by-value evaluation.
\end{enumerate}

\subsection{Metatheory}

\TODO unfinished; where should this go? combine with table above

\noindent\TODO terminology for $\Xi,\Gamma,\xi,v,q$?

\noindent\TODO need to define 1-vals at 1 and 2, and 2-vals at 2. what is the
terminology? (?, residuals, results?)

\noindent\TODO put $\Xi$ and $\Gamma$ in the judgments where appropriate

\noindent\TODO be uniform about which judgments have which contexts, etc

% local macros; put them in macros.tex once they are more finalized
\newcommand{\wf}{\ \mathsf{wf}}
\newcommand{\valoo}{\ \bbone\textsf{-}\mathsf{val} @ \bbone}
\newcommand{\valot}{\ \bbone\textsf{-}\mathsf{val} @ \bbtwo}
\newcommand{\valtt}{\ \bbtwo\textsf{-}\mathsf{val} @ \bbtwo}

\begin{definition}
Contexts $\Xi$ and $\Gamma$ are well-formed ($\Xi\wf$, $\Gamma\wf$) if they
contain only stage-2 variables.
\end{definition}

\noindent\TODO don't call it a table

\noindent\TODO what is the notation for $\xi$s? how do you build them?

\noindent\TODO define reification explicitly as a metafunction

\begin{definition}
A table $\xi$ is well-formed ($\xi\wf$) if either:
\begin{enumerate}
\item $\xi = \cdot$; or
\item $\xi = \xi',x\mapsto e$ where
$\Xi,\dom{\xi'};\Gamma\vdash e : B @ \bbtwo$ and
$\Xi,\dom{\xi'};\Gamma\vdash e \valot$.
\end{enumerate}
\end{definition}

\begin{theorem}
If $\Xi;\typesone e A$ then $\Xi\wf$, $\Gamma\wf$, and $A\istypeone$.
\end{theorem}

\begin{theorem}
If $\diaonesub$ then:
\begin{enumerate}
\item $\typesone e A$ for some 1-type $A$;
\item $\xi\wf$;
\item $\Xi,\dom\xi;\cdot\vdash v : A @ \bbone$; and
\item $\Xi,\dom\xi;\cdot\vdash v\valoo$.
\end{enumerate}
\end{theorem}

\begin{theorem}
If $\diatwosub$ then:
\begin{enumerate}
\item $\typestwo e A$ for some 2-type $A$;
\item $\Xi;\Gamma\vdash q : A @ \bbtwo$; and
\item $\Xi;\Gamma\vdash q\valtt$.
\end{enumerate}
\end{theorem}


