%!TEX root = paper.tex

\section{Additional examples}

This appendix includes additional examples of the behavior of our
splitting algorithm.

\subsection {Mixed Map Combinator}

In \ref{sec:exampleQS}, we showed the output of splitting quickselect
applied to one list and $m$ queries.  Here, we generalize to mapping
quickselect onto a list of queries. Note that we have to define a
datatype for integer lists at the second stage, which is given by
\texttt{list2}.
\begin{lstlisting} 
1`atsignnext{`2`
  datatype list2 = Empty2 | Cons2 of int * list2
`1`}

type qsType = ^list*$`2`int`1`->$`2`int`1`

// map : qsType -> ^list * $`2`list2`1` -> $`2`list2`1`
fun map f (l, q) = 
next {`2`
  let 
  fun m Empty2 = Empty2
    | m (Cons2(h,t)) = Cons2(prev{`1`f (l,next{`2`h`1`})`2`}, m t)
  in m prev{`1`q`2`}
`1`}

val qsMany = map qs`
\end{lstlisting}
The \texttt{map} function splits into the following two functions:
\begin{lstlisting} 
2`datatype list2 = Empty2 | Cons2 of int * list2

`1`fun map1 f = (fn (l,()) => ((), #2 (f (l, ()))), ())
`2`fun map2 (f,()) ((l,q), p : tree) =
  let 
  fun m Empty2 = Empty2
    | m (Cons2(h,t)) = Cons2(f ((l,h), p), m t) 
  in m q

`1`val (qsMany1,()) = map1 qs
`2`val qsMany2 = map2 (qs, ()) `
\end{lstlisting}

As desired, \texttt{qs1} (which is passed to \texttt{map1} via variable \texttt{f}) is executed only once per invocation of \texttt{map},
whereas \texttt{qs2} (which is passed to \texttt{map2} via variable \texttt{f}) is executed once per query.

\subsection{Trie}

The function {\tt exists} determines whether a query string \texttt{s} occurs in
a given list of strings (over the alphabet $\{A,B,C\}$). It starts by
partitioning the provided set of strings into three subsets, corresponding to
the set of strings starting with $A$ (resp., $B$ and $C$), and stripping that
first letter off of each of those strings. While processing the input list, it
also keeps track of whether the empty string has been encountered.
%
We then look at the query string \texttt{s}. If it's empty, we return whether
the empty string was encountered. Otherwise, we choose the partition which
agrees with the first letter of \texttt{s}, and recursively searches that list
of strings for the remainder of \texttt{s}.

Our staging annotations indicate that the list of strings are first-stage, while
the query string is second-stage.
\begin{lstlisting} 
3`atsigngr { `1`
datatype letter = A | B | C 
datatype string = EmptyS | ConsS of letter * string
datatype list   = EmptyL | ConsL of string * list

fun partition (EmptyL) = (false,EmptyL,EmptyL,EmptyL) 
  | partition (ConsL (s,ss)) = 
  let val (anyEmpty,a,b,c) = partition ss in 
  case s of 
    EmptyS => (true,a,b,c) 
  | ConsS (A,z) => (anyEmpty,ConsL(z,a),b,c) 
  | ConsS (B,z) => (anyEmpty,a,ConsL(z,b),c) 
  | ConsS (C,z) => (anyEmpty,a,b,ConsL(z,c)) 
`3`}`1`
atsignnext { `2`
datatype letter2 = A2 | B2 | C2
datatype string2 = EmptyS2 
				 | ConsS2 of letter2 * string2
`1`}

fun exists (`3`gr{`1`EmptyL`3`}`1`,next{`2`s`1`}) = next{`2`false`1`} 
  | exists (`3`gr{`1`ConsL ht`3`}`1`,next{`2`s`1`}) = 
	let `3`atsigngr{`1`
	  val (anyEmpty,a,b,c) = partition (ConsL ht)
	`3`}`1` in next { `2`
	case s of 
	  EmptyS2 => prev{`1`hold `3`gr{`1`anyEmpty`3`}`2`} 
	| ConsS2 (A2,z) => prev{`1`exists(`3`gr{`1`a`3`}`1`,next{`2`z`1`})`2`} 
	| ConsS2 (B2,z) => prev{`1`exists(`3`gr{`1`b`3`}`1`,next{`2`z`1`})`2`}
	| ConsS2 (C2,z) => prev{`1`exists(`3`gr{`1`c`3`}`1`,next{`2`z`1`})`2`}  
	`1`}` 
\end{lstlisting}
Running the splitting algorithm on this code produces:
\begin{lstlisting} 
datatype trie = Leaf 
			  | Branch of bool * trie * trie * trie

1`datatype letter = A | B | C 
datatype string = EmptyS | ConsS of letter * string
datatype list   = EmptyL | ConsL of string * list
fun partition (EmptyL) = (false,EmptyL,EmptyL,EmptyL) 
  | partition (ConsL (s,ss)) = 
  let val (anyEmpty,a,b,c) = partition ss in 
  case s of 
    EmptyS => (true,a,b,c) 
  | ConsS (A,z) => (anyEmpty,ConsL(z,a),b,c) 
  | ConsS (B,z) => (anyEmpty,a,ConsL(z,b),c) 
  | ConsS (C,z) => (anyEmpty,a,b,ConsL(z,c)) 
in
fun exists1 (EmptyL,()) = ((), Leaf)
  | exists1 (ConsL ht,()) =
	let 
	  val (anyEmpty,a,b,c) = partition (ConsL ht) 
	in ((), 
		Branch (anyEmpty, 
			#2 (exists1 (a, ())), 
			#2 (exists1 (b, ())), 
			#2 (exists1 (c, ()))))

`2`datatype letter2 = A2 | B2 | C2
datatype string2 = EmptyS2 
                 | ConsS2 of letter2 * string2
fun exists2 (((),s), Leaf) = false
  | exists2 (((),s), Branch (e,a,b,c)) = 
    case s of
	  EmptyS2 => e
	| ConsS2 (A,z) => exists2 (((), z), a)
	| ConsS2 (B,z) => exists2 (((), z), b)
	| ConsS2 (C,z) => exists2 (((), z), c)`

\end{lstlisting}

\texttt{exists1} creates a trie (or prefix tree) as the boundary data structure,
which is traversed by \texttt{exists2}.

