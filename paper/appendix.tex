%!TEX root = paper.tex

\section{Additional examples}

This appendix includes additional examples of the behavior of our
splitting algorithm.

\subsection {Mixed Map Combinator}

In \ref{sec:exampleQS}, we showed the output of splitting quickselect
applied to one list and $m$ queries.  Here, we generalize to mapping
quickselect onto a list of queries. Note that we have to define a
datatype for integer lists at the second stage, which is given by
\texttt{list2}.
\begin{lstlisting} 
1`atsignnext{`2`
  datatype list2 = Empty2 | Cons2 of int * list2
`1`}

type qsType = ^list*$`2`int`1`->$`2`int`1`

// map : qsType -> ^list * $`2`list2`1` -> $`2`list2`1`
fun map f (l, q) = 
next {`2`
  let 
  fun m Empty2 = Empty2
    | m (Cons2(h,t)) = Cons2(prev{`1`f (l,next{`2`h`1`})`2`}, m t)
  in m prev{`1`q`2`}
`1`}

val qsMany = map qs`
\end{lstlisting}
The \texttt{map} function splits into the following two functions:
\begin{lstlisting} 
2`datatype list2 = Empty2 | Cons2 of int * list2

`1`fun map1 f = (fn (l,()) => ((), #2 (f (l, ()))), ())
`2`fun map2 (f,()) ((l,q), p : tree) =
  let 
  fun m Empty2 = Empty2
    | m (Cons2(h,t)) = Cons2(f ((l,h), p), m t) 
  in m q

`1`val (qsMany1,()) = map1 qs
`2`val qsMany2 = map2 (qs, ()) `
\end{lstlisting}

As desired, \texttt{qs1} (which is passed to \texttt{map1} via variable \texttt{f}) is executed only once per invocation of \texttt{map},
whereas \texttt{qs2} (which is passed to \texttt{map2} via variable \texttt{f}) is executed once per query.

\subsection{Trie}

The function {\tt exists} determines whether a query string \texttt{s} occurs in
a given list of strings (over the alphabet $\{A,B,C\}$). It starts by
partitioning the provided set of strings into three subsets, corresponding to
the set of strings starting with $A$ (resp., $B$ and $C$), and stripping that
first letter off of each of those strings. While processing the input list, it
also keeps track of whether the empty string has been encountered.
%
We then look at the query string \texttt{s}. If it's empty, we return whether
the empty string was encountered. Otherwise, we choose the partition which
agrees with the first letter of \texttt{s}, and recursively searches that list
of strings for the remainder of \texttt{s}.

Our staging annotations indicate that the list of strings are first-stage, while
the query string is second-stage.
\begin{lstlisting} 
atsigngr { 
datatype letter = A | B | C 
datatype string = EmptyS | ConsS of letter * string
datatype list   = EmptyL | ConsL of string * list

fun partition (EmptyL) = (false,EmptyL,EmptyL,EmptyL) 
  | partition (ConsL (s,ss)) = 
  let val (anyEmpty,a,b,c) = partition ss in 
  case s of 
    EmptyS => (true,a,b,c) 
  | ConsS (A,z) => (anyEmpty,ConsL(z,a),b,c) 
  | ConsS (B,z) => (anyEmpty,a,ConsL(z,b),c) 
  | ConsS (C,z) => (anyEmpty,a,b,ConsL(z,c)) 
}
atsignnext { 
datatype letter2 = A2 | B2 | C2
datatype string2 = EmptyS2 | ConsS2 of letter2 * string2
}

fun exists (gr{EmptyL},next{s}) = next{false} 
  | exists (gr{ConsL ht},next{s}) = 
	let atsigngr{
	  val (anyEmpty,a,b,c) = partition (ConsL ht)
	} in next { 
	case s of 
	  EmptyS2 => prev{hold gr{anyEmpty}} 
	| ConsS2 (A2,z) => prev{exists(gr{a},next{z})} 
	| ConsS2 (B2,z) => prev{exists(gr{b},next{z})}
	| ConsS2 (C2,z) => prev{exists(gr{c},next{z})}  
	} 
\end{lstlisting}
Running the splitting algorithm on this code produces:
\begin{lstlisting} 
datatype trie = Leaf 
			  | Branch of bool * trie * trie * trie

1`datatype letter = A | B | C 
datatype string = EmptyS | ConsS of letter * string
datatype list   = EmptyL | ConsL of string * list
fun partition (EmptyL) = (false,EmptyL,EmptyL,EmptyL) 
  | partition (ConsL (s,ss)) = 
  let val (anyEmpty,a,b,c) = partition ss in 
  case s of 
    EmptyS => (true,a,b,c) 
  | ConsS (A,z) => (anyEmpty,ConsL(z,a),b,c) 
  | ConsS (B,z) => (anyEmpty,a,ConsL(z,b),c) 
  | ConsS (C,z) => (anyEmpty,a,b,ConsL(z,c)) 
in
fun exists (EmptyL,()) = ((), Leaf)
  | exists (ConsL ht,()) =
	let 
	  val (anyEmpty,a,b,c) = partition (ConsL ht) 
	in ((), 
		Branch (anyEmpty, 
			#2 (exists (a, ())), 
			#2 (exists (b, ())), 
			#2 (exists (c, ()))))

`2`datatype letter2 = A2 | B2 | C2
datatype string2 = EmptyS2 | ConsS2 of letter2 * string2
fun exists (((),s), Leaf) = false
  | exists (((),s), Branch (e,a,b,c)) = 
    case s of
	  EmptyS2 => e
	| ConsS2 (A,z) => exists (((), z), a)
	| ConsS2 (B,z) => exists (((), z), b)
	| ConsS2 (C,z) => exists (((), z), c)`

\end{lstlisting}

\texttt{exists1} creates a trie (or prefix tree) as the boundary data structure,
which is traversed by \texttt{exists2}.

