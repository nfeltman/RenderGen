%!TEX root = paper.tex

\section{Additional examples}

This appendix includes additional examples of the behavior of our
splitting algorithm.

\subsection {Mixed Map Combinator}

In \ref{sec:exampleQS}, we showed the output of splitting quickselect
applied to one list and $m$ queries.  Here, we generalize to mapping
quickselect onto a list of queries. Note that we have to define a
datatype for integer lists at the second stage, which is given by
\texttt{list2}.
\begin{lstlisting} 
1`atsignnext{`2`
  datatype list2 = Empty2 | Cons2 of int * list2
`1`}

type qsType = ^list*$`2`int`1`->$`2`int`1`

// map : qsType -> ^list * $`2`list2`1` -> $`2`list2`1`
fun map f (l, q) = 
next {`2`
  let 
  fun m Empty2 = Empty2
    | m (Cons2(h,t)) = Cons2(prev{`1`f (l,next{`2`h`1`})`2`}, m t)
  in m prev{`1`q`2`}
`1`}

val qsMany = map qs`
\end{lstlisting}
The \texttt{map} function splits into the following two functions:
\begin{lstlisting} 
2`datatype list2 = Empty2 | Cons2 of int * list2

`1`fun map1 f = (fn (l,()) => ((), #2 (f (l, ()))), ())
`2`fun map2 (f,()) ((l,q), p : tree) =
  let 
  fun m Empty2 = Empty2
    | m (Cons2(h,t)) = Cons2(f ((l,h), p), m t) 
  in m q

`1`val (qsMany1,()) = map1 qs
`2`val qsMany2 = map2 (qs, ()) `
\end{lstlisting}

As desired, \texttt{qs1} (which is passed to \texttt{map1} via variable \texttt{f}) is executed only once per invocation of \texttt{map},
whereas \texttt{qs2} (which is passed to \texttt{map2} via variable \texttt{f}) is executed once per query.

\subsection{Trie}

Our last example is one which generates a trie intermediate data structure.

The function {\tt exists} below determines whether a query string (s) occurs in a given set of strings (from the alphabet $\{A, B,C\}$).
It solves this problem by partitioning the provided set of strings into three subsets,
one which contains all words that start with $A$,
one which contains all words that start with $B$, and one for $C$.
When partitioning, we also throw away the first letter, since we know it's uniform for the whole subset.
Also while doing this partitioning, we also keep track of whether the empty word occurred at all.
We then look at the query string.  If it's empty, we return whether the empty word was in the set.
Otherwise, we look at the first letter, pick the appropriate subset, 
and recursively search for the rest of our query string in that.

We stage this algorithm by saying that the word set comes at stage \bbone\
and the query string comes at stage \bbtwo.

\begin{lstlisting} 
atsignmono { 
datatype letter = A | B | C 
datatype string = EmptyS | ConsS of letter * string
datatype list   = EmptyL | ConsL of string * list

fun partition (EmptyL) = (false,EmptyL,EmptyL,EmptyL) 
  | partition (ConsL (s,ss)) = 
  let val (anyEmpty,a,b,c) = partition ss in 
  case s of 
    EmptyS => (true,a,b,c) 
  | ConsS (A,z) => (anyEmpty,ConsL(z,a),b,c) 
  | ConsS (B,z) => (anyEmpty,a,ConsL(z,b),c) 
  | ConsS (C,z) => (anyEmpty,a,b,ConsL(z,c)) 
}
atsignnext { 
datatype letter2 = A2 | B2 | C2
datatype string2 = EmptyS2 | ConsS2 of letter2 * string2
}

fun exists (mono{EmptyL},next{s}) = next{false} 
  | exists (mono{ConsL ht},next{s}) = 
	let atsignmono{
	  val (anyEmpty,a,b,c) = partition (ConsL ht)
	} in next { 
	case s of 
	  EmptyS2 => prev{hold mono{anyEmpty}} 
	| ConsS2 (A2,z) => prev{exists(mono{a},next{z})} 
	| ConsS2 (B2,z) => prev{exists(mono{b},next{z})}
	| ConsS2 (C2,z) => prev{exists(mono{c},next{z})}  
	} 
\end{lstlisting}

\noindent
Running the splitting algorithm on this code produces:

\begin{lstlisting} 

datatype trie = Leaf 
			  | Branch of bool * trie * trie * trie

1`datatype letter = A | B | C 
datatype string = EmptyS | ConsS of letter * string
datatype list   = EmptyL | ConsL of string * list
fun partition (EmptyL) = (false,EmptyL,EmptyL,EmptyL) 
  | partition (ConsL (s,ss)) = 
  let val (anyEmpty,a,b,c) = partition ss in 
  case s of 
    EmptyS => (true,a,b,c) 
  | ConsS (A,z) => (anyEmpty,ConsL(z,a),b,c) 
  | ConsS (B,z) => (anyEmpty,a,ConsL(z,b),c) 
  | ConsS (C,z) => (anyEmpty,a,b,ConsL(z,c)) 
in
fun exists (EmptyL,()) = ((), Leaf)
  | exists (ConsL ht,()) =
	let 
	  val (anyEmpty,a,b,c) = partition (ConsL ht) 
	in ((), 
		Branch (anyEmpty, 
			#2 (exists (a, ())), 
			#2 (exists (b, ())), 
			#2 (exists (c, ()))))

`2`datatype letter2 = A2 | B2 | C2
datatype string2 = EmptyS2 | ConsS2 of letter2 * string2
fun exists (((),s), Leaf) = false
  | exists (((),s), Branch (e,a,b,c)) = 
    case s of
	  EmptyS2 => e
	| ConsS2 (A,z) => exists (((), z), a)
	| ConsS2 (B,z) => exists (((), z), b)
	| ConsS2 (C,z) => exists (((), z), c)`

\end{lstlisting}

As promised, this split version creates a trie in the first stage, and consumes it in the second stage.
