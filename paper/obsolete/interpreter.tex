\subsection{Interpreter}

\begin{lstlisting}
datatype binop  = Plus | Minus in
datatype iota	= Arg
				| Int of int 
				| Binop of binop * iota * iota
				| If of iota * iota * iota

fun eval2K (e,a,k) 
	: (iota * $int * ($int -> $int)) =
	case e of
	  Arg => k a
	| Int i => k next{hold{i}}
	| Binop (op,e1,e2) =>
		  eval2K (e1,a,
		  fn i => 
		    eval2K (e2,a,fn j => k (evalBinop2 (op,i,j)))
		  )
	| If (e1,e2,e3) =>
		  eval2K
		  (e1,a,fn i =>
				next {
					if prev { i }>0 then
						prev { eval2K (e2,a,k) }
					else
						prev { eval2K (e3,a,k) }
				})
\end{lstlisting}
splits into first part
\begin{lstlisting}
fun eval2K (e,a,k) =
	case e of
	  Arg => let (v,p) = k a in (v,inj1 p)
	| Int i =>
		let (v_1,p_1) = k ()
		(v_1,inj2 ((),i,p_1))
	| Binop (op,e1,e2) =>
		let (v,p) =
			eval2K (e1,a,
			fn i =>
				eval2K (e2,a,
				fn j =>
					let (v,p) = evalBinop2 (op,i,j) in
					let (v_1,p_1) = k v in
					(v_1, ((),p,p_1))
				)
			)
		in
		(v,inj3 p)
	| If (e1,e2,e3) =>
		let (v,p) =
			eval2K (e1,a,
			fn i =>
				((),(#2 (eval2K (e2,a,k)),#2 (eval2K (e3,a,k))))
			)
		in
		(v,inj4 p)
\end{lstlisting}
and second part
\begin{lstlisting}
fun eval2K ((e,a,k),l_3) =
	case l_3 of
	  inj1 l_4 => k (a,l_4)
	| inj2 l_4 => k (#2 l_4, #3 l_4)
	| inj3 l_4 =>
		eval2K (((),a,
		fn (i,l_5) =>
			eval2K (((),a,
			fn (j,l_6) => 
				k (evalBinop2 (((),i,j),#2 l_6),#3 l_6)
			),l_5)
		),l_4)
	| inj4 l_4 =>
		  eval2K
		  (((),a,fn (i,(l_6,l_5)) =>
				 if i>0 then
					 eval2K (((),a,k),l_6)
				 else
					 eval2K (((),a,k),l_5)),l_4)
\end{lstlisting}


