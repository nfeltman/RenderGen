To illustrate this, we present colorized version of \texttt{qSelect}:

\begin{lstlisting} 
1`datatype list = Empty | Cons of int * list
fun partition (p : int, l : list) = ... `

fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  case l of
    Empty => `2`0`1`
  | Cons (h,t) => 
      let (left,right,n) = partition h t in`2`
      case compare k n of
        LT => `qSelect 1`left `2`k
      | EQ => h
      | GT => `qSelect 1`right `2`(k-n-1)`
\end{lstlisting}

Here, the input $k$ and all parts of the computation that depend on it are colored blue,
whereas all of the parts of the computation that do not depend on $k$ are colored red.
The \texttt{qSelect} variable itself, due to its status as a function with a mixed-color body, is left black.

\ur{I find control dependence issue very confusing.  Let's factor this
out and talk about it in the end. }

To be precise, we use "depend on" to mean data dependence, but not control dependence---the 
first arguments to the recursive calls to \texttt{qSelect} are colored red,
despite appearing underneath a blue case statement.
This coloring rule is enough to ensure that information can flow from red code to blue code but not vice versa.

Observe the that helper function \texttt{partition} is colored entirely red,
which is valid because it is called with only red arguments.  
This is an illustration of the property stated above, that 
the partitioning of the list, even through recursion, depends only on the list itself and not on $k$.
Moreover, the property is notable because much of the work of the quickselect algorithm takes place in \texttt{partition}.

This suggests an optimization: we can split \texttt{qSelect} into two functions, 
one for all of the red code (\texttt{qSelect1}) and another for all of the blue code (\texttt{qSelect2}). 
Because of the dependence properties stated above, 
\texttt{qSelect2} will need only depend on the results of \texttt{qSelect1} and the input index $k$,
whereas \texttt{qSelect1} will only depend on the input list $l$.
Additionally, the meaning of \texttt{qSelect1} appropriately composed with \texttt{qSelect2} should be the same as \texttt{qSelect}, too.
Equationally, we can represent this relationship as simply 
\[
\mathtt{qSelect~l~k} \equiv \mathtt{qSelect2~(qSelect1~l)~k}
\]
for some list \texttt{l} and index \texttt{k}.


\ur{I don't follow the explanation below, e.g., ``assuming conclusion''}

With this goal in mind, we now set about deriving \texttt{qSelect1} and \texttt{qSelect2} from our colorized \texttt{qSelect}.
Because the original function is recursive,
the first step in this process is to assume the conclusion at the call sites.

\ur{quickselect 1 and 2: how did we introduce them?}

This is performed in place:
\begin{lstlisting} 
fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  case l of
    Empty => `2`0`1`
  | Cons (h,t) => 
      let (left,right,n) = partition h t in`2`
      case compare k n of
        LT => qSelect2 (`1`qSelect1 left`2`) k
      | EQ => h
      | GT => qSelect2 (`1`qSelect1 right`2`) (k-n-1)`
\end{lstlisting}
We then pull the stage \bbone\ portion of each branch of the
comparison up into a single tuple.

\begin{lstlisting} 
fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  case l of
    Empty => `2`0`1`
  | Cons (h,t) => 
      let (left,right,n) = partition h t in
      let p = `1`(h,qSelect1 left,qSelect1 right) in`2`
      case compare k n of
        LT => qSelect2 (pi2 p) k
      | EQ => pi1 p
      | GT => qSelect2 (pi3 p) (k-n-1)`
\end{lstlisting}

\ur{Don't know what ``this last step'' refers to.}
This last step is necessary, but we can perform it only because we're willing to ignore the control dependence.
We continue to pull up the precomputation and include more in it:

\begin{lstlisting} 
fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  case l of
    Empty => `2`0`1`
  | Cons (h,t) => 
      let p =
        let (left,right,n) = partition h t in
        `1`(n,h,qSelect1 left,qSelect1 right)
      in`2`
      case compare k (pi1 p) of
        LT => qSelect2 (pi3 p) k
      | EQ => pi2 p
      | GT => qSelect2 (pi4 p) (k-n-1)`
\end{lstlisting}

This completes the splitting of the cons branch.  
The empty branch can also be split, though in a trivial way:

\ur{Not clear, ``can be split'' split.  Does or doesn't (split) should be the verb?}
\begin{lstlisting} 
fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  case l of
    Empty => let p = () in `2`0`1`
  | Cons (h,t) => 
      let p =
        let (left,right,n) = partition h t in
        `1`(n,h,qSelect1 left,qSelect1 right)
      in`2`
      case compare k (pi1 p) of
        LT => qSelect2 (pi3 p) k
      | EQ => pi2 p
      | GT => qSelect2 (pi4 p) (k-n-1)`
\end{lstlisting}



To continue splitting the case statement, we need to generate a sum type in the precomputation
to remind the code what branch its in.

\begin{lstlisting} 
fun qSelect (1`l : list`) (2`k : int`) : 2`int` = 1`
  let p = 
    case l of
      Empty => Top ()
    | Cons (h,t) =>
        let (left,right,n) = partition h t in`1`
        Bot (n,h,qSelect1 left,qSelect1 right)
  in`2`
  case p of 
    Top () => 0
  | Bot p => 
      case compare k (pi1 p) of
        LT => qSelect2 (pi3 p) k
      | EQ => pi2 p
      | GT => qSelect2 (pi4 p) (k-n-1)`
\end{lstlisting}

We finish where we start, splitting \texttt{qSelect} into
\texttt{qSelect1} and \texttt{qSelect2}.  
Omitting a few type annotations, that is:

\begin{lstlisting} 
1`fun qSelect1 (l : list) = 
    case l of
      Empty => Top ()
    | Cons (h,t) =>
        let (left,right,n) = partition h t in
        Bot (n,h,qSelect1 left,qSelect1 right)
`2`
fun qSelect2 p (k : int) : int = 
  case p of 
    Top () => 0
  | Bot p => 
      case compare k (pi1 p) of
        LT => qSelect2 (pi3 p) k
      | EQ => pi2 p
      | GT => qSelect2 (pi4 p) (k-n-1)`
\end{lstlisting}


