\section{Splitting Algorithm}
\label{sec:splitting}

Although terms in \lang\ clearly distinguish their stage \bbone\ and stage
\bbtwo\ components, these components may be interleaved in complex ways. The
goal of \emph{stage splitting} is to produce from a term in \lang\ a pair of
terms in an unstaged language \langmono, which respectively perform all the
stage \bbone\ and stage \bbtwo\ subcomputations of the original term.

Since splitting stage \bbtwo\ terms is easier than splitting stage \bbone\ terms, 
we begin by describing how to split stage \bbtwo\ terms.

\subsection {Stage \bbtwo\ Splitting}

Splitting a stage \bbtwo\ term $\coltwo e A$ produces a \emph{precomputation}
term $p$ and a \emph{resumer} function $l.r$, which contain all stage \bbone\
and \bbtwo\ subcomputations of $e$, respectively. Since stage \bbtwo\
computations can depend on stage \bbone\ computations, $r$ can depend on $p$ via the variable
$l$. The correctness of splitting thus requires that $e$ is equivalent to
$\letin l p r$.

% TODO this contract works because a stage-2 term reduces to a value
% so we can simply compare (p,l.r) to that value

Splitting stage \bbtwo\ terms, as implemented by the judgment $e \splittwosym [p,l.r]$
(\cref{fig:termSplitTwo}), is guided by the structure of the term $e$. 
For example, the stage \bbtwo\ term
\begin{lstlisting}
2`hold{`1` 1+2 `2`} < (hold{`1` 3+4 `2`} - 5)`
\end{lstlisting}
has two subterms, the latter of which itself has two subterms. Two are $\pause$s
containing stage \bbone\ computations, while the third has no stage \bbone\
content. The precomputation \emph{lifts} these computations in the same tree
structure: \verb|(1+2,(3+4,()))|.%
\footnote{In later examples, we will optimize out unnecessary \texttt{()}s.}
The resumer is a function which computes the stage \bbtwo\ value of the original
term by mapping the results of the precomputation in place of the $\pause$s:
\verb|(L1,(L2,_)) => L1 < (L2 - 5)|. 

In general, constants and variables have no stage \bbone\ content, so their
precomputations are \texttt{()}, and their resumers return the original term's
value. Non-staging constructs with $n$ subterms have precomputations which are
$n$-tuples of their subterms' precomputations, and resumers which pass each
component to the resumer of the respective subterm. (This behavior at
\texttt{case} and functions causes precomputations to be lifted out from 
underneath stage \bbtwo\ binders.) The $\prev$ and $\pause$ rules depends
on splitting stage \bbone\ terms, which is covered later.

\subsection{Stage \bbone\ Splitting}

\TODO
The contract for splitting stage \bbone\ terms is more complex, because stage \bbone\ 
terms reduce to a pair of a future context and a partial value, not simply to a value.




%while maintaining the term's original structure. 

Stage \bbtwo\ values can contain no stage \bbone\ subcomputations, but the
reverse is not true of partial values (at stage \bbone). These \emph{can}
contain stage \bbtwo\ computations, both inside $\next$ blocks, which must
contain a variable reference to some future context, and inside lambdas, which
may contain a $\next$ in their body.

Thus, to split partial values, we must separate the contents of $\next$ blocks
from the rest of the term. This is implemented by the judgment $v \vsplito
[v_1,v_2]$ (\ref{fig:valSplit}). 

No dependence here.

For example, the stage \bbone\ term
\begin{lstlisting}
1`inl(3, next{`2`yhat`1`})`
\end{lstlisting}
splits into
\verb|inl(3,())| and \texttt{((),$\mathtt{\hat{y}}$)}.

sum types




In general,
at product and recursive types, splitting acts
recursively, gathering all subterms' stage $w$ content into $v_w$. At base
types, splitting assigns $v$ entirely to stage \bbone\ (and \texttt{()} to stage
\bbtwo); conversely, at $\fut$ types, splitting assigns $v$ (which must have the
form $\next~\hat y$) entirely to stage \bbtwo\ (and \texttt{()} to stage
\bbone).

This process of exposing only the relevant structure of a term at each stage is
called \emph{masking}.

Splitting a function is more complex, because function bodies are open terms,
and so are split by the judgments described in the next subsection. Essentially,
functions will split into two functions, whose bodies correspond to the stage
\bbone\ and stage \bbtwo\ components of the original function body.
Because that body may contain a precomputation, the generated function signatures must properly emit and resume with that precomputation.

%As described above, splitting a stage \bbtwo\ value always produces a trivial
%precomputation---either \texttt{()}, or nested tuples thereof. 

%Thus, it is meaningful to define some notion of splitting for them.  This is
%useful to study, because the definition will later be used as a contract with
%which general stage \bbone\ term splitting must comply.

%Recall that a partial value is externally a stage \bbone\ thing; it has a type
%$@~\bbone$, and along with a future context, it is the result of reducing a
%stage \bbone\ term. But internally, a partial value might contain stage \bbtwo\
%subexpressions.

\subsection{Stage \bbone\ Splitting}

\crem{value splitting figure is missing injections}

\TODO
\begin{enumerate}
\item Examples
\item Lifting (and masking)
\item Correctness? (Does this require partial value splitting?)
\end{enumerate}

\begin{theorem}[Correctness of splitting at $\bbone$]
If $\vdash e:A~@~\bbone$, then (by splitting)
\begin{itemize}
\item $\vdash e : A \splitonesym [c,l.r]$
\item $\reduce {c} {(v_1,u)}$
\item $\reduce {(\letin{l}{u}{r})} v_S$
\end{itemize}
if and only if (by the staged dynamic semantics)
\begin{itemize}
\item $\diaone [] e {\xi;v}$
\item $\dom \xi \vdash v \vsplito [v_1,v_2]$
\item $\reify \xi{v_2}q$
\item $q \mathbin{\tworedsym} v_D$
\end{itemize}
and if so, then $v_D \sim v_S$.
\end{theorem}

Lifting and masking are two necessary ingredients for ensuring that splitting
observes the stages of \lang. When splitting a partial value, the stage \bbone\
result must \emph{mask} the stage \bbtwo\ computations in order to be
single-staged. When splitting a stage \bbtwo\ term, the precomputation must
\emph{lift} out all embedded stage \bbone\ computations, so they can be
performed first, even though their results are only used in stage \bbtwo.
%and it's accessible to whatever surrounding piece of code refers to the value being split.
%is not accessible externally.

Splitting a stage \bbone\ term, in contrast, requires both masking and lifting.
Consider the term 
\begin{lstlisting}
1`(next{`2`hold{`1` 1+2 `2`} < 5`1`},3*4)`
\end{lstlisting}
Masking yields the stage \bbone\ computation \verb|((),3*4)|, while lifting
yields the (stage \bbone) precomputation \verb|(1+2)|. While both computations
must occur at stage \bbone, the former is needed by stage \bbone, while the
latter is needed by stage \bbtwo.

The precomputation for this term is a \emph{combined result} which is
the pair of these components: \verb|(((),3*4),1+2)|. The resumer is
likewise the pair of the stage \bbtwo\ results of lifting and masking:
\verb|fn L => (L<5,())|.
%\footnote{In this example, the combined result is a 2-tuple, but more generally
%it only must be a term which reduces to a 2-tuple.}

Splitting is implemented by the judgment $\splitonesym$,
the rules for which are given in \cref{fig:termSplitOne}.  
It operates inductively on the structure of the term.  
The $\splitonesym$ judgment sends a stage \bbone\ term $e$ to a combined term
$c$ and resumer $l.r$. 

The rule for $\next$ simply tuples up the precomputation of its subexpression with a trivial immediate result,
while the rule for $\prev$ projects the combined result of its subexpression to isolate the precomputation.
It may seem like this $\prev$ rule is throwing information away, but we well show later that the first component 
of the evaluated form of $c$ in the $\prev$ rule must always be unit.
The $\pause$ rule treats the entire combined result of its subexpression as a precomputation, 
and projects out the integer result in the resumer.%
\footnote{The resumer of an integer expression is usually trivial, 
but we have to include it here for termination purposes.}

In the splitting rules for stage \bbone\ {\tt case} expressions, we
have enough information at stage \bbone\ to know what branch to take, so there's
no need to speculate. Instead, we evaluate the stage \bbone\ portion of the
taken branch only, and inject the precomputation into a sum type. In the
resumer, we case on that injection, and resume the stage \bbtwo\ portion of the
correct branch.

\input{figures/splitting-term}

\subsection{Eliminating Unnecessary Code}

\crem{don't say ``cost''}

While these splitting rules are all correct in terms of producing the right values, applying them naively can result in terms with needlessly large cost.  Consider the following example involving the factorial function:
\begin{lstlisting}
2`prev{
  1`letfun fact (n : int) : int = 
    if n <= 0 then 1 else fact(n-1)*n
  in next{`2`hold {`1`fact 5`2`}-100`1`}`2`
}`
\end{lstlisting}

The boundary type\footnote{The splitting results are untyped, but we add in type annotations to aid the reader.} of this is give by the following datatype declaration:
\begin{lstlisting}
datatype prec = L | R of prec
\end{lstlisting}
The example then splits into the precomputation,
\begin{lstlisting}
1`letfun fact (n : int) : int * prec = 
  if n <= 0 then (1,L) 
  else let (y,z) = fact(n-1) in (y*n,R z)
in ((),fact 5)`
\end{lstlisting}
and the resumer
\begin{lstlisting}
2`l.
letfun fact (n : unit, l0 : prec) : unit = 
  case l0 of L => () | R l1 => fact ((),l0)
in (fact (#2 l); #1 l)-100`
\end{lstlisting}
The problem here is that the naive system doesn't realize that the \texttt{fact} function has no stage \bbtwo\ content,
and so it pessimistically retraces all of its steps in the resumer.  
Fixing this requires some recursive reasoning.  

We instead tried to solve the issue by adding a single new staging annotation to \lang, called \texttt{mono}.  
A \texttt{mono} block must appear in a stage \bbone\ context, and it indicates that its entire context is monostage.
This can be encoded in our statics and dynamics by adding a new stage \bbmono\ and the judgements:
\begin{mathpar}
\infer{\typesone{\monoSt~e}A}{\typesmono e A} \and
\infer{\diaone{\monoSt~e}{\cdot;v}}{\diaone{e}{\cdot;v}}
\end{mathpar}

The splitting rule for \texttt{mono} is more difficult.
The problem is that the rules needs to produce a resumer with the correct shape
for whatever the type of the \texttt{mono} is.
This is difficult in the presence of sums and general recursion,
and so we introduce a new value in our target language called dummy.
Dummy can only appear in resumers and dynamically takes the shape of whatever is required of it.

The evaluation rules for dummy values are given by:
\begin{mathpar}
\infer{e_1~e_2~\redsym~\mathtt{dummy}}{e_1~\redsym~\mathtt{dummy} & e_2~\redsym~v} \and
\infer{\unroll~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pio~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pit~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}
\end{mathpar}

Coming back to \texttt{mono}, the splitting rule is:
\begin{mathpar}
\infer{\splitone{\monoSt~e}A {e', {\tt dummy}} }{e \overset{C}{\rightarrow} e'} \and
\infer{e_1~e_2 \overset{C}{\rightarrow} \pio~(e_1'~e_2')}{e_1 \overset{C}{\rightarrow} e_1' & e_2 \overset{C}{\rightarrow} e_2'} \and
\infer{\lambda x.e \overset{C}{\rightarrow} \lambda x.(e',())}{e \overset{C}{\rightarrow} e'}
\end{mathpar}
And $\overset{C}{\rightarrow}$ operates like a map at all other terms.

Our use of {\tt dummy} is safe because
it can only appear in the resumers of terms that have no circles in their \lang\ type.
Since the $\prev$ rule requires a circle type, dummy values cannot leak from
the resumers of stage \bbone\ terms into the resumers of stage \bbtwo\ terms.

\input{figures/splitting-misc}
