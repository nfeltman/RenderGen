\section{Splitting Algorithm}
\label{sec:splitting}


\input{figures/splitting-overview}

Given a term $e$ in the source language \lang, where terms of
stage~\bbone\ and stage~\bbtwo\ may be interleaved, \emph{(stage)
  splitting} separates the stage~\bbone\ and stage~\bbtwo\
subcomputations into two terms,~$e_1$ and~$e_2$, in an unstaged target language \langmono\ 
%each performing the
%subcomputations corresponding to each stage.  More precisely, given a
%\lang\ term~$e$, splitting yields two terms $e_1$ and $e_2$ in a
%unstaged target language \langmono\
such that~$e_1$ performs all the
stage~\bbone\ subcomputations in~$e$ and~$e_2$~performs all of the
stage~\bbtwo\ subcomputations. Splitting preserves correctness in the sense that evaluating~$e$ in
the staged language produces the same result as evaluating~$e_1$ in the target language,
then further evaluating~$e_2$ in the target language with the result from~$e_1$.

In this section, we present a
splitting algorithm for the source language \lang, specifying
precisely the algorithm and its correctness conditions.  
We begin by defining a masking relation that serves to extract stage~\bbone\ and
stage~\bbtwo\ components of \lang\ partial values into \langmono\ terms that the outputs of splitting are designed to match. We then 
move on to the specification of the splitting algorithm itself.


\subsection{Masking}

% Intuitively, we require that the terms obtained by splitting a term $e$, when
% evaluated, agree with $e$ when evaluated according to our dynamic semantics. In
% the case of stage~\bbone\ terms, our dynamic semantics produce partial values
% containing information at \emph{both} stages, which goes against the idea that
% splitting separates the subcomputations belonging to each stage.

Recall that \lang\ partial values and residual tables together may
contain content at \emph{both} stages. For example the term:
\begin{lstlisting}
1`(1+2, next{`2`hold{`1`3+4`2`} + 5`1`})`
\end{lstlisting}
evaluates via $\redonesym$ to:
\begin{lstlisting}
2`[yhat|->7+5]` 1`(3,next{`2`yhat`1`})`
\end{lstlisting}
Intuitively, splitting this term should generate an~$e_1$ that reduces to the stage~\bbone\ content of the partial value \texttt{3},
and an~$e_2$ corresponding to the stage~\bbtwo\ computation: \\
$\letin \yhat {\mathtt{7+5}} \yhat$.

To precisely specify the stage~\bbone\ and stage~\bbtwo\ components of the partial value, we define 
\emph{masking} functions, written $\masko{{-};{-}}$ and $\maskt{{-};{-}}$, 
which take a residual table and partial value as input and emit a term in \langmono\
that corresponds to only the content belonging to a single stage. \ref{fig:valMask} defines these
masking functions.

\emph{Stage~\bbone\ masking} of the partial value~$v$ (written $\masko{v}$) produces a term in \langmono\ containing exactly
the stage~\bbone\ content of~$v$. Since \next\ terms only contain stage~\bbtwo\
content, $\masko{v}$ replaces all $\next$ subterms of~$v$ with \texttt{()}.  Since lambdas may represent multi-stage computations, stage~\bbone\ masking splits their bodies as general stage~\bbone\ terms (as described in \ref{sec:split-one}), and returns
the stage~\bbone\ component. $\masko{v}$ always produces a value in \langmono\ that has
the same structure as~$v$.  For example, the stage~\bbone\ mask of the partial value given above is \texttt{(3,())}. 

\emph{Stage~\bbtwo\ masking} of the partial value $v$ and residual context~$\xi$ (written $\maskt{\xi;v}$) produces a term in \langmono\ containing
exactly the stage~\bbtwo\ content of $[\xi;v]$. Unlike stage~\bbone\ masking, stage~\bbtwo\ masking 
requires access to the residual table $\xi$ because all stage~\bbtwo\
content in~$v$ has been lifted out into~$\xi$. Stage~\bbtwo\ masking discards
stage~\bbone\ content in~$v$ by replacing base constants with~\texttt{()},
replacing $\next~\hat{y}$ with~$\hat{y}$, and replacing all $n$-ary term
constructors with an $n$-tuple of masked subterms. Like stage~\bbone\ masking, stage~\bbtwo\
masking splits the bodies of lambdas as general stage~\bbone\ terms, and
returns the stage~\bbtwo\ component. After discarding all stage~\bbone\ content from~$v$, stage~\bbtwo\ masking reifies $\xi$ around the result,
producing a term in \langmono. For example, the stage~\bbtwo\ mask of the partial value and residual table given above is:
\begin{lstlisting}
let yhat=7+5 in ((),yhat)
\end{lstlisting}

\subsection{Stage \bbone\ Term Splitting}
\label{sec:split-one}

Splitting a stage~\bbone\ term $e$ in \lang\ yields a term 
$e_1$ that performs all stage~\bbone\ subcomputations in $e$ and a \emph{resumer} function $e_2 = l.r$ that performs all stage~\bbtwo\ subcomputations.
To ensure that the results of splitting produce the same output as the evaluation $e\mathbin{\redonesym}[\xi;v]$,
we require that $e_1$ reduce to the tuple $(y,b)$,
where $y$ is identical to $\masko{\xi;v}$, and 
$\letin l b r$ reduces to the same value as $\maskt{\xi;v}$. Since~$e_1$ performs both stage~\bbone\ subcomputations needed to produce $y$ (a value we call the \emph{stage~\bbone\ result}), and the stage~\bbone\ subcomputations (called \emph{precomputations}) that produce the \emph{boundary value} $b$ required by the resumer, we refer to this term as the \emph{combined term}, and hereafter denote it as $c$.

The splitting algorithm for stage~\bbone\ terms, as specified by the
judgment $e \splitonesym [c,l.r]$ in \cref{fig:termSplitOne}, proceeds
recursively on the structure of~$e$.
When $e$ is a terminal (a variable or base constant)
splitting yields a combined term formed by tupling $e$ with a \texttt{()} precomputation, and the trivial resumer \texttt{()}. (Stage~\bbone\ terminals, by definition, contain no stage~\bbtwo\ subcomputations.)  For example, the integer constant \texttt{3} splits into the combined term \texttt{(3,())} and resumer \texttt{\_=>()}.

% Note the direct correspondence of these splitting outputs to the output of the stage~\bbone\ and~\bbtwo\ masking functions.

For all non-terminals (except $\next$),
splitting descends into $e$, recursively splitting its $n$ subterms
to produce their respective combined terms $c_1,\ldots,c_n$ and resumers $r_1, \ldots, r_n$.
The combined term of $e$ is formed by binding $c_1,\ldots,c_n$
to the patterns $(y_1,b_1),\ldots,(y_n,b_n)$
to isolate \bbone-results from boundary values. Then,
the \bbone-result of $e$ is formed by replacing $e$'s subterms with $y_1,\ldots,y_n$.
The resumer binds the boundary values $b_1,\ldots,b_n$ to an
argument $(l_1,\ldots,l_n)$ in a term that has the same structure
of~$e$ but where each subterm is replaced by its resumer ($r_i$'s).

Splitting {\tt case} yields a combined term that executes one of the branches' combined terms based on the \bbone-result $y_1$ of the predicate.
The boundary value $b_i$ for this branch is injected and bundled with that of the predicate ($b_1$).   
$b_i$ is cased in the resumer to determine which branch's resumer should be executed.
{\tt case} and $\pause$ are the only two rules where splitting adds non-trivial logic is added to the precomputation.

Function introduction has a \texttt{()} boundary value,
since functions are already fully reduced in our semantics.
However, since the body of a function may itself be multi-stage, splitting must continue into it.
The \bbone-result is a new function formed from the stage~\bbone\ part of the original body.
The resumer is a new function formed out of the stage~\bbtwo\ part of the original body.
It is the responsibility of the application site to save the precomputation of the function body
and pass it to the resumer version of the function.

Since the results of splitting $\next$ terms depend on the output of splitting its stage~\bbtwo\ subterm,
we defer description of $\next$ until after describing stage~\bbtwo\ term splitting.

\subsection{Stage \bbtwo\ Term Splitting}

Because stage~\bbtwo\ terms in \lang\ fully reduce to values (as opposed to partial values),
splitting stage~\bbtwo\ terms in \lang\ assumes a simpler form than that of stage~\bbone\ term splitting. 
Specifically, splitting a stage~\bbtwo\ term $e$ in \lang\ generates a precomputation term $p$
(performing all stage~\bbone\ subcomputations in $e$) and a
resumer function $e_2=l.r$ (performing all stage~\bbtwo\ subcomputations) such that when 
$e$ reduces to the value~$v$, $\letin l p r$ reduces to an identical value in \langmono.
Note that in contrast to the combined term produced during stage~\bbone\ splitting,
the precomputation $p$ generated by stage~\bbtwo\ splitting exists entirely
to compute the input expected by the resumer.

% \ur{I don't quite understand the following.}
% (Thus, the resumer, bound to the value output by $p$, is equivalent to
% the residual term defined in~\ref{ssec:dynamics})

As with stage~\bbone\ terms, the splitting algorithm for stage~\bbtwo\ terms,
as specified by the judgment $e \splittwosym [p,l.r]$ in \cref{fig:termSplitTwo}, is defined on the local structure of $e$.
In the terminal cases of
constants and variables, splitting generates trivial precomputations that are \texttt{()}, and resumers consisting of the original term.
For example, the integer constant \texttt{3} splits into the
precomputation \texttt{()} and resumer \texttt{\_=>3}.

For all non-terminal terms~$e$ in \lang\ (except $\prev$
and $\pause$)
% recursively splitting
% subterms and generating precomputations $p_1, \ldots, p_n$ and
% resumers $r_1, \ldots, r_n$ for a term with~$n$ immediate subterms.
the precomputation of~$e$ is defined as the combined precomputations of $e$'s $n$ subterms:
$p=(p_1,\ldots,p_n)$.  The resumer binds each boundary value to an
argument $(l_1,\ldots,l_n)$ in a term that has the same structure
of~$e$ but where each subterm is replaced by its corresponding resumer $r_i$.

A notable properly of splitting stage~\bbtwo\ \texttt{case}s and functions is that the
precomputation of subterms is lifted out from underneath stage
\bbtwo\
binders.  % TODO: should probably draw a parallel to the same behavior in dynamics
\ur{This last point seems important.  It would be important to come
  back to it.}

Splitting $\prev$ generates a precomputation that projects the \bbone-result of its stage~\bbone\ subterm.
Since the argument to $\prev$ is of $\fut$ type, its \bbone-result reduces to \texttt{()}, justifying why it can be thrown away.
$\pause$ treats the entire combined term of its stage~\bbone\ subexpression as a precomputation, 
and projects out the integer result in the resumer. 
\footnote{The resumer of an integer expression is usually trivial, 
but we have to include it here for termination purposes.} 
Finally, splitting $\next$ simply tuples up the precomputation of its stage~\bbtwo\ subterm with a trivial \bbone-result \texttt{()}.

\input{figures/splitting-term}

\subsection{Optimization: Monostage Functions}

\textbf{KF: the missing point here is that the splitting algorithm was designed based on the local structure of \lang\ terms.
To make the algorithm derivation case compelling,
we need to optimize away some of that structure.  But this is hard to do through functions.}

The above splitting rules are correct, but can be optimized in many cases. 
For instance, if multiple subterms have a \texttt{()} precomputation, these can be
combined into a single \texttt{()}, with the residual changed accordingly.
This becomes more difficult to fix when it occurs within a recursive function.
For example, consider the stage~\bbtwo\ term
\begin{lstlisting}
2`prev{
  1`letfun fact (n : int) : int = 
    if n <= 0 then 1 else fact(n-1)*n
  in next{`2`hold {`1`fact 5`2`}-100`1`}`2`
}`
\end{lstlisting}
which splits into:
\begin{lstlisting}
1`letfun fact (n : int) : int * prec = 
  if n <= 0 then (1,L) 
  else let (y,z) = fact(n-1) in (y*n,R z)
in fact 5`

2`l => 
letfun fact (n : unit, l0 : prec) : unit = 
  case l0 of L => () | R l1 => fact ((),l0)
in (fact (pi2 l); pi1 l)-100`
\end{lstlisting}
Here, the stage \bbone\ function \texttt{fact} splits into two recursive
functions, which compute a combined result (stage \bbone\ result and
precomputation), and a stage \bbtwo\ result, respectively. This precomputation
could be given the type
\begin{lstlisting}
datatype prec = L | R of prec
\end{lstlisting}
while the stage \bbtwo\ result is always \texttt{()}.

It is wasteful to run the stage \bbtwo\ version of \texttt{fact}, since it
always returns \texttt{()}; worse yet, it has linear runtime!
But optimizing this away is in general a global operation,
so we instead solve this issue by adding a new staging annotation to \lang, called
\texttt{mono}. The term $\monoSt~e$ is stage \bbone, and requires that $e$ contains
no stage \bbtwo\ subexpressions. This adds a new stage \bbmono\ and two new
rules to \lang:
\begin{mathpar}
\infer{\typesone{\monoSt~e}A}{\typesmono e A & A~\mathrm{safe}} \and
\infer{\diaone{\monoSt~e}{\cdot;v}}{\diaone{e}{\cdot;v}}
\end{mathpar}
Here, the ``safe" judgment requires that $A$ has no $\to$ types in negative position.
Intuitively, this is to ensure that stage \bbtwo\ code cannot be substituted into a monostage region.

To split \texttt{mono} terms, we must produce a resumer with the correct shape
for the enclosed term. This is difficult to produce statically, because the
language has sums and general recursion. We instead produce it dynamically,
using a new value in \langmono, \texttt{dummy}, which can be consumed as though
it had any type:
\begin{mathpar}
\infer{e_1~e_2~\redsym~\mathtt{dummy}}{e_1~\redsym~\mathtt{dummy} & e_2~\redsym~v} \and
\infer{\unroll~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pio~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pit~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}
\end{mathpar}
The splitting rules are then
\begin{mathpar}
\infer{\splitone{\monoSt~e}A {(e',()), \_.{\tt dummy}} }{e \overset{C}{\rightarrow} e'}
\end{mathpar}
Here, $\overset{C}{\rightarrow}$ translates functions to the signature expected for stage \bbone\ splitting outputs
by performing the two rewrites in place:
\begin{align*}
\lam x A e &\overset{C}{\rightarrow} \lambda x.(e,())\\
e_1~e_2 &\overset{C}{\rightarrow} \pio~(e_1~e_2)
\end{align*}
For $\splitone e A {c,l.r}$, \texttt{dummy} can only appear as the 
final value of $r$ when $e$ has no $\fut$ in its \lang\ type.
Since the $\prev$ rule requires a circle type, \texttt{dummy} values cannot leak 
into the resumers of stage \bbtwo\ terms.

\input{figures/splitting-misc}

% \subsection{Implementation}
%
% \crem{Say something about the implementation.}

