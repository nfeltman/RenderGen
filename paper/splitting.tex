%!TEX root = paper.tex

\section{Splitting Algorithm}
\label{sec:splitting}

\begin{abstrsyn}

The goal of a stage splitting translation 
is to send a program $\mathcal P$ in a multistage language
to an equivalent form $\mathcal P'$ where the stages are seperated at the top level.
More specifically, $\mathcal P$ and $\mathcal P'$ should produce 
the same answer under their respective semantics.

Since \lang\ has three classes of multistage term, 
our splitting algorithm has three forms: 
$\splittwo e A p l r$ for \bbtwo-terms, 
$\splitone e A c {l.r}$ for \bbonem-terms, and 
$v \vsplito \mval i q$ for partial values.
In each form the output has two parts, corresponding to the
first-stage ($p$, $c$, and $i$) and second-stage ($l.r$, and $q$) content of the input.
Note that there's no need to provide forms of splitting for ground terms or residuals,
since those classes of term are already monostage by construction.

The rules of the three splitting judgements are given in \ref{fig:termSplit}.
Since the rules are simply recursive on the structure of the term, 
the splitting algorithm runs in linear time on the size of the input program.
Splitting is defined for all well-typed inputs (\ref{thm:total}), and it produces unique results (\ref{thm:unique}).
That is, each splitting judgement defines a total function.

\begin{theorem} [Splitting Totality] \leavevmode
\label{thm:total} 
\begin{itemize} 
\item For term $e$, if $\typestwo e A$, then $\splittwo e A p l r$. 
\item For term $e$, if $\typesone e A$, then $\splitone e A c {l.r}$.
\item For partial value $v$, if $\typesone v A$, then $v \vsplito \mval i q$.
\end{itemize}
\end{theorem}

\begin{theorem} [Splitting Uniqueness] \leavevmode
\label{thm:unique}
\begin{itemize} 
\item If $\splittwo e A p l r$ and $\splittwo e A {p'} {l'} {r'}$, then $p = p'$, and $l.r = l'.r'$.
\item If $\splitone e A p {l.r}$ and $\splitone e A {c'} {l'.r'}$, then $c = c'$, and $l.r = l'.r'$.
\item If $v \vsplito \mval i q$ and $v \vsplito \mval {i'} {q'}$, then $i = i'$ and $q = q'$.
\end{itemize}
\end{theorem}

We prove these theorems by straightforward induction on the typing derivation
and simultaneous induction on the splitting derivations, respectively.

\subsection{Outputs of Splitting}

Splitting a top level program $\coltwo e A$, via $\splittwosym$, yields $\pipeS p l r$.
Like $e$, this output is evaluated in two passes.
The first pass reduces $p$ to the value $b$ and plugs this result in for $l$ to produce $[b/l]r$;
the second pass evaluates $[b/l]r$.
The relationship between the two stages in this case is thus like a pipeline,
which is why we write them with a `\mytt{|}' in between.
Since execution of the first pass serves to generate input for
the second pass, we say $p$ is a {\em precomputation} that produces a
{\em boundary value} ($b$) for the {\em resumer} ($l.r$).

Splitting a partial value $v$, via $\vsplito$, yields $\mval i q$.
Since partial values, by definition, have no remaining work in the first pass
and since transfer of information between the stages occurs in the first pass of evalution,
we know that the second stage components of $v$ can no longer depend on its first stage components.
Analogously, this must also hold for the output of splitting, 
which is why $q$---unlike the resumer of world \bbtwo\ term splitting---is not open on a variable.
Thus, $i$ and $q$ are operationally independent, but they represent the complementary portions of $v$ that are relevant to each stage.
We call $i$ the \emph{immediate value} and $q$ the residual.

For any $\colmix e A$, splitting $e$ via $\splitonesym$ yields the pair of monostage terms $\pipeM c l r$. 
This output form is essentially a hybrid of the previous two.
Because $e$ is a term, $c$ needs to produces a boundary value $b$ to be passed to the resumer ($l.r$)
And since $e$ types at world \bbonem, it has an eventual result at the 
first stage as well as the second, and so it must produce an immediate value $i$.
The term $c$ meets both of these responsibilities by reducing to the tuple $\tup{i,b}$,
and so we call it a \emph{combined term}.

\subsection{World \bbtwo\ Term Splitting}

The dynamic correctness of the splitting translation requires that the simple 
evaluate-and-plug semantics on the output produces the same answer as the staged semantics of the previous section.
That is, $[b/l]r$ (the \emph{applied resumer}) should be equivalent 
to the residual $q$ produced by direct evaluation, $e \stepsym \bbtwo \cdots \stepsym \bbtwo \exv q$.
This condition is stated more precisely as \ref{thm:allCorrect},
where ``$\reduce e v$'' indicates standard monostage reduction of the term $e$ to the value $v$,
and ``$\equiv$'' indicates a monostage equivalence, which we cover later.

\begin{theorem} [End-to-End Correctness]
\label{thm:allCorrect}
If $\typestwo [\cdot] e A$, $e \stepsym \bbtwo \cdots \stepsym \bbtwo \exv q$, and $\splittwo e A p l r$,
then $\reduce p b$ and $[b/l]r \equiv q$.
\end{theorem}

We prove \ref{thm:allCorrect} by induction on the steps of evaluation.  
In the base case, where $e$ is already a residual of the form $\exv q$, we know
$\splittwo {\exv q} A {\exv{\tup{}}} \_ q$, so by uniqueness of splitting, 
$p = \tup{}$ and $r = q$.
From here, we can directly derive $\reduce {\exv {\tup {}}} {\tup {}}$ and $q \equiv q$.

In the recursive case, where the evaluation takes at least one step, we have 
$e \stepsym \bbtwo e' \stepsym \bbtwo \cdots \stepsym \bbtwo \exv q$
as well as \mbox{$\typestwo [\cdot] e A$} 
and \mbox{$\splittwo e A p l r$}.
By preservation and totality of splitting, we know $\typestwo [\cdot] {e'} A$ and $\splittwo {e'} A {p'} {l'} {r'}$.
From here, the inductive hypothesis yields $\reduce {p'} {b'}$ and $[b'/l']r' \equiv q$.
All that we now require is $\reduce p b$ and $[b/l]r \equiv [b'/l']r'$,
To close this gap we introduce \ref{lem:twoCorrect}, 
which essentially states that any single step is correct,
and whose proof will concern the rest of this section.

\begin{lemma} [Single Step Correctness]
\label{lem:twoCorrect}
\begin{itemize} 
\item If $e \stepsym \bbtwo e'$, $\splittwo e A p  l r$, $\splittwo {e'} A {p'} {l'} {r'}$, and $\reduce {p'} {b'}$,
then $\reduce p b$ and $[b/l]r \equiv [b'/l']r'$.
\item If $e \stepsym \bbonem e'$, $\splitone e A c {l.r}$, $\splitone {e'} A {c'} {l'.r'}$, and $\reduce {c'} {\tup{i,b'}}$,
then $\reduce c {\tup {i,b}}$ and $[b/l]r \equiv [b'/l']r'$.
\end{itemize}
\end{lemma}

After invocation of that new lemma, we can derive $[b/l]r \equiv [b'/l']r' \equiv q$ directly.
In order to prove \ref{lem:twoCorrect},
we will need to state analogous version for steps at \bbonem,
since the various kinds of multistage term in \lang\ are mutually dependent.
Thus, this section proceeds by covering the definition of splitting at \bbonem, 
starting with the value form at that world.

\subsection{Partial Value Splitting}
\label{sec:masking}

To provide intuition about the behavior of partial value splitting, consider the
following partial value:
\begin{lstlisting}
1` (next{`2`y`1`}, (`3`gr{`1`injL 7`3`}`1`, next{`2`y`1`}))`
\end{lstlisting}
To construct the value $i$ representing its first-stage components,
splitting first redacts all second-stage (blue) parts, along with the
surrounding \texttt{next} annotations. 
The resulting ``holes'' in the term are replaced with
unit values.
%\begin{lstlisting}
%4`##########`1` (`4`######`1`, injL (gr{7}, `4`######`1`))`
%\end{lstlisting}
%The holes inside the term needs to be filled with something to convey the lack of information, so we use a unit values:
\begin{lstlisting}
1`((), (3`gr{`1`injL 7`3`}`,()))`
\end{lstlisting}
Finally, partial value splitting drops \texttt{gr} annotations, yielding:
\begin{lstlisting}
1`((), (injL 7,()))`
\end{lstlisting}
To construct the residual $q$ (corresponding to second-stage computations) partial value splitting redacts all \texttt{gr} blocks
(replacing them with unit) and \texttt{next} annotations:
\begin{lstlisting}
2`(y, ((),y))`
\end{lstlisting}
A precise definition of the partial value splitting relation is given in
\ref{fig:termSplit}.

In some regards, the exact formulation of partial value splitting is arbitrary.
For instance, we chose to replace ``holes'' with unit values,
but in fact we could have used any value there and it would make no difference in the end.
There are however, at least some parts of the definition that are not arbitrary.
Importantly, partial value splitting must not lose any meaningful information,
such as injection tags.

%Since lambdas may represent multi-stage computations, masking splits
%the body of lambdas as general world \bbonem\ terms (as described in
%\ref{sec:split-one}), and packages the resulting terms as functions in
%both the first- and second-stage parts of the masked value.

% Masking operates by first inducting on the entries of the residual table.  
% Being purely second-stage content, these are reified into let statements at the top of the resumer.
% Once the table is empty, masking inducts on value itself.

% Masking assigns ground values to the immediate value
% and likewise assigns references into the residual table to the resumer.
% In both cases, the alternate component is assigned to $\tup{}$, to represent trivial information.
% Note that the \texttt{gr} and \texttt{next} annotations are erased.

% Masking distributes into tuples, injections, and rolls, since their subvalues may have content at both stages.
% However, the tags of injections and rolls are replicated only in the immediate value, 
% since they represent first-stage information.

\subsection{World \bbonem\ Term Splitting}

The correctness of \bbonem\ term splitting with respect to a $\stepsym \bbonem$ step is given in \ref{lem:oneCorrect}.
It's very similar to the world \bbtwo\ version, 
in that the reduction of the first stage part of $e'$ should imply reduction of the first stage part of $e$,
and that the resulting applied resumers should be equivalent.
But split forms at \bbonem\ have one more piece of output than those at \bbtwo,
namely the immediate value $i$.
\ref{lem:oneCorrect} accounts for this by saying that 
that immediate value must be exactly identical on both sides of the step.

The correctness of \bbonem\ term splitting with respect to hoisting steps is given in \ref{lem:hoistCorrect}.
Because hoisting steps are nothing but rearrangement of second stage code,
this lemma can use the strong requirement of identical combined terms.

\begin{lemma} [Hoisting Step Correctness]
\label{lem:hoistCorrect}
If $\lift e {e'}$, $\splitone e A c {l.r}$, and $\splitone {e'} A {c'} {l'.r'}$, then $c = c'$, and $l.r \equiv l'.r'$.
\end{lemma}

\subsection{Example cases.}

In this section, we consider a few exemplar cases 
from the proofs of \ref{lem:oneCorrect} and \ref{lem:twoCorrect}.
The equivalence relation ``$\equiv$'' is defined in \ref{fig:equiv}.

\paragraph{Reduction of {\tt pi1}.}
Define $E = \pio {\exv{\tup {v_1,v_2}}}$ and  
$C = \letin{\tup{y,z}}{\exv{\tup{\tup {i_1,i_2},\tup{}}}}{\tup{\pio {\exv y},\exv z}}$.
We are given $\stepmix  E {\exv {v_1}}$,
$\splitone E A C {l.\pio {\exv {\tup{q_1,q_2}}}}$, and
$\splitone {\exv {v_1}} A {\exv {\tup{i_1,\tup{}}}} {\_.\exv{q_1}}$,
and we need to show $\reduce C {\tup {i_1,\tup{}}}$
and $\pio {\exv {\tup{q_1,q_2}}} \equiv q_1$.
Both of these can be derived directly.
This pattern, where the outputs can be directly derived, extends to the {\tt pi2} and {\tt prev} reduction rules and all value marking rules.

\paragraph{Reduction of Application.} Let $E = \app {\exv{\fix f x e}} {\exv v}$,
$E' = [\fix fxe, v/f,x] e$, \\ 
$I = \fix f x {\letin {\tup{x,y}} c {\tup{x,\roll y}}}$,
$Q = \fix f {\tup{x,\roll l}} r$, and \\
$C = \left[
\talllet{\tup{y_1,z_1}}{\exv {\tup {I,\tup{}}}}{
\talllet{\tup{y_2,z_2}} {\exv {\tup {i_1,\tup{}}}}{
\talllet{\tup{y_3,z_3}}{\app{\exv {y_1}}{\exv {y_2}}}{\exv{\tup{y_3,\tup{z_1,z_2,z_3}}}\ttrpar\ttrpar\ttrpar}}}\right]$.
\\
We are given $\stepmix E {E'}$,
$\splitone E A C {\tup{\_,\_,l}.\app{\exv Q}{\exv{\tup{q_1,l}}}}$,
$\splitone {E'} A {[I,i_1/f,x]c} {l.[Q,q_1/f,x]r}$,
and $\reduce {[I,i_1/f,x]c} {\tup{i,b}}$.
From this, we can directly derive $\reduce C {\tup{i,\tup {\tup{},\tup{},\roll b}}}$
and $\app{\exv Q}{\exv{\tup{q_1,\roll b}}} \equiv [Q,q_1,b/f,x,l] r$.
This pattern applies to all of the other reduction rules involving substitution,
namely those for {\tt caseg}, and {\tt letg}. 
Observe that, in our formal version of the language, 
{\tt caseg} is the only construct where information is added to the boundary value.

\paragraph{Compatibility of {\tt pi1} at \bbtwo.}
We are given 
$\steptwo {\pio e} {\pio {e'}}$, 
$\splittwo {\pio e} A p l {\pio r}$, 
$\splittwo {\pio {e'}} A {p'} {l'} {\pio {r'}}$,
and $\reduce {p'} {b'}$.
Inversion of the first three yields
$\steptwo e {e'}$, $\splittwo e A p l r$, and $\splittwo {e'} A {p'} {l'} {r'}$.
Using \ref{lem:twoCorrect} inductively gives $\reduce p b$ and $[b/l]r \equiv [b'/l']r$.
From this, $[b/l]\pio r \equiv [b'/l']\pio {r}$ can be derived directly.
This pattern generalizes to all world \bbtwo\ compatibility rules.

\paragraph{Compatibility of {\tt pi1} at \bbonem.}
We are given
$\stepmix {\pio e} {\pio {e'}}$, 
$\splitone {\pio e} A {\letin{\tup{y,z}}{c}{\tup{\pio {\exv y},\exv z}}} {l.\pio r}$, \\
\mbox{$\splitone {\pio {e'}} A {\letin{\tup{y,z}}{c'}{\tup{\pio {\exv y},\exv z}}} {l'.\pio {r'}}$},
and \\ $\reduce {\letin{\tup{y,z}}{c'}{\tup{\pio {\exv y},\exv z}}} {\tup{i,b'}}$.
Inversion of the first three yields 
$\stepmix e {e'}$, $\splitone e A c {l.r}$, and $\splitone {e'} A {c'} {l'.r'}$, 
and inversion of the reduction yields $\reduce {c'} {\tup{\tup{i,i_2},b'}}$.
Using \ref{lem:oneCorrect} inductively gives $\reduce c {\tup{\tup{i,i_2},b}}$ and $[b/l]r \equiv [b'/l']r$.
From this, we can derive $\reduce {\letin{\tup{y,z}}{c}{\tup{\pio {\exv y},\exv z}}} {\tup{i,b}}$ and 
$[b/l]\pio r \equiv [b'/l']\pio {r}$ directly.
This pattern generalizes to all world \bbonem\ compatibility rules.

\paragraph{Compatibility of {\tt gr}.}
We are given 
$\stepmix {\pure e} {\pure {e'}}$, \\
$\splitone {\pure e} A {\tup {e,\exv {\tup{}}}} {\_.\exv{\tup{}}}$, 
$\splitone {\pure {e'}} A {\tup {e',\exv {\tup{}}}} {\_.\exv{\tup{}}}$,
and $\reduce {\tup {e',\exv {\tup{}}}} {\tup{i,\tup{}}}$.
Inversion of the step and reduction yield \mbox{$\steppure e {e'}$} and $\reduce {e'} i$.
As a simple property of monostage reduction (which $\stepsym \bbonep$ is), we know $\reduce e i$.
From here, we can derive $\reduce {\tup {e,\exv {\tup{}}}} {\tup{i,\tup{}}}$ and $\exv{\tup {}} \equiv \exv{\tup {}}$ directly.



% \subsection{Term Splitting at \bbonem}
% \label{sec:split-one}

% Given the definition of masking, we now describe how to split
% \bbonem\ terms. The algorithm, given in \cref{fig:termSplit}, proceeds
% recursively on the structure of~$e$. We derive a few cases here.

% \paragraph {Unit.} 
% As a simple first case, consider splitting the unit value, $\tup{}$
% which masks to $\mval {\tup{}} {\tup{}}$.
% %Units trivial contain unit split into more units: $\tup{} \vsplito \mval {\tup{}} {\tup{}}$.
% Splitting must produce a $c$ and $l.r$ satisfying
% \[
% 	\reduce c {\tup{\tup{},b}} \text{ and } [b/l]r \equiv \tup{}
% \]
% Our algorithm uses $c=\tup{\tup{},\tup{}}$ and $l.r = \_.\tup{}$.
% Splitting $\pure{e}$ follows in similar fashion, except the first 
% component of $c$ now becomes the result of evaluating the \bbonep\ term $e$.

% \paragraph {Injections.}
% Now consider splitting the non-terminal $\inl {e}$, where $\diaone
% {e} \xi v$ and $\rtab \xi v \vsplito \mval i q$, and thus:
% \[
% 	\splitone e A c {l.r} \text{ and } \reduce c {\tup{i,b}} \text{ and } [b/l]r \equiv q
% \]
% Since $\diaone {\inl e} \xi {\inl v}$ and $\rtab \xi {\inl v} \vsplito \mval {\inl i} q$,
% splitting must produce a $c'$ and $l.r'$ satisfying
% \[
% 	\reduce {c'} {\tup{\inl i,b'}} \text{ and } [b'/l]r' \equiv q
% \]
% Our algorithm generates a first pass $c'$ that produces the same
% boundary value as splitting $e$:
% \[
% c' = \letin {\tup {x,y}} c {\tup{\inl x, y}}
% \]
% Splitting the injection also generates the same resumer as splitting
% the subterm $e$ (that is, $l.r' = l.r$).

% \paragraph{Tuple.} For an example of splitting terms with more than one argument, consider the tuple $\tup{e_1,e_2}$,
% where $\diaone {e_k} {\xi_k} {v_k}$ and 
% $\rtab {\xi_k} {v_k} \vsplito \mval {i_k} {q_k}$ for $k = 1,2$.  
% Inductively:
% \[
% 	\splitone {e_k} A {c_k} {l_k.r_k} \text{ and } \reduce {c_k} {\tup{i_k,b_k}} \text{ and } [b_k/l_k]r_k \equiv q_k
% \]
% Since $\diaone {\tup{e_i,e_2}} {\xi_1,\xi_2} {\tup{v_1,v_2}}$ 
% and $\rtab {\xi_1,\xi_2} {\tup{v_1,v_2}}$ and $\tup{v_1,v_2} \vsplito \mval {\tup{i_1,i_2}} {\tup{q_1,q_2}}$,
% splitting generates:
% \[
% 	\reduce {c} {\tup{\tup{i_1,i_2},b}} \text{ and } [b/l]r \equiv \tup{q_1,q_2}
% \]
% The resulting boundary value is the tuple of the boundary values of
% the subterms, $b = \tup{b_1,b_2}$.  The value is 
% constructed using
% \[
% c = \letin{\tup{y_1,z_1}}{c_1}{\letin{\tup{y_2,z_2}}{c_2}{\tup{\tup{y_1, y_2},\tup{z_1, z_2}}}}
% \]
% and deconstructed in the resumer with a tuple pattern:
% \[
% l.r = \tup{l_1,l_2}.\tup{r_1,r_2}
% \]
% \paragraph {Case.}
% Splitting is most complicated at $\caseof {e_1} {x_2.e_2} {x_3.e_3}$ terms because of their divergent control flow.
% Here we consider only the case where
% $\diaone {e_1} {\xi_1} {\inl {v_1}}$ and \\ $\rtab {\xi_1} {\inl {v_1}} \vsplito \mval {\inl {i_1}} {q_1}$.
% (The \texttt{inr} case is analogous.)

% \noindent
% Inductively,
% \[
% 	\splitone {e_1} A {c_1} {l_1.r_1} \text{ and } \reduce {c_1} {\tup{\inl {i_1},b_1}} \text{ and } [b_1/l_1]r_1 \equiv q_1
% \]
% Additionally, the first branch evaluates $\diaone {[v_1/x_2]e_2} {\xi_2} {v_2}$
% and $\rtab {\xi_1,\xi_2} {v_2} \vsplito \mval {i_2} {q_2}$.
% Therefore:
% \begin{gather*}
% 	\splitone {e_2} A {c_2} {l_2.r_2} \text{ and } \reduce {[i_1/x_2]c_2}
%   {\tup{i_2,b_2}} \\
% \text{ and } [q_1/x_2][b_2/l_2]r_2 \equiv q_2
% \end{gather*}
% (Because $e_2$ is open on $x_2$, $\pipeM{c_2}{l_2}{r_2}$ is also open on $x_2$.
% When we substitute some $v_1$ for $x_2$ in $e_2$, we must substitute the masks
% of $v_1$ into $c_2$ and $l_2.r_2$.)

% The entire case evaluates as
% $\diaone {\caseof {e_1} {x_2.e_2} {x_3.e_3}} {\xi_1,\xi_2} {v_2}$, so splitting should produce 
% some $c'$ and
% $l'.r'$ such that 
% \[
%   \reduce {c'} {\tup{i_2,b'}} \text{ and }
%   [b'/l']r' \equiv q_2
% \]
% We choose
% \[
% c' =
% {\left(
% \talllet{\tup{y_1,z_1}}{c_1}{
% \tallcase{y_1}
% {x_2.\letin{\tup{y_2,z_2}}{c_2}{\tup{y_2,\tup{z_1,\inl{z_2}}}}}
% {x_3.\cdots\ttrpar}
% }\right)}
% \]
% \[
% l'.r' =
% \tup{l_1,l_b}.\letin{z}{r_1}{\caseof{l_b}{l_2.[z/x_2]{r_2}}{l_3.\cdots}}
% \]
% The term $c'$ reduces to
% $\tup{i_2,\tup{b_1,\inl{b_2}}}$, so 
% $b' = \tup{b_1,\inl{b_2}}$. Therefore
% $[b'/l']r'$ reduces to
% $[[b_1/l_1]r_1/x_2][b_2/l_2]r_2$, exactly the 
% $[q_1/x_2][b_2/l_2]r_2$ required.

% More intuitively, $c'$ cases on $i_1$ to run the first branch of first-stage
% code. The boundary value for that branch, $b_2$, is packaged as $\tup {b_1, \inl
% {b_2}}$. The resumer of the predicate uses $b_1$, and $\inl{b_2}$ signals to run
% the first branch's resumer. The second branches of $c'$ and $l'.r'$ are
% similarly constrained by the $\texttt{inr}$ case.

% %Recovering first stage divergence is easy, since for $\splitone {e_1} ? {c_1} {l_1.r_1}$, 
% %$\reduce {e_1} {\inl {v_1}}$ implies $\reduce {c_1} {\tup{\inl {i_1},b_1}}$.

% \paragraph {Function.} 
% Function introduction has a $\tup{}$ boundary value, since functions
% are already fully reduced in our semantics.  However, since the body
% of a function may itself be multistage, splitting must descend into
% it.  The first pass generated by splitting produces an $i$ that is a new
% function formed from the first-stage part of the original body.  The
% resumer is a new function formed out of the second-stage part of the
% original body.  It is the responsibility of the application site to
% save the precomputation of the function body and pass it to the
% resumer version of the function.

% \subsection{Term Splitting at \bbtwo}

% Because world \bbtwo\ terms in \lang\ reduce to monostage residuals
% (as opposed to partial values), term splitting at world
% \bbtwo\ (specified by the $\splittwosym$ relation in
% \cref{fig:termSplit}) is simpler than that of \bbonem.

% Consider any $n$-ary \bbtwo-term $e = \scriptCapp {e_1 \ttsemi \ldots
%   \ttsemi e_n}$ (except \texttt{prev}, which is discussed shortly).
% Note that for any $\diatwo e q$, the residual $q$ must have the form
% $\scriptCapp {q_1 \ttsemi \ldots \ttsemi q_n}$, even if $\mathcal{C}$ is
% nullary or the $q_i$ have binders.
% For each $k$, splitting the subterm $e_k$ yields $p_k$ and $l_k.r_k$ where
% \[
% 	\reduce {p_k} {b_k} \text{ and } [{b_k}/{l_k}]{r_k} \equiv {q_k}
% \]
% Correspondingly, splitting $\scriptCapp {e_1 \ttsemi \ldots \ttsemi e_n}$ generates $p$ and $l.r$ where
% \[
% 	\reduce p b \text{ and } [b/l]r \equiv \scriptCapp {q_1 \ttsemi \ldots \ttsemi q_n}
% \]
% Our algorithm accomplishes this by using $p = \tup {p_1, \ldots, p_n}$ and
% $l.r = \tup {l_1, \ldots, l_n}.\scriptCapp {r_1 \ttsemi \ldots \ttsemi r_n}$.

% %Again, this holds even for nullary terms and under binders.
% In particular, $\caseof{e_1}{x_2.e_2}{x_3.e_3}$ splits into:
% \[
% \pipeS {\tup{p_1,p_2,p_3}} {\tup{l_1,l_2,l_3}} {\caseof{r_1}{x_2.r_2}{x_3.r_3}}
% \]
% Note how the precomputations of $e_2$ and $e_3$ are pulled out from
% underneath the binder into a tuple that is always executed in the
% first stage. This occurs regardless of what branch is eventually
% executed in the second stage.

% \paragraph{Staging constructs.}
% Since \texttt{next} and \texttt{prev} do nothing more than convert between 
% second-stage terms at \bbtwo\ and encapsulated second-stage terms at \bbonem,
% their splitting rules are relatively simple.
% Given $\diatwo e q$, splitting yields $p$ and $l.r$ where
% \[
% 	\reduce p b \text{ and } [b/l]r \equiv q
% \]
% Then for $\diaone {\next {e}} {{\hat y} \mapsto q} {\next {\hat y}}$
% and\\ $\rtab {{\hat y} \mapsto q} {\next {\hat y}} \vsplito \mval {\tup{}} {\letin {\hat y} q {\hat y}}$, splitting must produce $c'$ and $l'.r'$ where
% \[
% 	\reduce {c'} {\tup {\tup{},b'}} \text{ and } [b'/l']r' \equiv \letin {\hat y} q {\hat y}
% \]
% Our algorithm chooses $c' = \tup{\tup{},p}$ and $l'.r' = l.r$.
% Applying this process in reverse yields a splitting rule for $\prev e$ which applies \texttt{pi1} to the combined term of $e$.

\subsection {Role of World \bbonep}
\label{sec:needGround}

The splitting algorithm described in the previous subsections operates
purely on the local structure of \lang\ terms.  One artifact of this design
is that splitting \bbonem\ terms may generate resumers containing
unnecessary logic.  For example, the rule for splitting
\bbonem\ \texttt{caseg} terms inserts the tag from the \texttt{caseg}
argument into the boundary value, then decodes this tag in the
resumer. This logic occurs regardless of whether the terms forming the
branches of the \texttt{caseg} contain second-stage computations.
Worse, if this \texttt{caseg} appeared in the body of a recursive
function with no other second-stage computations, splitting would
generate a resumer with (useless) recursive calls.

An illustrative example is the \texttt{partition} function in the quickselect
example of \ref{sec:exampleQS}. If \texttt{partition} were defined at \bbonem\
then (like \texttt{qs}) it would split into two functions
\texttt{partition1} and \texttt{partition2}, the latter of which recursively
computes the (trivial) second-stage component of \texttt{partition}'s result.
Moreover, \texttt{qs2} would call \texttt{partition2}, just as \texttt{qs1}
calls \texttt{partition1}:
\begin{lstlisting}
2`fun qs2 (p : tree, k : int) : int =
... | Branch (i,h,p1,p2) =>
  let val () = partition2 ((),()) in
  case compare k i of ...
\end{lstlisting}

Rather than attempt global optimization of the outputs of splitting,
we instead leverage the type system to indicate when a term contains
no second-stage computations by adding a third world \bbonep\ whose
terms are purely first-stage.  
Defining \texttt{partition} in this world is 
tantamount to proving it has no second-stage computations,
allowing splitting to avoid generating the resumer \texttt{partition2}
and calling it from \texttt{qs2}.

Since direct staged term evaluation (\ref{sec:semantics})
reduces all first stage terms to value forms without any remaining stage two work,
the distinction between \bbonem\ and \bbonep\ is unnecessary.
In contrast, when performing program transformations before the first stage inputs are known,
it is valuable to form a clear distinction between ground and mixed terms.
This was similarly observed in prior work seeking to implement self-applicable partial evaluators\,\cite{Mogensen89a,Mogensen89b}.
While this paper assumes that ground annotations already exist in the input,
it may be possible to use binding-time analysis techniques to automatically insert them.
Ground is also similar to the validity mechanism in ML5\,\cite{murphy05}.
\end{abstrsyn}

\input{figures/splitting-term}
\input{figures/splitting-misc}
