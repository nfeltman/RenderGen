
\section{Splitting Algorithm}

The basic idea is that we want to take a term which contains interleaved stage \bbone\ and stage \bbtwo\ code
and untangle it into two separate terms: one with all of the stage \bbone\ code and one with all the stage \bbtwo\ code.
To facilitate communication between the stages, there is a data structure passed between the stages, 
which is an output of the stage \bbone\ term and and input to the stage \bbtwo\ term.

As with the dynamics, the form of the splitting statement depends on the external stage of the term.
We consider splitting for stage \bbtwo\ terms first, as it has a simpler form.  
For example, take \verb|hold{1+2} < 5|.
We can split this into two separate terms, \verb|1+2| and \verb|fn l => l < 5|, 
which are called the {\em precomputation} and {\em residual}, respectively.  
For this splitting to be correct, the residual applied to the precomputation should yield the same result as the original term.  

The form of splitting for stage \bbone\ terms is more complicated.
To see why, consider the term \verb|(next{hold{1+2} < 5},3*4)|.
As before, the comparison operation is part of stage \bbtwo, 
and the addition operation is a stage \bbone\ precomputation, the result of which will eventually become input to the residual.
The multiplication operation, however, is neither part of the residual nor a precomputation to support it.
Instead it is the {\em immediate result} of stage \bbone, 
because it is available to the stage \bbone\ context around our original term.
For example:
\begin{lstlisting}
let x = (next{hold{1+2} < 5},3*4) in
next{ if prev{#1 x} then 7 else hold {#2 x} }
\end{lstlisting}
To support this, stage \bbone\ splitting produces two outputs: the {\em combined result} and the residual,
where the combined result reduces to a tuple containing the immediate result and the precomputation.

\subsection {Formal Setup}

We now discuss the formal definition of splitting.
The splitting algorithm comprises two judgments, $\splitonesym$ and $\splittwosym$.
The $\splitonesym$ judgment sends a stage \bbone\ term ($e$) to a combined term ($c$) and residual ($l.r$),
while $\splittwosym$ sends a stage \bbtwo\ term ($e$) to a precomputation ($p$) and a residual ($l.r$).
For concision, we actually represent residuals as a term open on a single variable, rather than as functions.
For both judgments, we use a context ($\Gamma$) to keep track of the open variables of $e$.

The rules\footnote{The rules are written using patterns, including the open variable of the residual.} 
for splitting $\next$, $\prev$, and $\pause$ are given in \ref{fig:termSplitOne}.
The rule for $\next$ simply tuples up the precomputation of its subexpression with a trivial immediate result,
while the rule for $\prev$ projects the combined result of its subexpression to just the precomputation.
The $\pause$ rule treats the entire combined result of its subexpression as a precomputation, 
and projects out the integer result in the residual\footnote{The residual of an integer expression is usually trivial, 
but we have to include it here for termination purposes.}

The rules of stage \bbtwo\ splitting are given in \ref{fig:termSplitTwo}.  
Every rule works by bundling the precomputations of the constituent parts, and then unbundling them with a pattern.
The rules of stage \bbone\ splitting are given in \ref{fig:termSplitOne}.  


\subsection {Speculation}

Notice in the stage \bbtwo\ rules for {\tt if}s, {\tt case}s, and functions, the precomputation is lifted out from within branches.
This is the manifestation of the speculation behavior from the semantics.

\subsection {Stage \bbone\ Divergence}
Consider the case of stage \bbone\ {\tt if} and {\tt case} expressions.
In both cases we have enough information at stage \bbone\ to know what branch to take, so there's no need to speculate.
Instead, we evaluate the stage \bbone\ portion of only the active branch, and then inject precomputation into a sum type.
Then in the residual, we case on that sum and resume the stage \bbtwo\ portion of the correct branch.

\subsection {Stage \bbone\ Functions}

The trick when splitting stage \bbone\ functions is that the contents themselves may be multi-stage.
We handle this by splitting them into two functions:
one in the immediate result which handles all the stage \bbone\ content of the original,
and one in the residual which handles all of the stage \bbtwo\ content.
Note that stage \bbone\ $\lambda$-expressions themselves have only a trivial precomputation.


Thus the boundary type appears as output of the first stage and input of the second stage.
This makes it hard to type the output, because the boundary types are not represented in the original function type.

\subsection {Boundary Type Worst Case}

\TODO add the example which is the worst case for figuring out boundary types

\input{figures/splitting-term}

\subsection{Value Splitting, Etc}

...

\subsection{Metatheory}

\begin{definition}
For residuals $q_1$ and $q_2$, define $q_1 \le_\beta q_2$ (``$q_1$ is $\beta$-smaller than $q_2$'') if they are
identical modulo internal beta reductions of $q_2$.
\end{definition}

Note, this is the empty-context version for stage \bbtwo.
We'll really need ones with contexts and stage \bbone.

\begin{theorem}
If $\cdot\vdash e : A \splittwosym [p:\tau,l.r]$ then,
\begin{enumerate}
\item $\cdot \vdash e : A~@~\bbtwo$ and
\item $\types [\cdot] p \tau$ and
\item $\types [l:\tau] r A$ and
\item $\diatwo [\cdot] e q$ iff $\reduce p u$ and if so
\item $q \equiv (\letin{l}{u}{r})$
\end{enumerate}
\end{theorem}

\input{figures/splitting-misc}

\section{Examples for Staged Pipelines}

Give the gist of one-to-one pipeline example (like client/server).
Then talk about a one-to-many pipeline.
Then talk about a many-to-one pipeline like spark.  It clear how to target something like this for known base types on the boundary, and for product types.  But sums on the boundary are hard!  We leave many-to-one as future-work.
