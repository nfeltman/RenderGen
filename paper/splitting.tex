\section{Splitting Algorithm}
\label{sec:splitting}

Although terms in \lang\ clearly distinguish their stage \bbone\ and stage
\bbtwo\ components, these components may be interleaved in complex ways. The
goal of \emph{stage splitting} is to produce from a term in \lang\ a pair of
terms in an unstaged language \langmono, which respectively perform all the
stage \bbone\ and stage \bbtwo\ subcomputations of the original term.

Since splitting stage \bbtwo\ terms is easier than splitting stage \bbone\
terms, we begin by describing how to split stage \bbtwo\ terms.

\subsection {Stage \bbtwo\ Splitting}

Splitting a stage \bbtwo\ term $\coltwo e A$ produces a \emph{precomputation}
term $p$ and a \emph{resumer} function $l.r$, which contain all stage \bbone\
and \bbtwo\ subcomputations of $e$, respectively. Since stage \bbtwo\
computations can depend on stage \bbone\ computations, $r$ can depend on $p$ via
the variable $l$. The correctness of splitting thus requires that $e$ is
equivalent to $\letin l p r$.

% TODO this contract works because a stage-2 term reduces to a value
% so we can simply compare (p,l.r) to that value

Splitting stage \bbtwo\ terms, as implemented by the judgment $e \splittwosym
[p,l.r]$ (\cref{fig:termSplitTwo}), is guided by the structure of the term $e$.
For example, the stage \bbtwo\ term
\begin{lstlisting}
2`hold{`1` 1+2 `2`} < (hold{`1` 3+4 `2`} - 5)`
\end{lstlisting}
has two subterms, the latter of which itself has two subterms. Two are $\pause$s
containing stage \bbone\ computations, while the third has no stage \bbone\
content. The precomputation \emph{lifts} these computations in the same tree
structure: \verb|(1+2,(3+4,()))|.%
\footnote{In later examples, we will optimize out unnecessary \texttt{()}s.}
The resumer is a function which computes the stage \bbtwo\ value of the original
term by mapping the results of the precomputation in place of the $\pause$s:
\verb|(L1,(L2,_)) => L1 < (L2 - 5)|. 

In general, constants and variables have no stage \bbone\ content, so their
precomputations are \texttt{()}, and their resumers return the original term's
value. Non-staging constructs with $n$ subterms have precomputations which are
$n$-tuples of their subterms' precomputations, and resumers which pass each
component to the resumer of the respective subterm. (This behavior at
\texttt{case} and functions causes precomputations to be lifted out from
underneath stage \bbtwo\ binders.) The $\prev$ and $\pause$ rules depends on
splitting stage \bbone\ terms, which is covered later.

\subsection{Stage \bbone\ Splitting}

Splitting a stage \bbone\ term $\colone e A$ produces a term and a function,
which respectively contain all the stage \bbone\ and stage \bbtwo\
subcomputations of $e$. The situation is more complex than when splitting stage
\bbtwo\ terms; to see why, consider the correctness criterion for splitting
stage \bbone\ terms.

Stage \bbone\ evaluation of $e$, via $e\mathbin{\redonesym}[\xi;v]$,
yields a table of (stage \bbtwo) residuals $\xi$, and a (stage \bbone) partial
value $v$. It is tempting to compare the two results of evaluating $e$ to the
two results of splitting it. To see where this goes wrong, consider the stage
\bbone\ term
\begin{lstlisting}
1`(1+2, next{`2`hold{`1`3+4`2`} + 5`1`})`
\end{lstlisting}
which evaluates to
\begin{lstlisting}
2`[yhat|->7+5]` 1`(3,next{`2`yhat`1`})`
\end{lstlisting}
This partial value contains a $\next$, and so is itself multistaged:
intuitively, its stage \bbone\ part is \texttt{3}, while its stage \bbtwo\ part
is $\mathtt{\hat{y}}$, which is bound to \texttt{7+5}.

We formalize this notion via two \emph{masking} functions (\ref{fig:valSplit}),
$\masko{\cdot}$ and $\maskt{\cdot}$, which expose only the relevant structure of
a partial value at each stage, essentially by replacing all stage \bbone\
(resp., \bbtwo) components of a partial value by \texttt{()}. The first result
of splitting must then compute the \bbone-mask of the partial value, and the
second result the \bbtwo-mask.

There is one final subtlety to splitting stage \bbone\ terms. In the example
above, there are \emph{two} flavors of stage \bbone\ subcomputations:
\texttt{1+2}, which is needed to compute the \bbone-mask, and \texttt{3+4},
a precomputation which is used by the computation of the \bbtwo-mask. 

Formally, splitting a stage \bbone\ term, as implemented by the judgment $e
\splitonesym [c,l.r]$ (\ref{fig:termSplitOne}), yields a \emph{combined result}
$c$ which computes a pair of the stage \bbone\ result and the precomputation,
and a \emph{resumer} function $l.r$. The correctness of splitting requires that,
for $e\mathbin{\redonesym}[\xi;v]$, we have that $\pio~c$ agrees with
$\masko{v}$, and $\letin l{\pit~c}r$ agrees with $\maskt{\xi;v}$.

The example splits into a combined result $c=$ \texttt{((1+2,()), 3+4)}, and a
resumer $l.r=$ \texttt{L => ((),L+5)}. Then $\pio~c$ reduces to \texttt{(3,())},
which agrees with the stage \bbone\ mask, and $\letin l{\pit~c}r$ reduces to
\texttt{((),12)}, which agrees with the stage \bbtwo\ mask.

\paragraph{Stage \bbone\ masking}

The purpose of masking is to expose only the relevant structure of a partial
value $v$ at each stage. For the most part, stage \bbone\ masking, $\masko{v}$,
simply replaces all $\next$s in $v$ with \texttt{()}. The only exception is for
functions $\lam xAe$; such a value represents a computation, so masking splits
its body as a computation, $e\splitonesym [c,l.r]$, and replaces it with its
stage \bbone\ component, the combined result.

\paragraph{Stage \bbtwo\ masking}

Stage \bbtwo\ masking, unlike stage \bbone\ masking, requires access to the
future context $\xi$, because the stage \bbtwo\ parts of $v$ contain variables
in $\xi$. To compute $\maskt{\xi;v}$, we rewrite $v$ to expose only the relevant
structure, and then reify the resulting term in the context $\xi$. This
rewriting process replaces base type constants in $v$ with \texttt{()}, and
$\next~\hat{y}$ with $\hat{y}$. Injection tags are eliminated, because the sum
type is at stage \bbone, so the tag is not relevant at stage \bbtwo. For
functions $\lam xAe$, masking again splits its body $e\splitonesym [c,l.r]$,
replaces it with the resumer, and uncurries, to yield $\lambda (x,l).r$.

\paragraph{Splitting}

Splitting stage \bbone\ terms, as implemented by the judgment $e\splitonesym
[c,l.r]$, is also guided by the structure of the term $e$.

\TODO polish the following explanation

The rule for $\next$ simply tuples up the precomputation of its subexpression with a trivial immediate result,
while the rule for $\prev$ projects the combined result of its subexpression to isolate the precomputation.
It may seem like this $\prev$ rule is throwing information away, but we well show later that the first component 
of the evaluated form of $c$ in the $\prev$ rule must always be unit.
The $\pause$ rule treats the entire combined result of its subexpression as a precomputation, 
and projects out the integer result in the resumer.%
\footnote{The resumer of an integer expression is usually trivial, 
but we have to include it here for termination purposes.}

In the splitting rules for stage \bbone\ {\tt case} expressions, we
have enough information at stage \bbone\ to know what branch to take, so there's
no need to speculate. Instead, we evaluate the stage \bbone\ portion of the
taken branch only, and inject the precomputation into a sum type. In the
resumer, we case on that injection, and resume the stage \bbtwo\ portion of the
correct branch.

\crem{split value splitting into two judgments, and call it masking}

\crem{masking figure is missing injections}

\crem{rename future context to residual table}

\input{figures/splitting-term}

\subsection{Eliminating Unnecessary Code}

\crem{don't say ``cost''}

While these splitting rules are all correct in terms of producing the right values, applying them naively can result in terms with needlessly large cost.  Consider the following example involving the factorial function:
\begin{lstlisting}
2`prev{
  1`letfun fact (n : int) : int = 
    if n <= 0 then 1 else fact(n-1)*n
  in next{`2`hold {`1`fact 5`2`}-100`1`}`2`
}`
\end{lstlisting}

The boundary type\footnote{The splitting results are untyped, but we add in type annotations to aid the reader.} of this is give by the following datatype declaration:
\begin{lstlisting}
datatype prec = L | R of prec
\end{lstlisting}
The example then splits into the precomputation,
\begin{lstlisting}
1`letfun fact (n : int) : int * prec = 
  if n <= 0 then (1,L) 
  else let (y,z) = fact(n-1) in (y*n,R z)
in ((),fact 5)`
\end{lstlisting}
and the resumer
\begin{lstlisting}
2`l.
letfun fact (n : unit, l0 : prec) : unit = 
  case l0 of L => () | R l1 => fact ((),l0)
in (fact (#2 l); #1 l)-100`
\end{lstlisting}
The problem here is that the naive system doesn't realize that the \texttt{fact} function has no stage \bbtwo\ content,
and so it pessimistically retraces all of its steps in the resumer.  
Fixing this requires some recursive reasoning.  

We instead tried to solve the issue by adding a single new staging annotation to \lang, called \texttt{mono}.  
A \texttt{mono} block must appear in a stage \bbone\ context, and it indicates that its entire context is monostage.
This can be encoded in our statics and dynamics by adding a new stage \bbmono\ and the judgements:
\begin{mathpar}
\infer{\typesone{\monoSt~e}A}{\typesmono e A} \and
\infer{\diaone{\monoSt~e}{\cdot;v}}{\diaone{e}{\cdot;v}}
\end{mathpar}

The splitting rule for \texttt{mono} is more difficult.
The problem is that the rules needs to produce a resumer with the correct shape
for whatever the type of the \texttt{mono} is.
This is difficult in the presence of sums and general recursion,
and so we introduce a new value in our target language called dummy.
Dummy can only appear in resumers and dynamically takes the shape of whatever is required of it.

The evaluation rules for dummy values are given by:
\begin{mathpar}
\infer{e_1~e_2~\redsym~\mathtt{dummy}}{e_1~\redsym~\mathtt{dummy} & e_2~\redsym~v} \and
\infer{\unroll~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pio~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pit~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}
\end{mathpar}

Coming back to \texttt{mono}, the splitting rule is:
\begin{mathpar}
\infer{\splitone{\monoSt~e}A {e', {\tt dummy}} }{e \overset{C}{\rightarrow} e'} \and
\infer{e_1~e_2 \overset{C}{\rightarrow} \pio~(e_1'~e_2')}{e_1 \overset{C}{\rightarrow} e_1' & e_2 \overset{C}{\rightarrow} e_2'} \and
\infer{\lambda x.e \overset{C}{\rightarrow} \lambda x.(e',())}{e \overset{C}{\rightarrow} e'}
\end{mathpar}
And $\overset{C}{\rightarrow}$ operates like a map at all other terms.

Our use of {\tt dummy} is safe because
it can only appear in the resumers of terms that have no circles in their \lang\ type.
Since the $\prev$ rule requires a circle type, dummy values cannot leak from
the resumers of stage \bbone\ terms into the resumers of stage \bbtwo\ terms.

\input{figures/splitting-misc}
