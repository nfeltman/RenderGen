
\section{Splitting Algorithm}
\label{sec:splitting}

%As with the dynamics, our stage-splitting algorithm for expressions in \lang\
%takes the form of two mutually-dependent judgments, $\splitonesym$ and
%$\splittwosym$, which respectively split terms that type $@ \bbone$ and $@
%\bbtwo$.  Before diving into the full generality, 

The goal of splitting is to take a multistage term and produce two new terms:
one with all of the stage \bbone\ content, and one with all of the stage \bbtwo\ content.
Exactly how this goal manifests depends on the form of the input. 
We consider four cases: stage \bbone\ values, stage \bbone\ terms, stage \bbtwo\ values,
and stage \bbtwo\ terms.

We cover stage \bbtwo\ value splitting first, because it is trivial by construction.
Since there is no stage \bbtwo\ expression that both is a value
and contains \bbone\ subexpressions, 
we say that stage \bbtwo\ values must contain no stage \bbone\ content.
Accordingly, there is nothing really to split.



\subsection{Partial Values}

Partial values, along with future environments, are produced by partially
evaluating stage \bbone\ terms. Although partial values have no more stage
\bbone\ computation remaining, they may contain variables bound by the future
environment, and thus, may require stage \bbtwo\ computation.

Splitting a partial value $v$ creates two single-stage values $v_1$ and $v_2$,
where $v_w$ contains only the information required for stage $w$ evaluation of
$v$. Splitting partial values is implemented by the judgment $v \vsplito
[v_1,v_2]$ defined in \ref{fig:valSplit}. 
At product, sum, and recursive types, splitting acts recursively, gathering all
subterms' stage $w$ content into $v_w$. At base types, splitting assigns $v$
entirely to stage \bbone\ (and \texttt{()} to stage \bbtwo); on the other hand,
at $\fut$ types, splitting assigns $v$ (which must have the form $\next~\hat y$)
entirely to stage \bbtwo\ (and \texttt{()} to stage \bbone). This process of
exposing only the relevant structure of a term is called \emph{masking}.


\ur{The case for ``fold'' seems missing in partial value splitting rules.}

Splitting a function is more complex, because function bodies are open terms,
and so are split by the judgments described in the next subsection. Essentially,
functions will split into two functions, whose bodies correspond to the stage
\bbone\ and stage \bbtwo\ components of the original function body.

\ur{Unclear whether the term ``masking'' includes the case for
  functions or not.  If it does, then it sounds rather
  inaccurate.  If not, then it should be stated clearly that it does
  not, but then what is the value of introducing one more term?}

\subsection{General Splitting}

Splitting arbitrary terms in \lang\ again results in two terms containing only
the stage \bbone\ or stage \bbtwo\ content of the original term; these terms are
called, respectively, the {\em precomputation} and {\em resumer}.
%
For example, the stage \bbtwo\ term
\begin{lstlisting}
2`hold{`1` 1+2 `2`} < hold{`1` 3+4 `2`} - 5`
\end{lstlisting}
splits into a precomputation \verb|(1+2,3+4)| and a resumer
\verb|fn (L1,L2) => L1 < L2-5|, with the property that the resumer applied to
the precomputation must agree with the original term. This process of hoisting
all the stage \bbone\ subterms out of a term is called \emph{lifting}.

Lifting and masking are two necessary ingredients for ensuring that splitting
observes the stages of \lang. When splitting a partial value, the stage \bbone\
result must \emph{mask} the stage \bbtwo\ computations in order to be
single-staged. When splitting a stage \bbtwo\ term, the precomputation must
\emph{lift} out all embedded stage \bbone\ computations, so they can be
performed first, even though their results are only used in stage \bbtwo.
%and it's accessible to whatever surrounding piece of code refers to the value being split.
%is not accessible externally.

Splitting a stage \bbone\ term, in contrast, requires both masking and splitting.
Consider the term 
\begin{lstlisting}
1`(next{`2`hold{`1` 1+2 `2`} < 5`1`},3*4)`
\end{lstlisting}
Masking yields the stage \bbone\ computation \verb|((),3*4)|, while lifting
yields the (stage \bbone) precomputation \verb|(1+2)|. While both computations
must occur at stage \bbone, the former is needed by stage \bbone, while the
latter is needed by stage \bbtwo.

The precomputation for this term is a \emph{combined result} which is
the pair of these components: \verb|(((),3*4),1+2)|. The resumer is
likewise the pair of the stage \bbtwo\ results of lifting and masking:
\verb|fn L => (L<5,())|.
%\footnote{In this example, the combined result is a 2-tuple, but more generally
%it only must be a term which reduces to a 2-tuple.}

\subsection {Formal Setup}

%in rule-for-rule correspondence with the typing rules $@\bbone$ and $@\bbtwo$.
Splitting is implemented by the judgments $\splitonesym$ and $\splittwosym$,
which take stage \bbone\ and stage \bbtwo\ terms respectively; these judgments
are defined in \cref{fig:termSplitOne,fig:termSplitTwo} inductively on the
structure of the term. Both judgments produce two terms in an unstaged language,
\langmono, whose grammar is given in \ref{fig:monoGrammar}. This language is
untyped and contains no staging features, but otherwise has the same term
constructors as \lang.
%\footnote{Since \langmono\ is untyped, we could encode everything with just functions.}.

The $\splitonesym$ judgment sends a stage \bbone\ term $e$ to a combined term
$c$ and resumer $l.r$, while $\splittwosym$ sends a stage \bbtwo\ term $e$ to a
precomputation $p$ and a resumer $l.r$. In both cases, the term $e$ is open on
variables in the context $\Gamma$. We write the rules using pattern notation
when appropriate.
%For concision, we represent resumers as a term open on a single variable,
%rather than as functions.

\ur{Reformat rules to make them fit into the paper.}

The $\splittwosym$ rules are conceptually simple and almost all very similar.  
As mentioned before, the only responsibility of $\splittwosym$ is to lift out the precomputation
from contained stage \bbone\ code into a single expression $p$, 
leaving a resumer $l.r$ to interpret the results of that precomputation.
Since base types and variables have no stage \bbone\ content, their precomputation is trivial;
that is, $p$ is a unit value and $l$ is never used in $r$.
At every other expression except $\prev$, the $\splittwosym$ rule works by bundling 
the precomputations of the constituent parts, and then unbundling them with a pattern,
with the resumer precisely resembling the original expression.

The rule for $\next$ simply tuples up the precomputation of its subexpression with a trivial immediate result,
while the rule for $\prev$ projects the combined result of its subexpression to isolate the precomputation.
It may seem like this $\prev$ rule is throwing information away, but we well show later that the first component 
of the evaluated form of $c$ in the $\prev$ rule must always be unit.
The $\pause$ rule treats the entire combined result of its subexpression as a precomputation, 
and projects out the integer result in the resumer.%
\footnote{The resumer of an integer expression is usually trivial, 
but we have to include it here for termination purposes.}

There are some particularly notable features of this definition of term
splitting.

\paragraph {Expression Splitting at Values}

When applied to partial values, term splitting always produces a trivial
precomputation, in the sense that the output is a nested sequence, possibly
empty, of tuples and injections of \texttt{()}. The intuition is that a partial
value has no remaining stage \bbone\ computation, and hence no precomputation.

%Partial value splitting is more than just a restriction of general expression
%splitting precisely because it observes this property it at the structural
%level, doing away with the precomputation entirely.

\paragraph {Speculation}

In the stage \bbtwo\ rules for {\tt if}s, {\tt case}s, and functions, the
precomputation is lifted out from within branches. This is the manifestation of
the speculation behavior from the semantics.

\paragraph {Stage \bbone\ Divergence}

In the splitting rules for stage \bbone\ {\tt if} and {\tt case} expressions, we
have enough information at stage \bbone\ to know what branch to take, so there's
no need to speculate. Instead, we evaluate the stage \bbone\ portion of the
taken branch only, and inject the precomputation into a sum type. In the
resumer, we case on that injection, and resume the stage \bbtwo\ portion of the
correct branch.

\paragraph {Stage \bbone\ Functions}

The body of a stage \bbone\ function may contain stage \bbtwo\ computation. We
handle this by splitting the function into two functions: one in the immediate
result which handles all the stage \bbone\ content of the original, and one in
the resumer which handles all of the stage \bbtwo\ content. Note that stage
\bbone\ lambdas are partial values, and so have only a trivial precomputation.

%\subsection {Boundary Type Worst Case}
%
%\TODO add the example which is the worst case for figuring out boundary types
%

\input{figures/splitting-term}

\subsection{Correctness of Splitting}

We can now develop an notion of what it means for splitting to be correct.  
Our general approach is to say that the dynamic semantics from \ref{sec:semantics} and splitting method are equivalent in some way.  
Thus, we start with two mutually dependent definitions of equivalence.  
Both relate residuals on the left with resumers on the right,
but $\equiv$ equates closed expressions, whereas $\sim$ equates values.

\begin{definition}
For residual $q$ and resumer $r$, define $q \equiv r : A$ to mean that 
$q \tworedsym v_q$ iff $\reduce {r} {v_r}$ where $v_q \sim v_r : A$, 
\end{definition}

\begin{definition}
For residual value $v_1$ and resumer value $v_2$, define $v_1 \sim v_2 : A$ by the following cases:
\begin{itemize}
\item $i \sim i : \rmint$
\item $(v_1,u_1) \sim (v_2,u_2) : A \times B$ where $v_1 \sim v_2 : A$ and $u_1 \sim u_2 : B$
\item $\inl~v_1 \sim \inl~v_2 : A + B$ where $v_1 \sim v_2 : A$
\item $\inr~v_1 \sim \inr~v_2 : A + B$ where $v_1 \sim v_2 : B$
\item $\lam {x_1} A {e_1} \sim \lambda x_2.e_2 : A \to B$ where \\ $\forall (v_1 \sim v_2 : A). [v_1/x_1]e_1 \equiv [v_2/x_2]e_2 : B$
\end{itemize}
\end{definition}

Essentially, we can read these as saying that two terms are equivalent if they evaluate to the same value,
where "same" for functions means that those functions always evaluate to the same thing given equivalent inputs.

We give the following end-to-end correctness lemmas for open terms. 
Those readers not interested in the gritty details are advised to skip ahead to the theorems for closed terms, which give the important gist.

In some of the lemmas, we sort the usually heterogeneous context into $\Gamma$ and $\Gamma'$, 
which respectively hold all of the stage \bbone\ and stage \bbtwo\ variable bindings.
Substitution splitting works just like value splitting, which is why they use the same symbol.

\begin{lemma}
If $\typesone e A$ then
$\Gamma\vdash e : A \splitonesym [c,l.r]$.
If $\typestwo e A$ then
$\Gamma\vdash e : A \splittwosym [p,l.r]$.
\end{lemma}

\begin{lemma}
If $\Gamma, \Gamma'\vdash e : A \splittwosym [p,l.r]$ then for all substitutions $\gamma : \Gamma$,
\begin{itemize}
\item $\gamma \vsplito [\gamma_1, \gamma_2]$
\item $\diatwo [\Gamma'] {\gamma(e)} q$ iff $\reduce {\gamma_1(p)} u$ where
\item $\Gamma' \vdash q \equiv (\letin{l}{u}{\gamma_2(r)})$
\end{itemize}
\end{lemma}

\begin{lemma}
If $\Gamma, \Gamma'\vdash e : A \splitonesym [c,l.r]$ then for all $\gamma : \Gamma$,
\begin{itemize}
\item $\gamma \vsplito [\gamma_1, \gamma_2]$
\item $\diaone [\Gamma'] {\gamma(e)} {\xi;v}$ iff $\reduce {\gamma_1(c)} {(v_1,u)}$ where
\item $\Gamma',\dom \xi \vdash v \vsplito [v_1,v_2]$
\item $\reify \xi {v_2} q$
\item $\Gamma'\vdash q \equiv (\letin{l}{u}{\gamma_2(r)})$
\end{itemize}
\end{lemma}

%You should think of these theorems as saying that 
%splitting commutes with evaluation.
These lemmas are rather technical, but they ultimately imply that evaluating a
closed term by splitting or by the dynamic semantics of \ref{ssec:dynamics} are
equivalent. 
We state this result for closed terms at each stage.

\begin{theorem}[Correctness of splitting at $\bbone$]
If $\vdash e:A~@~\bbone$, then (by splitting)
\begin{itemize}
\item $\vdash e : A \splitonesym [c,l.r]$
\item $\reduce {c} {(v_1,u)}$
\item $\reduce {(\letin{l}{u}{r})} v_S$
\end{itemize}
if and only if (by the staged dynamic semantics)
\begin{itemize}
\item $\diaone [] e {\xi;v}$
\item $\dom \xi \vdash v \vsplito [v_1,v_2]$
\item $\reify \xi{v_2}q$
\item $q \mathbin{\tworedsym} v_D$
\end{itemize}
and if so, then $v_D \sim v_S$.
\end{theorem}

\begin{theorem}[Correctness of splitting at $\bbtwo$]
If $\vdash e:A~@~\bbtwo$, then (by splitting)
\begin{itemize}
\item $\vdash e : A \splittwosym [p,l.r]$
\item $\reduce p u$
\item $\reduce{(\letin{l}{u}{r})}{v_S}$
\end{itemize}
if and only if (by the staged dynamic semantics)
\begin{itemize}
\item $\diatwo [] e q$
\item $q \mathbin{\tworedsym} v_D$
\end{itemize}
and if so, then $v_D \sim v_S$.
\end{theorem}

If we apply the former theorem to \verb|next{e}| of type $\fut A$, we
essentially obtain the latter theorem at \verb|e|.

The latter theorem implies that, given a multi-stage function $f:A\to\fut(B\to
C)~@~\bbone$, the two methods of evaluating \verb|prev{f a} b| agree.
However, we also expect that splitting $f$ directly will give us two functions,
one which accepts an $A$ and outputs an intermediate value and boundary data,
and another which takes in that boundary data and a $B$ and outputs a $C$.
Moreover, the composition of these two functions should be extensionally equal
to the staged dynamic semantics.

\TODO write the theorem for $\vdash f:A\to\fut(B\to C)~@~\bbone$.

%
%\subsubsection{Simple Types}
%
%\begin{theorem}
%If $\cdot\vdash e : A \splittwosym [p,l:\tau.r]$ then,
%\begin{itemize}
%\item $\cdot \vdash e : A~@~\bbtwo$ 
%\item $\types [\cdot] p \tau$ and $\types [l:\tau] r A$ 
%\item $\diatwo [\cdot] e q$ iff $\reduce p u$ and if so
%\item $q \equiv (\letin{l}{u}{r})$
%\end{itemize}
%\end{theorem}
%
%\begin{theorem}
%If $\cdot\vdash e : A \splitonesym [c,l:\tau.r]$ then,
%\begin{itemize}
%\item $\typesone [\cdot] e A$ 
%\item $A \tsplito [A_1,A_2]$
%\item $\types [\cdot] c {A_1 \times \tau}$ and $\types [l:\tau] r A_2$ 
%\item $\diaone [\cdot] e {\xi;v}$ iff $\reduce c {(v_1,u)}$ and if so
%\item $\dom \xi \vdash v \vsplito [v_1,v_2]$
%\item $\reify \xi {v_2} q$
%\item $q \equiv (\letin{l}{u}{r}) : A_2$
%\end{itemize}
%\end{theorem}
%
%\subsubsection{\bbone-Dependent Types}
%\begin{theorem}
%If $\cdot\vdash e : A \splitonesym [c,l:\tau.r]$ then,
%\begin{itemize}
%\item $\typesone [\cdot] e A$ 
%\item $A \tsplito [A_1,a.A_2]$
%\item $\types [\cdot] c {A_1 \times \tau}$ and $\types [l:\tau,a:A_1] r A_2$ 
%\item $\diaone [\cdot] e {\xi;v}$ iff $\reduce c {(v_1,u)}$ and if so
%\item $\dom \xi \vdash v \vsplito [v_1,v_2]$
%\item $\reify \xi {v_2} q$
%\item $q \equiv (\letin{l}{u}{r}) : A_2$
%\end{itemize}
%\end{theorem}

\subsection{Cost}

While these splitting rules are all correct in terms of producing the right values, applying them naively can result in terms with needlessly large cost.  Consider the following example involving the factorial function:
\begin{lstlisting}
2`prev{
  1`letfun fact (n : int) : int = 
    if n <= 0 then 1 else fact(n-1)*n
  in next{`2`hold {`1`fact 5`2`}-100`1`}`2`
}`
\end{lstlisting}

The boundary type\footnote{The splitting results are untyped, but we add in type annotations to aid the reader.} of this is give by the following datatype declaration:
\begin{lstlisting}
datatype prec = L | R of prec
\end{lstlisting}
The example then splits into the precomputation,
\begin{lstlisting}
1`letfun fact (n : int) : int * prec = 
  if n <= 0 then (1,L) 
  else let (y,z) = fact(n-1) in (y*n,R z)
in ((),fact 5)`
\end{lstlisting}
and the resumer
\begin{lstlisting}
2`l.
letfun fact (n : unit, l0 : prec) : unit = 
  case l0 of L => () | R l1 => fact ((),l0)
in (fact (#2 l); #1 l)-100`
\end{lstlisting}
The problem here is that the naive system doesn't realize that the \texttt{fact} function has no stage \bbtwo\ content,
and so it pessimistically retraces all of its steps in the resumer.  
Fixing this requires some recursive reasoning.  

We instead tried to solve the issue by adding a single new staging annotation to \lang, called \texttt{mono}.  
A \texttt{mono} block must appear in a stage \bbone\ context, and it indicates that its entire context is monostage.
This can be encoded in our statics and dynamics by adding a new stage \bbmono\ and the judgements:
\begin{mathpar}
\infer{\typesone{\monoSt~e}A}{\typesmono e A} \and
\infer{\diaone{\monoSt~e}{\cdot;v}}{\diaone{e}{\cdot;v}}
\end{mathpar}

The splitting rule for \texttt{mono} is more difficult.
...
transition to dummy.

The evaluation rules for dummy values are given by:
\begin{mathpar}
\infer{e_1~e_2~\redsym~\mathtt{dummy}}{e_1~\redsym~\mathtt{dummy} & e_2~\redsym~v} \and
\infer{\unroll~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pio~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pit~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}
\end{mathpar}

The basic idea here is that dummy will dynamically be whatever data structure you want it to be.

This is safe because [nico is just throwing something out here] 
it can only appear in the resumers of terms that have no circles in their \lang\ type.
Since the $\prev$ rule requires a circle type, dummy values cannot leak from
the resumers of stage \bbone\ terms into the resumers of stage \bbtwo\ terms.

\input{figures/splitting-misc}
