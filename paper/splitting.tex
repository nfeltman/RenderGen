
\section{Splitting Algorithm}
\label{sec:splitting}

The basic idea is that we want to take a \lang\ term which contains interleaved stage \bbone\ and stage \bbtwo\ code
and split it into two separate terms: one with all of the stage \bbone\ code and one with all the stage \bbtwo\ code.
To facilitate communication between the stages, there is a data structure passed between the stages, 
which is an output of the stage \bbone\ term and and input to the stage \bbtwo\ term.

As with the dynamics, the form of the splitting statement depends on the external stage of the term.
We consider splitting for stage \bbtwo\ terms first, as it has a simpler form.  
For example, take \verb|hold{1+2} < 5|.
We can split this into two separate terms, \verb|1+2| and \verb|fn l => l < 5|, 
which are called the {\em precomputation} and {\em residual}\footnote{We also used the term {\em residual} for the result of partial evaluation.
Where necessary, we will distinguish between these concepts by using the terms {\em splitting-residual}
and {\em evaluation-residual}.}, respectively.  

The form of splitting for stage \bbone\ terms is more complicated.
To see why, consider the term \verb|(next{hold{1+2} < 5},3*4)|.
As before, the comparison operation is part of stage \bbtwo, 
and the addition operation is a stage \bbone\ precomputation, the result of which will eventually become input to the residual.
The multiplication operation, however, is neither part of the residual nor a precomputation to support it.
Instead it is the {\em immediate result} of stage \bbone, 
because it is available to the stage \bbone\ context around our original term.
For example:
\begin{lstlisting}
let x = (next{hold{1+2} < 5},3*4) in
next{ if prev{#1 x} then 7 else hold {#2 x} }
\end{lstlisting}
To support this, stage \bbone\ splitting produces two outputs: the {\em combined result} and the residual,
where the combined result reduces to a tuple containing the immediate result and the precomputation.

We must also develop a notion of what it means for splitting to be correct.  
Our general approach is to say that the dynamic semantics from \ref{sec:semantics} and splitting method are equivalent in some way.  
In general, if a multi-stage program $P$ splits into stage-\bbone\ part $P_1$ and stage-\bbtwo\ part $P_2$, then
\begin{enumerate}
\item Partial evaluation of $P$ will terminate if and only if evaluation of $P_1$ terminates, and if so then
\item the immediate results of each method will be equivalent, and
\item the evaluation-residual and the splitting-residual ($P_2$ bound under the precomputation) are equivalent.
\end{enumerate}

This is straight-forward, given a careful definition of equivalence.


\subsection{Value Splitting}

Before getting into the formal presentation, 
we first consider the problem of splitting stage-\bbone\ partial values.
This serves as a didactic stepping-stone to full term-splitting, 
and it is a necessary component of the correctness theorem.

The rules for value splitting are given in \cref{fig:valSplit}.  It consists of a single judgment, $v \vsplito [v_1,v_2]$,
which sends a partial value $v$ to two single-stage values $v_1$ and $v_2$. 
Those respectively represent the stage-\bbone\ and stage-\bbtwo\ content of the original value.  
At base types, value splitting assigns all content to stage \bbone, and puts in a nullary tuple for stage two,
in accordance with the precept that base types have only trivial content at stage \bbtwo.
Splitting essentially distributes into values at product, sum, and recursive types.
Functions split into two other functions.  Since the body of a function is an open term, this rule must rely on 
general term splitting, which is covered momentarily.

Lastly, we consider value splitting at the $\fut$ type.  The only partial value with this type
is a $\next$ block containing a reference into the future environment.  This splits into a 
nullary tuple and the same variable, again aligning with the precept that $\fut$ types contain trivial stage-\bbone\
content.

\subsection {Formal Setup}

The splitting algorithm comprises two judgments, $\splitonesym$ and $\splittwosym$.
For both, the input is a term in \lang, and the output is two terms in \langmono, an
unstaged language.  The grammar for \langmono\ is given in \ref{fig:monoGrammar}.  It has no
staging features (we say that implicitly it has only one stage), and it is untyped.  
Modulo these differences, \langmono\ has all of the same features as \lang, 
although this is a matter of taste
\footnote{Since \langmono\ is untyped, we could encode everything with just functions.}.

Specifically, the $\splitonesym$ judgment sends a stage \bbone\ term ($e$) to a combined term ($c$) and residual ($l.r$),
while $\splittwosym$ sends a stage \bbtwo\ term ($e$) to a precomputation ($p$) and a residual ($l.r$).
For concision, we represent residuals as a term open on a single variable, rather than as functions.
For both judgments, we use a context ($\Gamma$) to keep track of the open variables of $e$.

The rules\footnote{The rules are written using patterns, including the open variable of the residual.} 
for splitting $\next$, $\prev$, and $\pause$ are given in \ref{fig:termSplitOne}.
The rule for $\next$ simply tuples up the precomputation of its subexpression with a trivial immediate result,
while the rule for $\prev$ projects the combined result of its subexpression to just the precomputation.
The $\pause$ rule treats the entire combined result of its subexpression as a precomputation, 
and projects out the integer result in the residual\footnote{The residual of an integer expression is usually trivial, 
but we have to include it here for termination purposes.}

The rules of stage \bbtwo\ splitting are given in \ref{fig:termSplitTwo}.  
Every rule works by bundling the precomputations of the constituent parts, and then unbundling them with a pattern.
The rules of stage \bbone\ splitting are given in \ref{fig:termSplitOne}.  


\subsection {Speculation}

Notice in the stage \bbtwo\ rules for {\tt if}s, {\tt case}s, and functions, the precomputation is lifted out from within branches.
This is the manifestation of the speculation behavior from the semantics.

\subsection {Stage \bbone\ Divergence}
Consider the splitting rules for stage-\bbone\ {\tt if} and {\tt case} expressions.
In both cases we have enough information at stage \bbone\ to know what branch to take, so there's no need to speculate.
Instead, we evaluate the stage \bbone\ portion of only the active branch, and then inject precomputation into a sum type.
Then in the residual, we case on that sum and resume the stage \bbtwo\ portion of the correct branch.

\subsection {Stage \bbone\ Functions}

The trick when splitting stage \bbone\ functions is that the contents themselves may be multi-stage.
We handle this by splitting them into two functions:
one in the immediate result which handles all the stage \bbone\ content of the original,
and one in the residual which handles all of the stage \bbtwo\ content.
Note that stage \bbone\ $\lambda$-expressions themselves have only a trivial precomputation.

%\subsection {Boundary Type Worst Case}
%
%\TODO add the example which is the worst case for figuring out boundary types
%

\input{figures/splitting-term}

\subsection{Metatheory}

We start with two mutually dependent definitions of equivalence.  
Both relate evaluation-residuals on the left with splitting residuals on the right,
but $\equiv$ operates on terms, whereas $\sim$ on values.

\begin{definition}
For evaluation-residual $q$ and splitting-residual $r$, define $q \equiv r : A$ to mean that 
$q \tworedsym v_q$ iff $\reduce {r} {v_r}$ where $v_q \sim v_r : A$, 
\end{definition}

\begin{definition}
For evaluation-residual value $v_1$ and splitting-residual value $v_2$, define $v_1 \sim v_2 : A$ by the following cases:
\begin{itemize}
\item $i \sim i : \rmint$
\item $(v_1,u_1) \sim (v_2,u_2) : A \times B$ where $v_1 \sim v_2 : A$ and $u_1 \sim u_2 : B$
\item $\inl~v_1 \sim \inl~v_2 : A + B$ where $v_1 \sim v_2 : A$
\item $\inr~v_1 \sim \inr~v_2 : A + B$ where $v_1 \sim v_2 : B$
\item $\lam {x_1} A {e_1} \sim \lambda x_2.e_2 : A \to B$ where \\ $\forall (v_1 \sim v_2 : A). [v_1/x_1]e_1 \equiv [v_2/x_2]e_2 : B$
\end{itemize}
\end{definition}

Essentially, we can read these as saying that two terms are equivalent if they evaluate to the same value,
where "same" for functions means that those functions always evaluate to the same thing given equivalent inputs.

We give the following end-to-end correctness lemmas for open terms. 
It's a bit of a mess currently, but the $\Gamma$ is supposed to be all of the stage \bbone\ bindings, 
whereas $\Gamma'$ is the stage \bbtwo\ bindings.
Substitution splitting works just like value splitting, which is why they use the same symbol.

The jury is still out on how to make these strong enough to prove that the partitioning between stages is correct.

\begin{lemma}
If $\typesone e A$ then
$\Gamma\vdash e : A \splitonesym [c,l.r]$.
If $\typestwo e A$ then
$\Gamma\vdash e : A \splittwosym [p,l.r]$.
\end{lemma}

\begin{lemma}
If $\Gamma, \Gamma'\vdash e : A \splittwosym [p,l.r]$ then for all substitutions $\gamma : \Gamma$,
\begin{itemize}
\item $\gamma \vsplito [\gamma_1, \gamma_2]$
\item $\diatwo [\Gamma'] {\gamma(e)} q$ iff $\reduce {\gamma_1(p)} u$ where
\item $\Gamma' \vdash q \equiv (\letin{l}{u}{\gamma_2(r)})$
\end{itemize}
\end{lemma}

\begin{lemma}
If $\Gamma, \Gamma'\vdash e : A \splitonesym [c,l.r]$ then for all $\gamma : \Gamma$,
\begin{itemize}
\item $\gamma \vsplito [\gamma_1, \gamma_2]$
\item $\diaone [\Gamma'] {\gamma(e)} {\xi;v}$ iff $\reduce {\gamma_1(c)} {(v_1,u)}$ where
\item $\Gamma',\dom \xi \vdash v \vsplito [v_1,v_2]$
\item $\reify \xi {v_2} q$
\item $\Gamma'\vdash q \equiv (\letin{l}{u}{\gamma_2(r)})$
\end{itemize}
\end{lemma}

%You should think of these theorems as saying that 
%splitting commutes with evaluation.
These lemmas are rather technical, but they ultimately imply that evaluating a
closed term by splitting or by the dynamic semantics of \ref{ssec:dynamics} are
equivalent. 
We state this result for closed terms at each stage.

\begin{theorem}[Correctness of splitting at $\bbone$]
If $\vdash e:A~@~\bbone$, then (by splitting)
\begin{itemize}
\item $\vdash e : A \splitonesym [c,l.r]$
\item $\reduce {c} {(v_1,u)}$
\item $\reduce {(\letin{l}{u}{r})} v_S$
\end{itemize}
if and only if (by the staged dynamic semantics)
\begin{itemize}
\item $\diaone [] e {\xi;v}$
\item $\dom \xi \vdash v \vsplito [v_1,v_2]$
\item $\reify \xi{v_2}q$
\item $q \mathbin{\tworedsym} v_D$
\end{itemize}
and if so, then $v_D \sim v_S$.
\end{theorem}

\begin{theorem}[Correctness of splitting at $\bbtwo$]
If $\vdash e:A~@~\bbtwo$, then (by splitting)
\begin{itemize}
\item $\vdash e : A \splittwosym [p,l.r]$
\item $\reduce p u$
\item $\reduce{(\letin{l}{u}{r})}{v_S}$
\end{itemize}
if and only if (by the staged dynamic semantics)
\begin{itemize}
\item $\diatwo [] e q$
\item $q \mathbin{\tworedsym} v_D$
\end{itemize}
and if so, then $v_D \sim v_S$.
\end{theorem}

If we apply the former theorem to \verb|next{e}| of type $\fut A$, we
essentially obtain the latter theorem at \verb|e|.

The latter theorem implies that, given a multi-stage function $f:A\to\fut(B\to
C)~@~\bbone$, the two methods of evaluating \verb|prev{f a} b| agree.
However, we also expect that splitting $f$ directly will give us two functions,
one which accepts an $A$ and outputs an intermediate value and boundary data,
and another which takes in that boundary data and a $B$ and outputs a $C$.
Moreover, the composition of these two functions should be extensionally equal
to the staged dynamic semantics.

\TODO write the theorem for $\vdash f:A\to\fut(B\to C)~@~\bbone$.

%
%\subsubsection{Simple Types}
%
%\begin{theorem}
%If $\cdot\vdash e : A \splittwosym [p,l:\tau.r]$ then,
%\begin{itemize}
%\item $\cdot \vdash e : A~@~\bbtwo$ 
%\item $\types [\cdot] p \tau$ and $\types [l:\tau] r A$ 
%\item $\diatwo [\cdot] e q$ iff $\reduce p u$ and if so
%\item $q \equiv (\letin{l}{u}{r})$
%\end{itemize}
%\end{theorem}
%
%\begin{theorem}
%If $\cdot\vdash e : A \splitonesym [c,l:\tau.r]$ then,
%\begin{itemize}
%\item $\typesone [\cdot] e A$ 
%\item $A \tsplito [A_1,A_2]$
%\item $\types [\cdot] c {A_1 \times \tau}$ and $\types [l:\tau] r A_2$ 
%\item $\diaone [\cdot] e {\xi;v}$ iff $\reduce c {(v_1,u)}$ and if so
%\item $\dom \xi \vdash v \vsplito [v_1,v_2]$
%\item $\reify \xi {v_2} q$
%\item $q \equiv (\letin{l}{u}{r}) : A_2$
%\end{itemize}
%\end{theorem}
%
%\subsubsection{\bbone-Dependent Types}
%\begin{theorem}
%If $\cdot\vdash e : A \splitonesym [c,l:\tau.r]$ then,
%\begin{itemize}
%\item $\typesone [\cdot] e A$ 
%\item $A \tsplito [A_1,a.A_2]$
%\item $\types [\cdot] c {A_1 \times \tau}$ and $\types [l:\tau,a:A_1] r A_2$ 
%\item $\diaone [\cdot] e {\xi;v}$ iff $\reduce c {(v_1,u)}$ and if so
%\item $\dom \xi \vdash v \vsplito [v_1,v_2]$
%\item $\reify \xi {v_2} q$
%\item $q \equiv (\letin{l}{u}{r}) : A_2$
%\end{itemize}
%\end{theorem}

\input{figures/splitting-misc}
