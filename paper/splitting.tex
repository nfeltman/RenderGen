
\section{Splitting Algorithm}
\label{sec:splitting}

Much like partial evaluation, the goal of stage-splitting is to separate the evaluation of a multi-stage function into distinct phases.
However, where partial evaluation requires the value of some inputs to be known, stage splitting is a static transformation performed
before any arguments are available.
Taking a multivariate function $f$ as input, stage-splitting produces two functions $f_1$ and $f_2$,
where $f_1$ uses the stage-\bbone\ input to produce a data structure, 
and $f_2$ uses that data structure and the stage-\bbtwo\ input to produce the final output.  
More precisely, a stage splitter is any $s$ such that
\[
	\forall f. \exists f_1,f_2. 
	\left[
		\begin{array}{l}
		s(f) = (f_1,f_2) \text{ and } \\
		\forall x,y.\llbracket f \rrbracket(x,y)=\llbracket f_2 \rrbracket(\llbracket f_1 \rrbracket(x),y)
		\end{array}
	\right]
\]
with the same $\llbracket \cdot \rrbracket$ notation as before.
Notice that $x$ here is bound underneath the existential $f_1$ and $f_2$,
meaning that the stage splitting operation does not depend on the stage-\bbone\ input.
This stands in contrast to the definition of partial evaluation, where $f_x$ does depend on $x$.

As with the dynamics, our stage-splitting algorithm for expressions in \lang\ takes 
the form of two mutually-dependent judgments, $\splitonesym$ and $\splittwosym$. 
Before diving into the full generality, we consider splitting for a simple fragment of the full language: partial values.
After that, we define splitting for full expressions, discuss some notable properties of the algorithm, and then prove correctness.

\subsection{Partial Value Splitting}

We now consider the problem of splitting stage-\bbone\ partial values.
This serves as a simple didactic stepping-stone to the full formulation, 
and we will see later that it is a necessary component of the correctness theorem.

The basic goal of partial value splitting is to take a partial value $v$ and create from it two single stage values $v_1$ and $v_2$,
where $v_1$ contains only the information from $v$ that is relevant to the first stage, 
and $v_2$ contains only the information from $v$ that is relevant to the second stage.
We call this action {\em masking}.

There are many reasonable ways to achieve this goal, 
and we choose one that preserves as much structure as possible from $v$.
Formally, partial value splitting comprises a single judgment, $v \vsplito [v_1,v_2]$, the rules for which are given in \cref{fig:valSplit}.
It essentially acts distributively at product, sum, and recursive types, 
doing little more than recuring into subvalues and duplicating the structure to both results.
At base types, partial value splitting assign all content ({\em i.e.} the integer or boolean) to stage \bbone, and uses a nullary tuple placeholder for stage \bbtwo.
Conversely at $\fut$ types, splitting assigns all content ({\em i.e.} the environment reference) to stage \bbtwo, and uses a nullary tuple for stage \bbone.

Functions are inherently more complicated. 
Since the body of a function is an open term, the partial value splitting rule for functions must rely on general expression splitting, which is covered momentarily.
The most we can say here is a function splits into two other functions, 
whose bodies correspond to the stage \bbone\ and stage \bbtwo\ components of the original function's body.

\subsection{ Expression Splitting}

We now consider the problem of splitting expressions in \lang, starting with stage \bbtwo\ terms.  
The goal here is to end up with two new terms: one that has all of the stage \bbone\ content of the original, and one with all of the stage \bbtwo\ content. 
These are respectively called the {\em precomputation} and {\em residual}.
\footnote{We also used the term {\em residual} for the result of partial evaluation.
Where necessary, we will distinguish between these concepts by using the terms {\em splitting-residual} and {\em evaluation-residual}.}

For example, consider $e=``\verb|hold{1+2} < hold{3+4}-5|"$.
We can split this into two terms, $p=``\verb|(1+2,3+4)|"$ and $r=``\verb|fn (L1,L2) => L1 < L2-5|"$, 
with the as yet imprecise property that $r$ applied to $p$ yields the same final value as $e$.
In general, all we're doing here is finding the contained nuggets of stage \bbone\ code and pulling them into a big tuple,
an action we call {\em lifting}.

Note that lifting and masking are different, despite both being within the purview of splitting.
They particularly differ in how the resulting stage \bbone\ parts are used.
The $v_1$ of partial value splitting is essentially the stage \bbone\ content of {\em result} of computation, 
and it's accessible to whatever surrounding piece of code refers to the value being split.
In contrast, the $p$ of stage \bbtwo\ expression splitting is only meant to support the stage \bbtwo\ part,
and is not accessible externally.

The distinction between lifting and masking is important because stage \bbone\ expression splitting does both.
To see why, consider the term \verb|(next{hold{1+2} < 5},3*4)|.
The stage \bbone\ result of masking is \verb|((),3*4)|, 
and the precomputation (i.e. the stage \bbone\ result of lifting) is \verb|(1+2)|.
To get the total stage \bbone\ result of splitting, we just take the tuple of those two parts: \verb|(((),3*4),1+2)|.  
This is called the {\em combined result} for stage \bbone.
\footnote{In this example, the combined result is a 2-tuple, but more generally it only must be a term which reduces to a 2-tuple.}

The residual is likewise the combination of the stage \bbtwo\ results of lifting and masking.
In this case, it is ``\verb|fn L => (L<5,())|".

\subsection {Formal Setup}

The splitting algorithm comprises two judgments, $\splitonesym$ and $\splittwosym$.
For both, the input is a term in \lang, and the output is two terms in \langmono, an
unstaged language.  The grammar for \langmono\ is given in \ref{fig:monoGrammar}.  It has no
staging features (we say that implicitly it has only one stage), and it is untyped.  
Modulo these differences, \langmono\ has all of the same features as \lang, 
although this is a matter of taste
\footnote{Since \langmono\ is untyped, we could encode everything with just functions.}.

Specifically, the $\splitonesym$ judgment sends a stage \bbone\ term ($e$) to a combined term ($c$) and residual ($l.r$),
while $\splittwosym$ sends a stage \bbtwo\ term ($e$) to a precomputation ($p$) and a residual ($l.r$).
For concision, we represent residuals as a term open on a single variable, rather than as functions.
For both judgments, we use a context ($\Gamma$) to keep track of the open variables of $e$.

The rules\footnote{The rules are written using patterns, including the open variable of the residual.} 
for splitting $\next$, $\prev$, and $\pause$ are given in \ref{fig:termSplitOne}.
The rule for $\next$ simply tuples up the precomputation of its subexpression with a trivial immediate result,
while the rule for $\prev$ projects the combined result of its subexpression to just the precomputation.
The $\pause$ rule treats the entire combined result of its subexpression as a precomputation, 
and projects out the integer result in the residual\footnote{The residual of an integer expression is usually trivial, 
but we have to include it here for termination purposes.}

The rules of stage \bbtwo\ splitting are given in \ref{fig:termSplitTwo}.  
Every rule works by bundling the precomputations of the constituent parts, and then unbundling them with a pattern.
The rules of stage \bbone\ splitting are given in \ref{fig:termSplitOne}.  

\subsection {Properties}

We'll now call out a few properties to notice in the splitting rules.

\subsubsection {Speculation}

Notice in the stage \bbtwo\ rules for {\tt if}s, {\tt case}s, and functions, the precomputation is lifted out from within branches.
This is the manifestation of the speculation behavior from the semantics.

\subsubsection {Stage \bbone\ Divergence}
Consider the splitting rules for stage-\bbone\ {\tt if} and {\tt case} expressions.
In both cases we have enough information at stage \bbone\ to know what branch to take, so there's no need to speculate.
Instead, we evaluate the stage \bbone\ portion of only the active branch, and then inject precomputation into a sum type.
Then in the residual, we case on that sum and resume the stage \bbtwo\ portion of the correct branch.

\subsubsection {Stage \bbone\ Functions}

The trick when splitting stage \bbone\ functions is that the contents themselves may be multi-stage.
We handle this by splitting them into two functions:
one in the immediate result which handles all the stage \bbone\ content of the original,
and one in the residual which handles all of the stage \bbtwo\ content.
Note that stage \bbone\ $\lambda$-expressions themselves have only a trivial precomputation.

%\subsection {Boundary Type Worst Case}
%
%\TODO add the example which is the worst case for figuring out boundary types
%

\input{figures/splitting-term}

\subsection{Correctness of Splitting}

We can now develop an notion of what it means for splitting to be correct.  
Our general approach is to say that the dynamic semantics from \ref{sec:semantics} and splitting method are equivalent in some way.  
Thus, we start with two mutually dependent definitions of equivalence.  
Both relate evaluation-residuals on the left with splitting residuals on the right,
but $\equiv$ equates closed expressions, whereas $\sim$ equates values.

\begin{definition}
For evaluation-residual $q$ and splitting-residual $r$, define $q \equiv r : A$ to mean that 
$q \tworedsym v_q$ iff $\reduce {r} {v_r}$ where $v_q \sim v_r : A$, 
\end{definition}

\begin{definition}
For evaluation-residual value $v_1$ and splitting-residual value $v_2$, define $v_1 \sim v_2 : A$ by the following cases:
\begin{itemize}
\item $i \sim i : \rmint$
\item $(v_1,u_1) \sim (v_2,u_2) : A \times B$ where $v_1 \sim v_2 : A$ and $u_1 \sim u_2 : B$
\item $\inl~v_1 \sim \inl~v_2 : A + B$ where $v_1 \sim v_2 : A$
\item $\inr~v_1 \sim \inr~v_2 : A + B$ where $v_1 \sim v_2 : B$
\item $\lam {x_1} A {e_1} \sim \lambda x_2.e_2 : A \to B$ where \\ $\forall (v_1 \sim v_2 : A). [v_1/x_1]e_1 \equiv [v_2/x_2]e_2 : B$
\end{itemize}
\end{definition}

Essentially, we can read these as saying that two terms are equivalent if they evaluate to the same value,
where "same" for functions means that those functions always evaluate to the same thing given equivalent inputs.

We give the following end-to-end correctness lemmas for open terms. 
It's a bit of a mess currently, but the $\Gamma$ is supposed to be all of the stage \bbone\ bindings, 
whereas $\Gamma'$ is the stage \bbtwo\ bindings.
Substitution splitting works just like value splitting, which is why they use the same symbol.

\begin{lemma}
If $\typesone e A$ then
$\Gamma\vdash e : A \splitonesym [c,l.r]$.
If $\typestwo e A$ then
$\Gamma\vdash e : A \splittwosym [p,l.r]$.
\end{lemma}

\begin{lemma}
If $\Gamma, \Gamma'\vdash e : A \splittwosym [p,l.r]$ then for all substitutions $\gamma : \Gamma$,
\begin{itemize}
\item $\gamma \vsplito [\gamma_1, \gamma_2]$
\item $\diatwo [\Gamma'] {\gamma(e)} q$ iff $\reduce {\gamma_1(p)} u$ where
\item $\Gamma' \vdash q \equiv (\letin{l}{u}{\gamma_2(r)})$
\end{itemize}
\end{lemma}

\begin{lemma}
If $\Gamma, \Gamma'\vdash e : A \splitonesym [c,l.r]$ then for all $\gamma : \Gamma$,
\begin{itemize}
\item $\gamma \vsplito [\gamma_1, \gamma_2]$
\item $\diaone [\Gamma'] {\gamma(e)} {\xi;v}$ iff $\reduce {\gamma_1(c)} {(v_1,u)}$ where
\item $\Gamma',\dom \xi \vdash v \vsplito [v_1,v_2]$
\item $\reify \xi {v_2} q$
\item $\Gamma'\vdash q \equiv (\letin{l}{u}{\gamma_2(r)})$
\end{itemize}
\end{lemma}

%You should think of these theorems as saying that 
%splitting commutes with evaluation.
These lemmas are rather technical, but they ultimately imply that evaluating a
closed term by splitting or by the dynamic semantics of \ref{ssec:dynamics} are
equivalent. 
We state this result for closed terms at each stage.

\begin{theorem}[Correctness of splitting at $\bbone$]
If $\vdash e:A~@~\bbone$, then (by splitting)
\begin{itemize}
\item $\vdash e : A \splitonesym [c,l.r]$
\item $\reduce {c} {(v_1,u)}$
\item $\reduce {(\letin{l}{u}{r})} v_S$
\end{itemize}
if and only if (by the staged dynamic semantics)
\begin{itemize}
\item $\diaone [] e {\xi;v}$
\item $\dom \xi \vdash v \vsplito [v_1,v_2]$
\item $\reify \xi{v_2}q$
\item $q \mathbin{\tworedsym} v_D$
\end{itemize}
and if so, then $v_D \sim v_S$.
\end{theorem}

\begin{theorem}[Correctness of splitting at $\bbtwo$]
If $\vdash e:A~@~\bbtwo$, then (by splitting)
\begin{itemize}
\item $\vdash e : A \splittwosym [p,l.r]$
\item $\reduce p u$
\item $\reduce{(\letin{l}{u}{r})}{v_S}$
\end{itemize}
if and only if (by the staged dynamic semantics)
\begin{itemize}
\item $\diatwo [] e q$
\item $q \mathbin{\tworedsym} v_D$
\end{itemize}
and if so, then $v_D \sim v_S$.
\end{theorem}

If we apply the former theorem to \verb|next{e}| of type $\fut A$, we
essentially obtain the latter theorem at \verb|e|.

The latter theorem implies that, given a multi-stage function $f:A\to\fut(B\to
C)~@~\bbone$, the two methods of evaluating \verb|prev{f a} b| agree.
However, we also expect that splitting $f$ directly will give us two functions,
one which accepts an $A$ and outputs an intermediate value and boundary data,
and another which takes in that boundary data and a $B$ and outputs a $C$.
Moreover, the composition of these two functions should be extensionally equal
to the staged dynamic semantics.

\TODO write the theorem for $\vdash f:A\to\fut(B\to C)~@~\bbone$.

%
%\subsubsection{Simple Types}
%
%\begin{theorem}
%If $\cdot\vdash e : A \splittwosym [p,l:\tau.r]$ then,
%\begin{itemize}
%\item $\cdot \vdash e : A~@~\bbtwo$ 
%\item $\types [\cdot] p \tau$ and $\types [l:\tau] r A$ 
%\item $\diatwo [\cdot] e q$ iff $\reduce p u$ and if so
%\item $q \equiv (\letin{l}{u}{r})$
%\end{itemize}
%\end{theorem}
%
%\begin{theorem}
%If $\cdot\vdash e : A \splitonesym [c,l:\tau.r]$ then,
%\begin{itemize}
%\item $\typesone [\cdot] e A$ 
%\item $A \tsplito [A_1,A_2]$
%\item $\types [\cdot] c {A_1 \times \tau}$ and $\types [l:\tau] r A_2$ 
%\item $\diaone [\cdot] e {\xi;v}$ iff $\reduce c {(v_1,u)}$ and if so
%\item $\dom \xi \vdash v \vsplito [v_1,v_2]$
%\item $\reify \xi {v_2} q$
%\item $q \equiv (\letin{l}{u}{r}) : A_2$
%\end{itemize}
%\end{theorem}
%
%\subsubsection{\bbone-Dependent Types}
%\begin{theorem}
%If $\cdot\vdash e : A \splitonesym [c,l:\tau.r]$ then,
%\begin{itemize}
%\item $\typesone [\cdot] e A$ 
%\item $A \tsplito [A_1,a.A_2]$
%\item $\types [\cdot] c {A_1 \times \tau}$ and $\types [l:\tau,a:A_1] r A_2$ 
%\item $\diaone [\cdot] e {\xi;v}$ iff $\reduce c {(v_1,u)}$ and if so
%\item $\dom \xi \vdash v \vsplito [v_1,v_2]$
%\item $\reify \xi {v_2} q$
%\item $q \equiv (\letin{l}{u}{r}) : A_2$
%\end{itemize}
%\end{theorem}

\input{figures/splitting-misc}
