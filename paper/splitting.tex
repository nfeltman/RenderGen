%\langmono\ has a evaluation judgment $\redsym$, which works in the expected way
%to produce unstaged values.

\section{Splitting Algorithm}
\label{sec:splitting}

%As with the dynamics, our stage-splitting algorithm for expressions in \lang\
%takes the form of two mutually-dependent judgments, $\splitonesym$ and
%$\splittwosym$, which respectively split terms that type $@ \bbone$ and $@
%\bbtwo$.

Although terms in \lang\ clearly distinguish their stage \bbone\ and stage
\bbtwo\ components, these components may be interleaved in complex ways. The
goal of \emph{stage splitting} is to produce from a term in \lang\ a pair of
terms in an unstaged language \langmono, which respectively perform all the
stage \bbone\ and stage \bbtwo\ subcomputations of the original term.

We begin by describing how to split stage \bbtwo\ terms.

%Since splitting stage \bbtwo\ terms from \lang\ is a simpler operation than
%splitting stage 1 terms, we first describe the mechanics of splitting stage
%\bbtwo, before moving to the more complex case of stage \bbone\ term splitting.

\subsection {Stage \bbtwo\ Splitting}

Splitting a stage-\bbtwo\ term $\coltwo e A$ produces a \emph{precomputation}
term $p$ and a \emph{resumer} function $l.r$, such that $e$ is equivalent to
$\letin l p r$. This is implemented by the judgment $\splittwosym$,
(\cref{fig:termSplitTwo}), which operates inductively on the structure of the
term.

For example, the stage \bbtwo\ term
\begin{lstlisting}
2`hold{`1` 1+2 `2`} < hold{`1` 3+4 `2`} - 5`
\end{lstlisting}
splits into a precomputation \verb|(1+2,3+4)| and a resumer
\verb|(L1,L2) => L1 < L2-5|, with the property that the resumer applied to the
precomputation must agree with the original term. This process of hoisting stage
\bbone\ subterms out of $e$ is called \emph{precomputation lifting}, and
intuitively, amounts to computing a data structure which is consumed by $r$.

Since base types and variables have no stage \bbone\ content, their
precomputations are \texttt{()}, and are not used in the resumer. At every other
expression except $\prev$, splitting bundles the precomputations of the
constituent parts, and then unbundles them with a pattern, with the resumer
precisely resembling the original expression. The $\prev$ rule depends on
splitting stage \bbone\ terms, which is covered later.

%As mentioned before, the only responsibility of $\splittwosym$ is to lift
%out the precomputation from contained stage \bbone\ code into a single
%expression $p$, leaving a resumer $l.r$ to interpret the results of that
%precomputation.

\subsection{(Partial) Value Splitting}

As described above, splitting a stage \bbtwo\ value always produces a trivial
precomputation---either \texttt{()}, or nested tuples thereof. Intuitively,
this is because stage-\bbtwo\ values contain no stage \bbone\ computations.

The same is not true of partial values (at stage \bbone), which \emph{can}
contain stage \bbtwo\ computations, namely, inside $\next$ blocks, which must
contain a variable reference to some future context, and inside lambdas, which
may contain a $\next$ in their body.

Thus, to split partial values, we must separate the contents of $\next$ blocks
from the rest of the term, while maintaining the term's original structure. This
is implemented by the judgment $v \vsplito [v_1,v_2]$ (\ref{fig:valSplit}).
At product, sum, and recursive types, splitting acts recursively, gathering all
subterms' stage $w$ content into $v_w$.
At base types, splitting assigns $v$ entirely to stage \bbone\ (and \texttt{()}
to stage \bbtwo);
on the other hand, at $\fut$ types, splitting assigns $v$ (which must have the
form $\next~\hat y$) entirely to stage \bbtwo\ (and \texttt{()} to stage
\bbone).
This process of exposing only the relevant structure of a term at each stage is
called \emph{masking}.

\ur{The case for ``roll'' seems missing in partial value splitting rules.}

Splitting a function is more complex, because function bodies are open terms,
and so are split by the judgments described in the next subsection. Essentially,
functions will split into two functions, whose bodies correspond to the stage
\bbone\ and stage \bbtwo\ components of the original function body.

\ur{Unclear whether the term ``masking'' includes the case for
  functions or not.  If it does, then it sounds rather
  inaccurate.  If not, then it should be stated clearly that it does
  not, but then what is the value of introducing one more term?}

%Indeed it would be almost nonsensical to talk of an algorithm for splitting
%stage \bbtwo\ values, since the precondition, that the input is a stage \bbtwo\
%value, is enough to imply the postcondition, that no stage interleaving remains

%Thus, it is meaningful to define some notion of splitting for them.  This is
%useful to study, because the definition will later be used as a contract with
%which general stage \bbone\ term splitting must comply.

%Recall that a partial value is externally a stage \bbone\ thing; it has a type
%$@~\bbone$, and along with a future context, it is the result of reducing a
%stage \bbone\ term. But internally, a partial value might contain stage \bbtwo\
%subexpressions.

\subsection{Stage \bbone\ Term Splitting}

Lifting and masking are two necessary ingredients for ensuring that splitting
observes the stages of \lang. When splitting a partial value, the stage \bbone\
result must \emph{mask} the stage \bbtwo\ computations in order to be
single-staged. When splitting a stage \bbtwo\ term, the precomputation must
\emph{lift} out all embedded stage \bbone\ computations, so they can be
performed first, even though their results are only used in stage \bbtwo.
%and it's accessible to whatever surrounding piece of code refers to the value being split.
%is not accessible externally.

Splitting a stage \bbone\ term, in contrast, requires both masking and splitting.
Consider the term 
\begin{lstlisting}
1`(next{`2`hold{`1` 1+2 `2`} < 5`1`},3*4)`
\end{lstlisting}
Masking yields the stage \bbone\ computation \verb|((),3*4)|, while lifting
yields the (stage \bbone) precomputation \verb|(1+2)|. While both computations
must occur at stage \bbone, the former is needed by stage \bbone, while the
latter is needed by stage \bbtwo.

The precomputation for this term is a \emph{combined result} which is
the pair of these components: \verb|(((),3*4),1+2)|. The resumer is
likewise the pair of the stage \bbtwo\ results of lifting and masking:
\verb|fn L => (L<5,())|.
%\footnote{In this example, the combined result is a 2-tuple, but more generally
%it only must be a term which reduces to a 2-tuple.}

Splitting is implemented by the judgment $\splitonesym$,
the rules for which are given in \cref{fig:termSplitOne}.  
It operates inductively on the structure of the term.  
The $\splitonesym$ judgment sends a stage \bbone\ term $e$ to a combined term
$c$ and resumer $l.r$. 

The rule for $\next$ simply tuples up the precomputation of its subexpression with a trivial immediate result,
while the rule for $\prev$ projects the combined result of its subexpression to isolate the precomputation.
It may seem like this $\prev$ rule is throwing information away, but we well show later that the first component 
of the evaluated form of $c$ in the $\prev$ rule must always be unit.
The $\pause$ rule treats the entire combined result of its subexpression as a precomputation, 
and projects out the integer result in the resumer.%
\footnote{The resumer of an integer expression is usually trivial, 
but we have to include it here for termination purposes.}

\subsection {Notable Properties}

\nr{These points will probably get lifted into the preceding sections.}

There are some particularly notable features of this definition of term
splitting.

\paragraph {Speculation}

In the stage \bbtwo\ rules for {\tt if}s, {\tt case}s, and functions, the
precomputation is lifted out from within branches. This is the manifestation of
the speculation behavior from the semantics.

\paragraph {Stage \bbone\ Divergence}

In the splitting rules for stage \bbone\ {\tt if} and {\tt case} expressions, we
have enough information at stage \bbone\ to know what branch to take, so there's
no need to speculate. Instead, we evaluate the stage \bbone\ portion of the
taken branch only, and inject the precomputation into a sum type. In the
resumer, we case on that injection, and resume the stage \bbtwo\ portion of the
correct branch.

\paragraph {Stage \bbone\ Functions}

The body of a stage \bbone\ function may contain stage \bbtwo\ computation. We
handle this by splitting the function into two functions: one in the immediate
result which handles all the stage \bbone\ content of the original, and one in
the resumer which handles all of the stage \bbtwo\ content. Note that stage
\bbone\ lambdas are partial values, and so have only a trivial precomputation.

\paragraph {Typing the Boundary}

\TODO add the example which shows that we need dynamic types

\input{figures/splitting-term}

\TODO say something about correctness criteria for splitting? (see
\texttt{obsolete/correctness.tex})

\subsection{Cost}

\TODO don't use that word

While these splitting rules are all correct in terms of producing the right values, applying them naively can result in terms with needlessly large cost.  Consider the following example involving the factorial function:
\begin{lstlisting}
2`prev{
  1`letfun fact (n : int) : int = 
    if n <= 0 then 1 else fact(n-1)*n
  in next{`2`hold {`1`fact 5`2`}-100`1`}`2`
}`
\end{lstlisting}

The boundary type\footnote{The splitting results are untyped, but we add in type annotations to aid the reader.} of this is give by the following datatype declaration:
\begin{lstlisting}
datatype prec = L | R of prec
\end{lstlisting}
The example then splits into the precomputation,
\begin{lstlisting}
1`letfun fact (n : int) : int * prec = 
  if n <= 0 then (1,L) 
  else let (y,z) = fact(n-1) in (y*n,R z)
in ((),fact 5)`
\end{lstlisting}
and the resumer
\begin{lstlisting}
2`l.
letfun fact (n : unit, l0 : prec) : unit = 
  case l0 of L => () | R l1 => fact ((),l0)
in (fact (#2 l); #1 l)-100`
\end{lstlisting}
The problem here is that the naive system doesn't realize that the \texttt{fact} function has no stage \bbtwo\ content,
and so it pessimistically retraces all of its steps in the resumer.  
Fixing this requires some recursive reasoning.  

We instead tried to solve the issue by adding a single new staging annotation to \lang, called \texttt{mono}.  
A \texttt{mono} block must appear in a stage \bbone\ context, and it indicates that its entire context is monostage.
This can be encoded in our statics and dynamics by adding a new stage \bbmono\ and the judgements:
\begin{mathpar}
\infer{\typesone{\monoSt~e}A}{\typesmono e A} \and
\infer{\diaone{\monoSt~e}{\cdot;v}}{\diaone{e}{\cdot;v}}
\end{mathpar}

The splitting rule for \texttt{mono} is more difficult.
...
transition to dummy.

The evaluation rules for dummy values are given by:
\begin{mathpar}
\infer{e_1~e_2~\redsym~\mathtt{dummy}}{e_1~\redsym~\mathtt{dummy} & e_2~\redsym~v} \and
\infer{\unroll~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pio~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pit~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}
\end{mathpar}

The basic idea here is that dummy will dynamically be whatever data structure you want it to be.

This is safe because [nico is just throwing something out here] 
it can only appear in the resumers of terms that have no circles in their \lang\ type.
Since the $\prev$ rule requires a circle type, dummy values cannot leak from
the resumers of stage \bbone\ terms into the resumers of stage \bbtwo\ terms.

\input{figures/splitting-misc}
