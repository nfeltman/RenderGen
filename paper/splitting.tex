
\section{Splitting Algorithm}

Motivate splitting here.  (Depends on intro)
Consider splitting at \bbtwo. 
The basic idea is that, for a given input program, we want to find all of the stage \bbone\ content, pull that out into a single term, 
and also produce a stage \bbtwo\ term, which takes the results of the stage \bbone\ part and produces the final answer.
We call these two parts the {\em precomputation} and the {\em residual}, respectively.
More formally, we want to take some $\coltwo e A$ and produce a $p : \tau$ and a $r : \tau \to A$ such that $e$ and $(r~p)$ reduce to the same value.

\subsection {Splitting If Statements}

Consider the following stage \bbtwo\ example:
\begin{lstlisting}
if 6*7 > 41 then
	hold{1+2} * 3
else 
	hold{2*3} + hold {4*5}
\end{lstlisting}
Under the definitions above, this should split into:
\begin{lstlisting}
(1+2,2*3,4*5)
\end{lstlisting}
and
\begin{lstlisting}
fn (l1,l2,l3) => 
    if 6*7 > 41 then l1 * 3 else l2 + l3
\end{lstlisting}
Essentially what we've done is find all of the $\pause$ expressions, 
bundle them into a tuple in then precomputation, 
and then unbundle them into the correct place in the residual.
Note how splitting has the same speculative behavior as our \lang\ dynamics,
wherein we run the stage \bbone\ code in {\em both} branches of the stage \bbtwo\ {\tt if} expression.

Now consider splitting the following expression, where the {\tt if} is at stage \bbone, rather than stage \bbtwo:
\begin{lstlisting}
prev {
  if 6*7 > 41 then
    next{1+hold{2*3}}
  else 
    next{4+5}
}
\end{lstlisting}
This splits into
\begin{lstlisting}
if 6*7 > 41 then inL (2*3) else inR ()
\end{lstlisting}
and
\begin{lstlisting}
fn l => 
  case l of
    l1 => 1+l1
  | () => 4+5
\end{lstlisting}
Here, there's no need to speculate.
Instead, we evaluate the stage \bbone\ portion of only the active branch, and then inject the result into a sum type.
Then in the residual, we case on that sum and resume the stage \bbtwo\ portion of the correct branch.

\subsection {Splitting at the First Stage}

Consider the example from section \ref{nonDup}:

\begin{lstlisting} 
prev{
  let x = (next {1+2}, 3+4) in
  next{prev{#1 x} * prev{#1 x} * prev{hold(#2 x)}}
}
\end{lstlisting}

It's not clear whether the {\tt x} binding should be thought of as happening at stage \bbone\ or stage \bbtwo.
The variable itself is of course at stage \bbone, but the expression that is bound to it has some stage \bbtwo\ content, namely \verb|1+2|.
The solution is to think of {\tt x} as existing at both stages, and so it appears in the precomputation {\em and} the residual.
Here's the precomputation:
\begin{lstlisting} 
let x = ((), 3+4) in 
#2 x
\end{lstlisting}
and the residual:
\begin{lstlisting} 
fn l =>
  let x = (1+2, ()) in 
  (#1 x) * (#1 x) * l
\end{lstlisting}
What we see is that {\tt x}, which has type $A = \rmint \times \fut \rmint$ in the original program, 
has types $A_1 = \rmint \times \rmint$ in the precomputation and $A_2 = \rmunit \times \rmint$ in the residual.
We call $A_1$ and $A_2$ the first and second {\em images} of $A$.

\subsection {Splitting Functions}

The trick when splitting functions is that the contents themselves may be multi-stage.
Thus the boundary type appears as output of the first stage and input of the second stage.
This makes it hard to type the output, because the boundary types are not represented in the original function type.

\subsection {Formal Setup}

We express residuals as functions in the informal development above.
For reasons of concision, we equivalently represent residuals as terms open on a variable in the formal judgements.

The $\splitonesym$ judgment takes an open stage \bbone\ term to a combined term and a residual.
The $\splittwosym$ judgment takes an open stage \bbtwo\ term to a precomputation and a residual.

[develop the more formal version...]

  $\diatwo [\cdot;\cdot] e q$ and $\reduce q v$ iff $\reduce {r~p} {v}$.

[Present the splitting judgement.  Give statements of type and value correctness for splitting.  Give all of the splitting rules.  Talk through a few of them.]

\subsection {Boundary Type Worst Case}

\TODO add the example which is the worst case for figuring out boundary types

\input{figures/splitting-term}
\input{figures/splitting-sumfun}

\section{Examples for Staged Pipelines}

Give the gist of one-to-one pipeline example (like client/server).
Then talk about a one-to-many pipeline.
Then talk about a many-to-one pipeline like spark.  It clear how to target something like this for known base types on the boundary, and for product types.  But sums on the boundary are hard!  We leave many-to-one as future-work.
