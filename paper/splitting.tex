
\section{Splitting Algorithm}

The basic idea is that we want to take a term which contains interleaved stage \bbone\ and stage \bbtwo\ code
and untangle it into two separate terms: one with all of the stage \bbone\ code and one with all the stage \bbtwo\ code.
To facilitate communication between the stages, there is a data structure passed between the stages, 
which is an output of the stage \bbone\ term and and input to the stage \bbtwo\ term.

As with the dynamics, the form of the splitting statement depends on the external stage of the term.
We consider splitting for stage \bbtwo\ terms first, as it has a simpler form.  
For example, take \verb|hold{1+2} < 5|.
We can split this into two separate terms, \verb|1+2| and \verb|fn l => l < 5|, 
which are called the {\em precomputation} and {\em residual}, respectively.  
For this splitting to be correct, the residual applied to the precomputation should yield the same result as the original term.  

The form of splitting for stage \bbone\ terms is more complicated.

\subsection {Splitting If Statements}

Consider the following stage \bbtwo\ example:
\begin{lstlisting}
if 6*7 > 41 then
	hold{1+2} * 3
else 
	hold{2*3} + hold {4*5}
\end{lstlisting}
Under the definitions above, this should split into:
\begin{lstlisting}
(1+2,2*3,4*5)
\end{lstlisting}
and
\begin{lstlisting}
fn (l1,l2,l3) => 
    if 6*7 > 41 then l1 * 3 else l2 + l3
\end{lstlisting}
Essentially what we've done is find all of the $\pause$ expressions, 
bundle them into a tuple in then precomputation, 
and then unbundle them into the correct place in the residual.
Note how splitting has the same speculative behavior as our \lang\ dynamics,
wherein we run the stage \bbone\ code in {\em both} branches of the stage \bbtwo\ {\tt if} expression.

Now consider splitting the following expression, where the {\tt if} is at stage \bbone, rather than stage \bbtwo:
\begin{lstlisting}
prev {
  if 6*7 > 41 then
    next{1+hold{2*3}}
  else 
    next{4+5}
}
\end{lstlisting}
This splits into
\begin{lstlisting}
if 6*7 > 41 then inL (2*3) else inR ()
\end{lstlisting}
and
\begin{lstlisting}
fn l => 
  case l of
    l1 => 1+l1
  | () => 4+5
\end{lstlisting}
Here, there's no need to speculate.
Instead, we evaluate the stage \bbone\ portion of only the active branch, and then inject the result into a sum type.
Then in the residual, we case on that sum and resume the stage \bbtwo\ portion of the correct branch.

\subsection {Splitting at the First Stage}

Consider the example from section \ref{nonDup}:

\begin{lstlisting} 
prev{
  let x = (next {1+2}, 3+4) in
  next{prev{#1 x} * prev{#1 x} * hold{#2 x}}
}
\end{lstlisting}

It's not clear whether the {\tt x} binding should be thought of as happening at stage \bbone\ or stage \bbtwo.
The variable itself is of course at stage \bbone, but the expression that is bound to it has some stage \bbtwo\ content, namely \verb|1+2|.
The solution is to think of {\tt x} as existing at both stages, and so it appears in the precomputation {\em and} the residual.
Here's the precomputation:
\begin{lstlisting} 
let x = ((), 3+4) in 
#2 x
\end{lstlisting}
and the residual:
\begin{lstlisting} 
fn l =>
  let x = (1+2, ()) in 
  (#1 x) * (#1 x) * l
\end{lstlisting}
What we see is that {\tt x}, which has type $A = \rmint \times \fut \rmint$ in the original program, 
has types $A_1 = \rmint \times \rmint$ in the precomputation and $A_2 = \rmunit \times \rmint$ in the residual.
We call $A_1$ and $A_2$ the first and second {\em images} of $A$.

\subsection {Splitting Functions}

The trick when splitting functions is that the contents themselves may be multi-stage.
Thus the boundary type appears as output of the first stage and input of the second stage.
This makes it hard to type the output, because the boundary types are not represented in the original function type.

\subsection {Formal Setup}

We express residuals as functions in the informal development above.
For reasons of concision, we equivalently represent residuals as terms open on a variable in the formal judgements.

The $\splitonesym$ judgment takes an open stage \bbone\ term to a combined term and a residual.
The $\splittwosym$ judgment takes an open stage \bbtwo\ term to a precomputation and a residual.

[develop the more formal version...]

  $\diatwo [\cdot;\cdot] e q$ and $\reduce q v$ iff $\reduce {r~p} {v}$.

[Present the splitting judgement.  Give statements of type and value correctness for splitting.  Give all of the splitting rules.  Talk through a few of them.]

\subsection {Boundary Type Worst Case}

\TODO add the example which is the worst case for figuring out boundary types

\input{figures/splitting-term}

\section{Examples for Staged Pipelines}

Give the gist of one-to-one pipeline example (like client/server).
Then talk about a one-to-many pipeline.
Then talk about a many-to-one pipeline like spark.  It clear how to target something like this for known base types on the boundary, and for product types.  But sums on the boundary are hard!  We leave many-to-one as future-work.
