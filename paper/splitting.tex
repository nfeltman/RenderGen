%!TEX root = paper.tex

\section{Splitting Algorithm}
\label{sec:splitting}

\input{figures/splitting-overview}

\begin{abstrsyn}

%Although the type system of \lang\ ensures that we can perform all first-stage
%computations before any second-stage ones, actually evaluating terms in this
%fashion is rather involved, because stages are syntactically interleaved
%within terms.

In this section, we present a {\em splitting algorithm} that
statically converts a term in \lang\ into a pair of monostaged terms
that individually correspond to the first and second stage
computations of the original \lang\ term. Due to important differences
in structure, we describe both the invariants and algorithm for
splitting \bbonem\ terms separately from that of \bbtwo\ terms.  By
construction, \bbonep\ terms are monostage and do not require
splitting.

\textbf{\bbtwo\ term splitting.}  As suggested informally in
\ref{sec:example}, splitting a \lang\ program (a \bbtwo\ term) should
yield two monostage terms where evaluating the second term
(corresponding to second stage computations) on the output of the
first term (first stage computations), yields the same result as
direct evaluation of the original \lang\ program.  More precisely, for
any $\coltwo e A$ which reduces to a residual $q$ (via $\diatwo e q$),
$e$ splits (via the new relation~$\splittwosym$) into a pair of terms
$\pipeS p l r$ where $\reduce p b$, and $[b/l]r$ is the same as $q$ up
to an equivalence. The term $p$ generated by the split (called the
{\em precomputation}, due to its role producing the inputs for
subsequent second stage computation) is a monostage term representing
all the first-stage computations in $e$. The term $l.r$ (called the
{\em resumer}) is a monostage term representing all the second-stage
computations in $e$.  We refer to the result of the precomputation
($b$) the {\em boundary value} of the split since it represents the
data communicated between the first and second stage computations.
The process of splitting \bbtwo\ terms (and the relationship of these
operations to the outputs of direct \lang\ evaluation) is provided at
right in \ref{fig:splittingSummary}.
% and described in detail in \ref{sec:split-two}.


% $\sepredtwosym$ is defined
% by a single rule, which evaluates the precomputation and substitutes
% the resulting value in for $l$ in the resumer:
%\[
%\infer{{[b/l]r}\equiv q} {\reduce p b}
%\]

\textbf{\bbonem\ term splitting.} Defining the requirements for
splitting \bbonem\ terms is challenging because unlike \bbtwo\ terms
(which reduce to monostage residuals that can be directly compared to
resumers), \bbonem\ terms reduce to residual tables and partial values
that represent computations at both stages.
%One complication arises from the fact that \lang\ terms at world \bbonem\ produce multistage output.
%For example, the \bbonem\ term:
%\begin{lstlisting}
%(next {1+2}, grnd{3+4})
%\end{lstlisting}
%reduces (via $\redonesym$) to the residual table and partial value:
%\begin{lstlisting}
%[yhat |-> 1+2] (next {yhat}, grnd{7})
%\end{lstlisting}

To resolve the mismatch between the multi-stage computations
represented by residual tables and partial values and the desired
monostaged outputs of splitting, we choose to define a translation,
called {\em masking}, written $\rtab \xi v \vsplito \mval i q$, which
converts residual tables and partial values into a {\em masked value}.
The first part of the masked value, $i$, is a monostage value holding
the result of all first stage components of $v$.  The second
component, $q$, is a residual representing all second stage
computations in $\xi$ and $v$. (A precise definition of masking is
given in \ref{sec:masking}.)

We define the requirements for splitting \bbonem\ terms using the
results of masking. Specifically, for any $\colmix e A$ which reduces
to $\rtab \xi v$ (via $\redonesym$), masking yields the masked value
$\mval i q$ (via~$\vsplito$).  Then $e$ splits (via the new
relation~$\splitonesym$) into the monostage terms $\pipeM c l r$ where
$\reduce c (i,b)$, and $[b/l]r$ is the same as $q$ up to an
equivalence.  The term $c$ generated by splitting (called the {\em
  combined term}) is a monostage term encoding all the first-stage
computations in $e$, and $l.r$ (again called the {\em resumer}) is a
monostage term encoding all the second-stage computations in $e$.  The
process of splitting \bbonem\ terms is summarized at left in
\ref{fig:splittingSummary}.
% and described in detail in \ref{sec:split-one}.


%$\sepredonesym$ is defined by a single rule that yields masked values:
%\[
%\infer{\sepredone {\pipeM c l r} {\mval i {[b/l]r}}} {\reduce c {(i,b)}}
%\]

Note that since $\coltwo e A$ reduces to an entirely second-stage
residual, its first-stage computations only exist to generate input
for second stage computations.  In contrast, since $\colmix e A$
reduces to a multi-stage residual table and partial value, its first
stage computations serve to both generate the value used as input for
the second stage {\em and also} produce a first-stage value.
Correspondingly, the precomputation $p$ resulting from splitting
\bbtwo\ terms reduces only to a boundary value $b$ which is passed to
the resumer; but the combined term $c$ resulting from splitting
\bbonem\ terms reduces to a tuple containing both the first stage {\em
  immediate result} $i$ and the boundary value $b$ (motivating the
name {\em combined term}).

The following subsections formally define the masking transformation
($\vsplito$), then describe the algorithm for splitting both
\bbonem\ terms ($\splitonesym$) and \bbtwo\ terms ($\splittwosym$).
  
\subsection{Masking}
\label{sec:masking}

Masking converts a residual table and associated partial value into a
masked value $\mval i q$.
%that explicitly separates the first stage components of 
%result from the residual.
%where $i$ is a monostage value encoding all
%first stage components of the partial value, and $q$ is a monostage
%term encoding all of the second-stage computations of the partial
%value.
Masking is not a transformation performed as part of the splitting
algorithm.  Instead, masking defines an intuitive notion of the first
stage and second stage ``components'' of residual tables and partial
values, and it is used to define the requirements of what output
splitting of \bbonem\ terms must produce.  A precise definition of the
masking relation is given in \ref{fig:valMask}, but to gain intuition
about the intent of masking operations, consider the following
residual table and partial value, colored as before:
\begin{lstlisting}
2`[yhat |-> 1+2]`1` (next{`2`yhat`1`}, injL (grnd{7}, next{`2`yhat`1`}))`
\end{lstlisting}
To construct a value representing its first-stage components ($i$ in
the resulting masked value), masking first redacts all second stage
(blue) parts, along with the surrounding \texttt{next}
annotations. (This redaction removes the entire residual table since
it only represents stage two computations.) The resulting ``holes'' in
the term are replaced with unit values.
%\begin{lstlisting}
%4`##########`1` (`4`######`1`, injL (grnd{7}, `4`######`1`))`
%\end{lstlisting}
%The holes inside the term needs to be filled with something to convey the lack of information, so we use a unit values:
\begin{lstlisting}
1`((), injL (grnd{7},()))`
\end{lstlisting}
Finally, masking dropping \texttt{grnd} annotations yielding a value.
\begin{lstlisting}
1`((), injL (7,()))`
\end{lstlisting}
To construct a residual corresponding to the stage two computations
represented by the residual table and partial value ($q$ in resulting
the masked value), masking first redacts all \texttt{grnd} blocks
(replaced with unit), \texttt{next} annotations, and injection tags
(essentially, the tuple structure is kept, but all other structure is
discarded):
%\begin{lstlisting}
%2`[yhat |-> 1+2]`1` (`4`####`2`yhat`4`#`1`, `4`####`1` (`4`####`1`,`4`####`2`yhat`4`#`1`))`
%\end{lstlisting}
%Where the \texttt{grnd} blocks left a hole, we put in a unit values:
\begin{lstlisting}
2`[yhat |-> 1+2] (yhat, ((),yhat))`
\end{lstlisting}
Then masking reifies the residual table into \texttt{let} bindings,
yielding a residual:
\begin{lstlisting}
2`let yhat = 1+2 in (yhat, ((),yhat))`
\end{lstlisting}

Note in \ref{fig:valMask} that since lambdas may represent multistage
computations, masking splits the body of lambdas as general world
\bbonem\ terms (as described in \ref{sec:split-one}), and packages the
resulting terms as functions in both the first and second stage parts
of the masked value.
% Masking operates by first inducting on the entries of the residual table.  
% Being purely second-stage content, these are reified into let statements at the top of the resumer.
% Once the table is empty, masking inducts on value itself.

% Masking assigns ground values to the immediate value
% and likewise assigns references into the residual table to the resumer.
% In both cases, the alternate component is assigned to $\tup{}$, to represent trivial information.
% Note that the \texttt{grnd} and \texttt{next} annotations are erased.

% Masking distributes into tuples, injections, and rolls, since their subvalues may have content at both stages.
% However, the tags of injections and rolls are replicated only in the immediate value, 
% since they represent first-stage information.

\subsection{Term Splitting at \bbonem}
\label{sec:split-one}

We now show how to translate terms $\colmix e A$ into the form $\pipeM c l r$,
pursuant to the correctness condition given in \ref{fig:splittingSummary}.
The algorithm is specified by the $\splitonesym$ relation (\cref{fig:termSplit}), 
which proceeds recursively on the structure of~$e$.

We start with splitting the unit value, $\tup{}$.
Masking tells us that units, being trivial, only split into more units: $\tup{} \vsplito \mval {\tup{}} {\tup{}}$.
Plugging this in to the contract for splitting at \bbonem\ gives:
\[
	\text{if } \splitone {\tup {}} A c {l.r} \text{ then } \reduce c {\tup{\tup{},b}} \text{ and } [b/l]r \equiv \tup{}
\]
Although the only hard requirement for $b$, $c$, and $l.r$ is to satisfy these relations,
our actual choices are designed to do the least work possible.
In particular, we choose $b = \tup{}$; $c=\tup{\tup{},\tup{}}$; and $l.r = \_.\tup{}$.
That is, we choose a trivial boundary value.
All together, this yield the rule in \cref{fig:termSplit}.
This exercise proceeds much the same way for \texttt{grnd} blocks, 
with the purely first stage contents of the block standing in for one of the $\tup{}$s.

We next consider splitting a non-terminal, namely $\inl {e}$.
From the semantics, we already know that 
for some $\xi$ and $v$, $\diaone {e} \xi v$ and $\diaone {\inl e} \xi {\inl v}$.
Masking these outputs gives $\rtab \xi v \vsplito \mval i q$ 
and $\rtab \xi {\inl v} \vsplito \mval {\inl i} q$.
Since splitting works from the inside out, we already know that
\[
	\splitone e A c {l.r} \text{ and } \reduce c {\tup{i,b}} \text{ and } [b/l]r \equiv q
\]
and what we need to do is find some $b'$, $c'$, and $l'.r'$ satisfying
\[
	\reduce {c'} {\tup{\inl i,b'}} \text{ and } [b'/l']r' \equiv q
\]
Once again, we take the simplest solution, which in this case is $b' = b$; $l'.r' = l.r$;
and $c' = \letin {\tup {x,y}} c {\tup{\inl x, y}}$.  
This sort of technique generalize to all constructs which don't involve control flow.

\nr{working from here down}

Splitting {\tt case} yields a combined term that executes one of the branches' combined terms based on the immediate result $y_1$ of the predicate.
The boundary value $b_i$ for this branch is injected and bundled with that of the predicate ($b_1$).   
$b_i$ is cased in the resumer to determine which branch's resumer should be executed.
{\tt case} is the only rule where splitting adds non-trivial logic is added to the precomputation.

Function introduction has a $\tup{}$ boundary value,
since functions are already fully reduced in our semantics.
However, since the body of a function may itself be multistage, splitting must continue into it.
The immediate result is a new function formed from the first-stage part of the original body.
The resumer is a new function formed out of the second-stage part of the original body.
It is the responsibility of the application site to save the precomputation of the function body
and pass it to the resumer version of the function.

Since the results of splitting \texttt{next} terms depend on the output of
splitting its world \bbtwo\ subterm,
we defer description of \texttt{next} until after describing world \bbtwo\ term splitting.

\subsection{Term Splitting at \bbtwo}

Because world \bbtwo\ terms in \lang\ reduce to monostage residuals (as opposed to partial values),
term splitting at world \bbtwo\ assumes a simpler form than the version at \bbonem\ does. 
The algorithm is specified by the $\splittwosym$ relation in \cref{fig:termSplit}.

In the terminal cases of
constants and variables, splitting generates trivial precomputations that are \texttt{()}, and resumers consisting of the original term.
For example, the integer constant \texttt{3} splits into the
precomputation \texttt{()} and resumer \texttt{\_=>3}.

More generally, for all (except \texttt{prev}) 
$n$-ary terms $e = \mathcal{C}\ttlpar e_1 \ttsemi \ldots \ttsemi e_n \ttrpar$ 
the precomputation is the tupled precomputations of $e$'s $n$ subterms:
$p=(p_1,\ldots,p_n)$.  The resumer binds each boundary value to an
argument $(l_1,\ldots,l_n)$ in a term that has the same structure
of~$e$ but where each subterm is replaced by its corresponding resumer:
$r = \mathcal{C}\ttlpar r_1 \ttsemi \ldots \ttsemi r_n \ttrpar$ .
Notably, at \texttt{case}s and functions the
precomputation of subterms is lifted out from underneath world \bbtwo\ binders.  
% TODO: should probably draw a parallel to the same behavior in dynamics

Splitting \texttt{prev} generates a precomputation that projects the immediate
result of its world \bbone\ subterm.
Since the argument to \texttt{prev} is of $\fut$ type, its immediate result reduces to $\tup{}$, justifying why it can be thrown away.
Finally, splitting \texttt{next} simply tuples up the precomputation of its
world \bbtwo\ subterm with a trivial immediate result $\tup{}$.

\subsection {Necessity of \bbonep}
\label{sec:needGround}

We have not yet given a justification for why first stage code must be
partitioned between the worlds \bbonem\ and \bbonep.
Certainly one could imagine a simpler system without all the \texttt{grnd} annotations.  
Why wouldn't this work?

In order to be correct, any code at \bbonem\ must be split with the 
pessimistic assumption that it may result in work at the second stage.
When this assumption turns out not to be true---that is, purely monostage code---then 
splitting may produce second stage code which is needlessly costly 
(an example of this will occur in \ref{sec:exampleQS}).
Detecting and optimizing this case is in general a global program analysis,
since functions can be passed around as values.  
So instead of relying on hefty analysis, 
we take the approach of adding enough structure to the input language's type system to
allow the input code to {\em prove} itself to be---in some parts---monostage.

We find that giving input with \texttt{grnd} annotations is not especially cumbersome in practice.
Yet even if a language designer desired a different implicit/explicit trade-off,
then the three-world \lang\ would still be useful as a typed intermediate representation.

\end{abstrsyn}

\input{figures/splitting-misc}
\input{figures/splitting-term}
