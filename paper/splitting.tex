
\section{Splitting Algorithm}

\input{figures/splitting-term}
\input{figures/splitting-sumfun}

[Present the splitting judgement.  Give statements of type and value correctness for splitting.  Give all of the splitting rules.  Talk through a few of them.]

\section{Examples for Staged Pipelines}

Give the gist of one-to-one pipeline example (like client/server).
Then talk about a one-to-many pipeline.
Then talk about a many-to-one pipeline like spark.  It clear how to target something like this for known base types on the boundary, and for product types.  But sums on the boundary are hard!  We leave many-to-one as future-work.


\section{Examples of Algorithm Derivation}

Fast exponent example.  

\begin{lstlisting} 
let exp (b : $int, e : int) : $int =
	if e == 0 then
		next{1}
	else if (e mod 2) == 0 then
		next{let x = prev{exp(b,e/2)} in x*x}
	else
		next{prev{b} * prev{exp (b,e-1)}}		
\end{lstlisting}

splits into

\begin{lstlisting} 
let exp (b, e) =
	((), roll (
		if e == 0 then
			inL ()
		else 
			inR (
				if (e mod 2) == 0 then
					inL (#2 (exp (b,e/2)))
				else
					inR (#2 (exp (b,e-1)))
			)
	))
\end{lstlisting}

and

\begin{lstlisting} 
let exp ((b, e), p) =
	case unroll p of
	  () => 1
	| d  =>
		case d of
		  r => let x = exp ((b,()),r) in x*x
		| r => b * exp ((b,()),r)
\end{lstlisting}

Quickselect example.

\begin{lstlisting} 
let qs (l : "*$\mathtt{\mu \alpha. }$*"() + "*$\mathtt{int*\alpha}$*", i: $int) = 
	case unroll l of
	  () => next {0}
	| (h,t) => 
		let (left,right,n) = partition h t in
		next{
			let n = prev{hold n} in
			case compare prev{i} n of
			  () (*LT*) => prev {qs left i}
			| () (*EQ*) => prev {hold h}
			| () (*GT*) => 
				prev {qs right next{prev{i}-n-1}}
		}	
\end{lstlisting}

Things to try: an interpreter which, partially evaluated, does cps or something.

For each of these examples, talk about what partial evaluation would do and why that might be bad.


[Meta-ML eases off on this restriction but does not (I think?) eliminate it.]

[What's going on with names and necessity?]

[Our work bears a lot of similarity to ML5, which also uses a modal type system.  The difference is that we target stages systems (each stage talks to the next), whereas they target distributed ones (all stages talk to all others). The type systems reflect this directly in the world accessibility relation.  There might be some analogue of stage-splitting in the ML5 work, but I have not yet isolated it (might be buried in CPS conversion).]

