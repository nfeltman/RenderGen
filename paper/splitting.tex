%!TEX root = paper.tex

\section{Splitting Algorithm}
\label{sec:splitting}

\input{figures/splitting-overview}

\begin{abstrsyn}

The goal of a stage splitting translation is to send programs in a multistage language
to a form where the stages are seperated at the top level.
To be valid, such a translation must meet two requirements:
at values it must not lose information,
and at terms it must respect the semantics.

For a two-stage language like \lang, this means translating a multistage
object into a pair of monostage objects
which respectively embody the first-stage and second-stage content of the original.
Since \lang\ has three classes of multistage object, 
our splitting algorithm has three forms: 
\bbtwo-term splitting, \bbonem-term splitting, and partial value splitting.
These are given by the judgements $\splittwo e A p l r$, $\splitone e A c {l.r}$, and $v \vsplito \mval i q$.
The rules of all three judgements are given in \ref{fig:termSplit}.

Before discussing the validity of these translations, 
we note that splitting is defined for all well-typed inputs (\ref{thm:total} in \ref{fig:splittingSummary}), and it produces unique results (\ref{thm:unique}).
That is, each splitting relation is a total function.
We prove these theorems by straightforward induction on the typing derivation
and simultaneous induction on the splitting derivations, respectively.

\subsection{Partial Value Splitting}
\label{sec:masking}

Partial value splitting (given by the relation $\vsplito$) converts a 
partial value $v$ into a split value $\mval i q$.
The first component of the split value, the \emph{immediate value} $i$, is a monostage value holding
the result of all first-stage components of $v$.  The second
component, $q$, is a residual representing all second-stage
variable references of $v$.

To provide intuition about the intent of partial value splitting, consider the
following partial value:
\begin{lstlisting}
1` (next{`2`yhat`1`}, (`3`gr{`1`injL 7`3`}`1`, next{`2`yhat`1`}))`
\end{lstlisting}
To construct the value $i$ representing its first-stage components,
splitting first redacts all second-stage (blue) parts, along with the
surrounding \texttt{next} annotations. 
The resulting ``holes'' in the term are replaced with
unit values.
%\begin{lstlisting}
%4`##########`1` (`4`######`1`, injL (gr{7}, `4`######`1`))`
%\end{lstlisting}
%The holes inside the term needs to be filled with something to convey the lack of information, so we use a unit values:
\begin{lstlisting}
1`((), (3`gr{`1`injL 7`3`}`,()))`
\end{lstlisting}
Finally, partial value splitting drops \texttt{gr} annotations yielding:
\begin{lstlisting}
1`((), (injL 7,()))`
\end{lstlisting}
To construct the residual $q$ (corresponding to second-stage computations) partial value splitting redacts all \texttt{gr} blocks
(replacing them with unit) and \texttt{next} annotations:
\begin{lstlisting}
2`(yhat, ((),yhat))`
\end{lstlisting}
A precise definition of the partial value splitting relation is given in
\ref{fig:valMask}.
Observe that partial value splitting does not lose any meaningful information (namely injection tags),
which is the validity requirement for a translation of value forms.

%Since lambdas may represent multi-stage computations, masking splits
%the body of lambdas as general world \bbonem\ terms (as described in
%\ref{sec:split-one}), and packages the resulting terms as functions in
%both the first- and second-stage parts of the masked value.

% Masking operates by first inducting on the entries of the residual table.  
% Being purely second-stage content, these are reified into let statements at the top of the resumer.
% Once the table is empty, masking inducts on value itself.

% Masking assigns ground values to the immediate value
% and likewise assigns references into the residual table to the resumer.
% In both cases, the alternate component is assigned to $\tup{}$, to represent trivial information.
% Note that the \texttt{gr} and \texttt{next} annotations are erased.

% Masking distributes into tuples, injections, and rolls, since their subvalues may have content at both stages.
% However, the tags of injections and rolls are replicated only in the immediate value, 
% since they represent first-stage information.

\subsection{World \bbtwo\ Term Splitting}

For any $\coltwo e A$
which reduces to the residual $\exv q$ (via repeated $\stepsym \bbtwo$),
splitting $e$ (via $\splittwosym$)
yields a pair of monostaged terms $\pipeS p l r$, where $p$ and $l.r$
contain all first- and second-stage computations in $e$ respectively.

This output is a multistage program in its own right.
It evaluates by reducing $p$ to $b$ in the first pass,
then plugging that result in for $l$ to produce $[b/l]r$,
which is evaluated in the second pass.
Since execution of the first pass serves to generate input for
the second pass, we say $p$ is a {\em precomputation} that produces a
{\em boundary value} ($b$) for the {\em resumer} ($l.r$).

We define the correctness of splitting 
by saying that $[b/l]r$, the \emph{applied resumer}, should be equivalent 
to the residual produced by direct evaluation, $q$.
We state this more precisely as \ref{thm:allCorrect},
where ``$\reduce e v$'' indicates standard monostage reduction of the term $e$ to the value $v$,
and ``$\equiv$'' indicates a monostage equivalence, which we cover later.

We prove \ref{thm:allCorrect} by induction on the steps of evaluation.  
In the base case, where $e$ is already a residual of the form $\exv q$, we know
$\splittwo {\exv q} A {\exv{\tup{}}} \_ q$, and so by uniqueness of splitting, 
$p = \tup{}$ and $r = q$.
From here, we can directly derive $\reduce {\exv {\tup {}}} {\tup {}}$ and $q \equiv q$.

In the recursive case, we have 
$\typestwo [\cdot] e A$, $e \stepsym \bbtwo e' \stepsym \bbtwo \cdots \stepsym \bbtwo \exv q$, and $\splittwo e A p l r$.
To help this case, we introduce \ref{lem:twoCorrect}, whose proof will concern the rest of this section.
By preservation and totality of splitting, we know $\typestwo [\cdot] {e'} A$ and $\splittwo {e'} A {p'} {l'} {r'}$.
The inductive hypothesis yields $\reduce {p'} {b'}$ and $[b'/l']r' \equiv q$.
From here, \ref{lem:twoCorrect} then gives $\reduce p b$ and $[b/l]r \equiv [b'/l']r'$,
and we derive $[b/l]r \equiv [b'/l']r' \equiv q$ directly. \qed

All that remains is to prove \ref{lem:twoCorrect}.  
We will do this by induction on the derivation of the step.
However, since second-stage steps can depend on first-stage steps,
we first cover the definition of splitting terms at \bbonem.

\subsection{World \bbonem\ Term Splitting}

For any $\colmix e A$, 
splitting $e$ (via $\splitonesym$) again 
yields the pair of monostage terms $\pipeM c l r$. 

The responsibilities of this first stage component, $c$, can be seen as a combination of the
those of world \bbtwo\ term splitting and partial value splitting.
Since $e$ is a term, the first stage computations within it may yet still
affect its second stage computations,
and so $c$ needs to produces a boundary value $b$ to be passed to the resumer ($l.r$).
But since $e$ is a world \bbonem\ construct, it has an eventual result at the 
first stage as well as the second, and so it must produce an immediate value $i$.
The term $c$ meets both of these responsibilities by reducing to the tuple $\tup{i,b}$,
and so we call it a {\em combined term}.

The correctness of \bbonem\ term splitting with respect to $\stepsym \bbonem$ steps is given in \ref{lem:oneCorrect}.
Like with the \bbtwo\ version, this requires that the applied resumer be equivalent both sides of the step.
But additionally, it also requires that first stage results be exactly identical.

The correctness of \bbonem\ term splitting with respect to hoisting steps is given in \ref{lem:hoistCorrect}.
Because hoisting steps are nothing but rearrangement of second stage code,
this lemma can use the strong requirement of idnetical combined terms.

\subsection{Example cases.}

\TODO do some cases of the proof, and use the opportunity to discuss why splitting does what it does

\paragraph{\bbtwo\ Compatility.}
\paragraph{\bbone\ Compatility.}
\paragraph{Functions.}
\paragraph{Next and prev.}
\paragraph{Ground and Caseg.}

% \subsection{Term Splitting at \bbonem}
% \label{sec:split-one}

% Given the definition of masking, we now describe how to split
% \bbonem\ terms. The algorithm, given in \cref{fig:termSplit}, proceeds
% recursively on the structure of~$e$. We derive a few cases here.

% \paragraph {Unit.} 
% As a simple first case, consider splitting the unit value, $\tup{}$
% which masks to $\mval {\tup{}} {\tup{}}$.
% %Units trivial contain unit split into more units: $\tup{} \vsplito \mval {\tup{}} {\tup{}}$.
% Splitting must produce a $c$ and $l.r$ satisfying
% \[
% 	\reduce c {\tup{\tup{},b}} \text{ and } [b/l]r \equiv \tup{}
% \]
% Our algorithm uses $c=\tup{\tup{},\tup{}}$ and $l.r = \_.\tup{}$.
% Splitting $\pure{e}$ follows in similar fashion, except the first 
% component of $c$ now becomes the result of evaluating the \bbonep\ term $e$.

% \paragraph {Injections.}
% Now consider splitting the non-terminal $\inl {e}$, where $\diaone
% {e} \xi v$ and $\rtab \xi v \vsplito \mval i q$, and thus:
% \[
% 	\splitone e A c {l.r} \text{ and } \reduce c {\tup{i,b}} \text{ and } [b/l]r \equiv q
% \]
% Since $\diaone {\inl e} \xi {\inl v}$ and $\rtab \xi {\inl v} \vsplito \mval {\inl i} q$,
% splitting must produce a $c'$ and $l.r'$ satisfying
% \[
% 	\reduce {c'} {\tup{\inl i,b'}} \text{ and } [b'/l]r' \equiv q
% \]
% Our algorithm generates a first pass $c'$ that produces the same
% boundary value as splitting $e$:
% \[
% c' = \letin {\tup {x,y}} c {\tup{\inl x, y}}
% \]
% Splitting the injection also generates the same resumer as splitting
% the subterm $e$ (that is, $l.r' = l.r$).

% \paragraph{Tuple.} For an example of splitting terms with more than one argument, consider the tuple $\tup{e_1,e_2}$,
% where $\diaone {e_k} {\xi_k} {v_k}$ and 
% $\rtab {\xi_k} {v_k} \vsplito \mval {i_k} {q_k}$ for $k = 1,2$.  
% Inductively:
% \[
% 	\splitone {e_k} A {c_k} {l_k.r_k} \text{ and } \reduce {c_k} {\tup{i_k,b_k}} \text{ and } [b_k/l_k]r_k \equiv q_k
% \]
% Since $\diaone {\tup{e_i,e_2}} {\xi_1,\xi_2} {\tup{v_1,v_2}}$ 
% and $\rtab {\xi_1,\xi_2} {\tup{v_1,v_2}}$ and $\tup{v_1,v_2} \vsplito \mval {\tup{i_1,i_2}} {\tup{q_1,q_2}}$,
% splitting generates:
% \[
% 	\reduce {c} {\tup{\tup{i_1,i_2},b}} \text{ and } [b/l]r \equiv \tup{q_1,q_2}
% \]
% The resulting boundary value is the tuple of the boundary values of
% the subterms, $b = \tup{b_1,b_2}$.  The value is 
% constructed using
% \[
% c = \letin{\tup{y_1,z_1}}{c_1}{\letin{\tup{y_2,z_2}}{c_2}{\tup{\tup{y_1, y_2},\tup{z_1, z_2}}}}
% \]
% and deconstructed in the resumer with a tuple pattern:
% \[
% l.r = \tup{l_1,l_2}.\tup{r_1,r_2}
% \]
% \paragraph {Case.}
% Splitting is most complicated at $\caseof {e_1} {x_2.e_2} {x_3.e_3}$ terms because of their divergent control flow.
% Here we consider only the case where
% $\diaone {e_1} {\xi_1} {\inl {v_1}}$ and \\ $\rtab {\xi_1} {\inl {v_1}} \vsplito \mval {\inl {i_1}} {q_1}$.
% (The \texttt{inr} case is analogous.)

% \noindent
% Inductively,
% \[
% 	\splitone {e_1} A {c_1} {l_1.r_1} \text{ and } \reduce {c_1} {\tup{\inl {i_1},b_1}} \text{ and } [b_1/l_1]r_1 \equiv q_1
% \]
% Additionally, the first branch evaluates $\diaone {[v_1/x_2]e_2} {\xi_2} {v_2}$
% and $\rtab {\xi_1,\xi_2} {v_2} \vsplito \mval {i_2} {q_2}$.
% Therefore:
% \begin{gather*}
% 	\splitone {e_2} A {c_2} {l_2.r_2} \text{ and } \reduce {[i_1/x_2]c_2}
%   {\tup{i_2,b_2}} \\
% \text{ and } [q_1/x_2][b_2/l_2]r_2 \equiv q_2
% \end{gather*}
% (Because $e_2$ is open on $x_2$, $\pipeM{c_2}{l_2}{r_2}$ is also open on $x_2$.
% When we substitute some $v_1$ for $x_2$ in $e_2$, we must substitute the masks
% of $v_1$ into $c_2$ and $l_2.r_2$.)

% The entire case evaluates as
% $\diaone {\caseof {e_1} {x_2.e_2} {x_3.e_3}} {\xi_1,\xi_2} {v_2}$, so splitting should produce 
% some $c'$ and
% $l'.r'$ such that 
% \[
%   \reduce {c'} {\tup{i_2,b'}} \text{ and }
%   [b'/l']r' \equiv q_2
% \]
% We choose
% \[
% c' =
% {\left(
% \talllet{\tup{y_1,z_1}}{c_1}{
% \tallcase{y_1}
% {x_2.\letin{\tup{y_2,z_2}}{c_2}{\tup{y_2,\tup{z_1,\inl{z_2}}}}}
% {x_3.\cdots\ttrpar}
% }\right)}
% \]
% \[
% l'.r' =
% \tup{l_1,l_b}.\letin{z}{r_1}{\caseof{l_b}{l_2.[z/x_2]{r_2}}{l_3.\cdots}}
% \]
% The term $c'$ reduces to
% $\tup{i_2,\tup{b_1,\inl{b_2}}}$, so 
% $b' = \tup{b_1,\inl{b_2}}$. Therefore
% $[b'/l']r'$ reduces to
% $[[b_1/l_1]r_1/x_2][b_2/l_2]r_2$, exactly the 
% $[q_1/x_2][b_2/l_2]r_2$ required.

% More intuitively, $c'$ cases on $i_1$ to run the first branch of first-stage
% code. The boundary value for that branch, $b_2$, is packaged as $\tup {b_1, \inl
% {b_2}}$. The resumer of the predicate uses $b_1$, and $\inl{b_2}$ signals to run
% the first branch's resumer. The second branches of $c'$ and $l'.r'$ are
% similarly constrained by the $\texttt{inr}$ case.

% %Recovering first stage divergence is easy, since for $\splitone {e_1} ? {c_1} {l_1.r_1}$, 
% %$\reduce {e_1} {\inl {v_1}}$ implies $\reduce {c_1} {\tup{\inl {i_1},b_1}}$.

% \paragraph {Function.} 
% Function introduction has a $\tup{}$ boundary value, since functions
% are already fully reduced in our semantics.  However, since the body
% of a function may itself be multistage, splitting must descend into
% it.  The first pass generated by splitting produces an $i$ that is a new
% function formed from the first-stage part of the original body.  The
% resumer is a new function formed out of the second-stage part of the
% original body.  It is the responsibility of the application site to
% save the precomputation of the function body and pass it to the
% resumer version of the function.

% \subsection{Term Splitting at \bbtwo}

% Because world \bbtwo\ terms in \lang\ reduce to monostage residuals
% (as opposed to partial values), term splitting at world
% \bbtwo\ (specified by the $\splittwosym$ relation in
% \cref{fig:termSplit}) is simpler than that of \bbonem.

% Consider any $n$-ary \bbtwo-term $e = \scriptCapp {e_1 \ttsemi \ldots
%   \ttsemi e_n}$ (except \texttt{prev}, which is discussed shortly).
% Note that for any $\diatwo e q$, the residual $q$ must have the form
% $\scriptCapp {q_1 \ttsemi \ldots \ttsemi q_n}$, even if $\mathcal{C}$ is
% nullary or the $q_i$ have binders.
% For each $k$, splitting the subterm $e_k$ yields $p_k$ and $l_k.r_k$ where
% \[
% 	\reduce {p_k} {b_k} \text{ and } [{b_k}/{l_k}]{r_k} \equiv {q_k}
% \]
% Correspondingly, splitting $\scriptCapp {e_1 \ttsemi \ldots \ttsemi e_n}$ generates $p$ and $l.r$ where
% \[
% 	\reduce p b \text{ and } [b/l]r \equiv \scriptCapp {q_1 \ttsemi \ldots \ttsemi q_n}
% \]
% Our algorithm accomplishes this by using $p = \tup {p_1, \ldots, p_n}$ and
% $l.r = \tup {l_1, \ldots, l_n}.\scriptCapp {r_1 \ttsemi \ldots \ttsemi r_n}$.

% %Again, this holds even for nullary terms and under binders.
% In particular, $\caseof{e_1}{x_2.e_2}{x_3.e_3}$ splits into:
% \[
% \pipeS {\tup{p_1,p_2,p_3}} {\tup{l_1,l_2,l_3}} {\caseof{r_1}{x_2.r_2}{x_3.r_3}}
% \]
% Note how the precomputations of $e_2$ and $e_3$ are pulled out from
% underneath the binder into a tuple that is always executed in the
% first stage. This occurs regardless of what branch is eventually
% executed in the second stage.

% \paragraph{Staging constructs.}
% Since \texttt{next} and \texttt{prev} do nothing more than convert between 
% second-stage terms at \bbtwo\ and encapsulated second-stage terms at \bbonem,
% their splitting rules are relatively simple.
% Given $\diatwo e q$, splitting yields $p$ and $l.r$ where
% \[
% 	\reduce p b \text{ and } [b/l]r \equiv q
% \]
% Then for $\diaone {\next {e}} {{\hat y} \mapsto q} {\next {\hat y}}$
% and\\ $\rtab {{\hat y} \mapsto q} {\next {\hat y}} \vsplito \mval {\tup{}} {\letin {\hat y} q {\hat y}}$, splitting must produce $c'$ and $l'.r'$ where
% \[
% 	\reduce {c'} {\tup {\tup{},b'}} \text{ and } [b'/l']r' \equiv \letin {\hat y} q {\hat y}
% \]
% Our algorithm chooses $c' = \tup{\tup{},p}$ and $l'.r' = l.r$.
% Applying this process in reverse yields a splitting rule for $\prev e$ which applies \texttt{pi1} to the combined term of $e$.

\subsection {Role of World \bbonep}
\label{sec:needGround}

The splitting algorithm described in the previous subsections operates
purely on the local structure of \lang\ terms.  One artifact of this design
is that splitting \bbonem\ terms may generate resumers containing
unnecessary logic.  For example, the rule for splitting
\bbonem\ \texttt{case} terms inserts the tag from the \texttt{case}
argument into the boundary value, then decodes this tag in the
resumer. This logic occurs regardless of whether the terms forming the
branches of the \texttt{case} contain second-stage computations.
Worse, if this \texttt{case} appeared in the body of a recursive
function with no other second-stage computations, splitting would
generate a resumer with (useless) recursive calls.

Rather than attempt global optimization of the outputs of splitting,
we instead leverage the type system to indicate when a term contains
no second-stage computations by adding a third world \bbonep\ whose
terms are purely first-stage.  While not necessary for ordinary staged
term evaluation (\ref{sec:semantics}), this annotation is
particularly useful for splitting. Specifically, splitting $\pure e$
terms trivially yields a unit resumer.

The \texttt{partition} function in the quickselect example in
\ref{sec:exampleQS} is an example of such a function that contains no
second-stage computations, but, if not defined within a $\pure$
annotation, would cause splitting to generate a recursive resumer.

\end{abstrsyn}

\input{figures/splitting-misc}
\input{figures/splitting-term}
