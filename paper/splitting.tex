%!TEX root = paper.tex

\section{Splitting Algorithm}
\label{sec:splitting}

%\input{figures/splitting-overview}

\begin{abstrsyn}

Splitting statically transforms terms in \lang\ into a pair of
monostaged terms that correspond to the first stage and second stage
computations in the original term. The idea is that evaluating the
first monostaged term in a first pass, and then evaluating the second
monostaged term on the results of the first pass, yields the same
result as fully evaluating the original \lang\ program.  Complexity
arises because \lang\ evaluation of \bbonem\ terms may also generate
results in the first stage. (For example, a \bbonem\ term of type
$\curr \rmint$ results in an \rmint\ in the first stage.) Handling the
asymmetry between the results of evaluating \bbonem\ terms (which may
produce results at both the first and second stage) and \bbtwo\ terms
(which only produce second stage results) is fundamental to the
structure of the splitting algorithm presented in this section.  By
construction, \bbonep\ terms are monostage and do not require
splitting.

\textbf{\bbtwo\ term splitting.}  For any $\coltwo e A$ which reduces
to a residual $q$ (via $\diatwo e q$) and then a final value $v$ (via
$\reduce q v$), splitting $e$ (via the new relation~$\splittwosym$)
yields a pair of monostaged terms $p$ (containing all first stage
computations in $e$) and $l.r$ (containing all second stage
computations in $e$). Executing $p$ in a first pass produces $b$ (via
$\reduce p b$). Then, in the second pass, $\reduce {[b/l]r} {v'} = v$.
Since execution of the first pass serves to generate input for the
second pass, we say $p$ is a {\em precomputation} that produces a {\em
  boundary value} ($b$) for the {\em resumer} ($l.r$).

% The process of splitting \bbtwo\ terms is given by via the new
% relation~$\splittwosym$.

% (and the relationship of these
% operations to the outputs of direct \lang\ evaluation) is provided at
% right in \ref{fig:splittingSummary}.


% $\sepredtwosym$ is defined
% by a single rule, which evaluates the precomputation and substitutes
% the resulting value in for $l$ in the resumer:
%\[
%\infer{{[b/l]r}\equiv q} {\reduce p b}
%\]

\textbf{\bbonem\ term splitting.}  For any $\colmix e A$ which reduces
to $\rtab \xi v$ (via $\redonesym$), masking yields the masked value
$\mval i q$ (via~$\vsplito$).  Then $e$ splits (via the new
relation~$\splitonesym$) into the monostage terms $\pipeM c l r$ where
$\reduce c (i,b)$, and $[b/l]r$ is the same as $q$ up to an
equivalence.  The term $c$ generated by splitting (called the {\em
  combined term}) is a monostage term encoding all the first-stage
computations in $e$, and $l.r$ (again called the {\em resumer}) is a
monostage term encoding all the second-stage computations in $e$.  The
process of splitting \bbonem\ terms is summarized at left in
\ref{fig:splittingSummary}.

%Defining the requirements for
%splitting \bbonem\ terms is challenging because unlike \bbtwo\ terms
%(which reduce to monostage residuals that can be directly compared to
%resumers), \bbonem\ terms reduce to residual tables and partial values
%that represent computations at both stages.

To resolve the mismatch between the multi-stage computations
represented by residual tables and partial values and the desired
monostaged outputs of splitting, we choose to define a translation,
called {\em masking}, written $\rtab \xi v \vsplito \mval i q$, which
converts residual tables and partial values into a {\em masked value}.
The first part of the masked value, $i$, is a monostage value holding
the result of all first stage components of $v$.  The second
component, $q$, is a residual representing all second stage
computations in $\xi$ and $v$. (A precise definition of masking is
given in \ref{sec:masking}.)

% We define the requirements for splitting \bbonem\ terms using the
% results of masking.

Note that since $\coltwo e A$ reduces to an entirely second-stage
residual, its first-stage computations only exist to generate input
for second stage computations.  In contrast, since $\colmix e A$
reduces to a multi-stage residual table and partial value, its first
stage computations serve to both generate the value used as input for
the second stage {\em and also} produce a first-stage value.
Correspondingly, the precomputation $p$ resulting from splitting
\bbtwo\ terms reduces only to a boundary value $b$ which is passed to
the resumer; but the combined term $c$ resulting from splitting
\bbonem\ terms reduces to a tuple containing both the first stage {\em
  immediate result} $i$ and the boundary value $b$ (motivating the
name {\em combined term}). 

The following subsections formally define the masking transformation
($\vsplito$), then describe the algorithm for splitting both
\bbonem\ terms ($\splitonesym$) and \bbtwo\ terms ($\splittwosym$).
  
\subsection{Masking}
\label{sec:masking}

Masking converts a residual table and associated partial value into a
masked value $\mval i q$.
%that explicitly separates the first stage components of 
%result from the residual.
%where $i$ is a monostage value encoding all
%first stage components of the partial value, and $q$ is a monostage
%term encoding all of the second-stage computations of the partial
%value.
Masking is not a transformation performed as part of the splitting
algorithm.  Instead, masking defines an intuitive notion of the first
stage and second stage ``components'' of residual tables and partial
values, and it is used to define the requirements of what output
splitting of \bbonem\ terms must produce.  A precise definition of the
masking relation is given in \ref{fig:valMask}, but to gain intuition
about the intent of masking operations, consider the following
residual table and partial value, colored as before:
\begin{lstlisting}
2`[yhat |-> 1+2]`1` (next{`2`yhat`1`}, injL (grnd{7}, next{`2`yhat`1`}))`
\end{lstlisting}
To construct a value representing its first-stage components ($i$ in
the resulting masked value), masking first redacts all second stage
(blue) parts, along with the surrounding \texttt{next}
annotations. (This redaction removes the entire residual table since
it only represents stage two computations.) The resulting ``holes'' in
the term are replaced with unit values.
%\begin{lstlisting}
%4`##########`1` (`4`######`1`, injL (grnd{7}, `4`######`1`))`
%\end{lstlisting}
%The holes inside the term needs to be filled with something to convey the lack of information, so we use a unit values:
\begin{lstlisting}
1`((), injL (grnd{7},()))`
\end{lstlisting}
Finally, masking dropping \texttt{grnd} annotations yielding a value.
\begin{lstlisting}
1`((), injL (7,()))`
\end{lstlisting}
To construct a residual corresponding to the stage two computations
represented by the residual table and partial value ($q$ in resulting
the masked value), masking first redacts all \texttt{grnd} blocks
(replaced with unit), \texttt{next} annotations, and injection tags
(essentially, the tuple structure is kept, but all other structure is
discarded):
%\begin{lstlisting}
%2`[yhat |-> 1+2]`1` (`4`####`2`yhat`4`#`1`, `4`####`1` (`4`####`1`,`4`####`2`yhat`4`#`1`))`
%\end{lstlisting}
%Where the \texttt{grnd} blocks left a hole, we put in a unit values:
\begin{lstlisting}
2`[yhat |-> 1+2] (yhat, ((),yhat))`
\end{lstlisting}
Then masking reifies the residual table into \texttt{let} bindings,
yielding a residual:
\begin{lstlisting}
2`let yhat = 1+2 in (yhat, ((),yhat))`
\end{lstlisting}

Note in \ref{fig:valMask} that since lambdas may represent multistage
computations, masking splits the body of lambdas as general world
\bbonem\ terms (as described in \ref{sec:split-one}), and packages the
resulting terms as functions in both the first and second stage parts
of the masked value.
% Masking operates by first inducting on the entries of the residual table.  
% Being purely second-stage content, these are reified into let statements at the top of the resumer.
% Once the table is empty, masking inducts on value itself.

% Masking assigns ground values to the immediate value
% and likewise assigns references into the residual table to the resumer.
% In both cases, the alternate component is assigned to $\tup{}$, to represent trivial information.
% Note that the \texttt{grnd} and \texttt{next} annotations are erased.

% Masking distributes into tuples, injections, and rolls, since their subvalues may have content at both stages.
% However, the tags of injections and rolls are replicated only in the immediate value, 
% since they represent first-stage information.

\subsection{Term Splitting at \bbonem}
\label{sec:split-one}

We now show how to translate terms $\colmix e A$ into the form $\pipeM c l r$,
pursuant to the correctness condition given in \ref{fig:splittingSummary}.
The algorithm is specified by the $\splitonesym$ relation (\cref{fig:termSplit}), 
which proceeds recursively on the structure of~$e$.

When $e$ is unit or a variable,
splitting yields a combined term formed by tupling $e$ with a $\tup{}$ precomputation.
These expressions, as they contain no second-stage subcomputations, have a trivial resumer, $\tup{}$.
Similarly, the contents of a \texttt{grnd} block are assigned entirely to the immediate value,
with trivial precomputation and resumer.

For all non-terminals (except \texttt{next}),
splitting descends into $e$, recursively splitting its $n$ subterms
to produce their respective combined terms $c_1,\ldots,c_n$ and resumers $r_1, \ldots, r_n$.
The combined term of $e$ is formed by binding $c_1,\ldots,c_n$
to the patterns $(y_1,z_1),\ldots,(y_n,z_n)$
to isolate immediate results from boundary values. Then,
the immediate result of $e$ is formed by replacing $e$'s subterms with $y_1,\ldots,y_n$.
The resumer binds the boundary values $b_1,\ldots,b_n$ to an
argument $(l_1,\ldots,l_n)$ in a term that has the same structure
of~$e$ but where each subterm is replaced by its resumer ($r_i$'s).

Splitting {\tt case} yields a combined term that executes one of the branches' combined terms based on the immediate result $y_1$ of the predicate.
The boundary value $b_i$ for this branch is injected and bundled with that of the predicate ($b_1$).   
$b_i$ is cased in the resumer to determine which branch's resumer should be executed.
{\tt case} is the only rule where splitting adds non-trivial logic is added to the precomputation.

Function introduction has a $\tup{}$ boundary value,
since functions are already fully reduced in our semantics.
However, since the body of a function may itself be multistage, splitting must continue into it.
The immediate result is a new function formed from the first-stage part of the original body.
The resumer is a new function formed out of the second-stage part of the original body.
It is the responsibility of the application site to save the precomputation of the function body
and pass it to the resumer version of the function.

Since the results of splitting \texttt{next} terms depend on the output of
splitting its world \bbtwo\ subterm,
we defer description of \texttt{next} until after describing world \bbtwo\ term splitting.

\subsection{Term Splitting at \bbtwo}

Because world \bbtwo\ terms in \lang\ reduce to monostage residuals (as opposed to partial values),
term splitting at world \bbtwo\ assumes a simpler form than the version at \bbonem\ does. 
The algorithm is specified by the $\splittwosym$ relation in \cref{fig:termSplit}.

In the terminal cases of
constants and variables, splitting generates trivial precomputations that are \texttt{()}, and resumers consisting of the original term.
For example, the integer constant \texttt{3} splits into the
precomputation \texttt{()} and resumer \texttt{\_=>3}.

More generally, for all (except \texttt{prev}) 
$n$-ary terms $e = \mathcal{C}\ttlpar e_1 \ttsemi \ldots \ttsemi e_n \ttrpar$ 
the precomputation is the tupled precomputations of $e$'s $n$ subterms:
$p=(p_1,\ldots,p_n)$.  The resumer binds each boundary value to an
argument $(l_1,\ldots,l_n)$ in a term that has the same structure
of~$e$ but where each subterm is replaced by its corresponding resumer:
$r = \mathcal{C}\ttlpar r_1 \ttsemi \ldots \ttsemi r_n \ttrpar$ .
Notably, at \texttt{case}s and functions the
precomputation of subterms is lifted out from underneath world \bbtwo\ binders.  
% TODO: should probably draw a parallel to the same behavior in dynamics

Splitting \texttt{prev} generates a precomputation that projects the immediate
result of its world \bbone\ subterm.
Since the argument to \texttt{prev} is of $\fut$ type, its immediate result reduces to $\tup{}$, justifying why it can be thrown away.
Finally, splitting \texttt{next} simply tuples up the precomputation of its
world \bbtwo\ subterm with a trivial immediate result $\tup{}$.

\subsection {Necessity of \bbonep}
\label{sec:needGround}

We have not yet given a justification for why first stage code must be
partitioned between the worlds \bbonem\ and \bbonep.
Certainly one could imagine a simpler system without all the \texttt{grnd} annotations.  
Why wouldn't this work?

In order to be correct, any code at \bbonem\ must be split with the 
pessimistic assumption that it may result in work at the second stage.
When this assumption turns out not to be true---that is, purely monostage code---then 
splitting may produce second stage code which is needlessly costly 
(an example of this will occur in \ref{sec:exampleQS}).
Detecting and optimizing this case is in general a global program analysis,
since functions can be passed around as values.  
So instead of relying on hefty analysis, 
we take the approach of adding enough structure to the input language's type system to
allow the input code to {\em prove} itself to be---in some parts---monostage.

We find that giving input with \texttt{grnd} annotations is not especially cumbersome in practice.
Yet even if a language designer desired a different implicit/explicit trade-off,
then the three-world \lang\ would still be useful as a typed intermediate representation.

\end{abstrsyn}

\input{figures/splitting-misc}
\input{figures/splitting-term}
