%!TEX root = paper.tex

\section{Splitting Algorithm}
\label{sec:splitting}

\input{figures/splitting-overview}

\begin{abstrsyn}

%Although the type system of \lang\ ensures that we can perform all first-stage
%computations before any second-stage ones, actually evaluating terms in this
%fashion is rather involved, because stages are syntactically interleaved
%within terms.

In this section, we present a \emph{splitting algorithm} which
statically converts a term in \lang\ into a pair of 
%syntactically % I don't like this word but temporarily here for continuity
separate, monostaged programs that correspond to the first and second stage computations in that term.

%The output of splitting is simpler because it is {\em syntactically separated};
%The output of splitting is equivalent (to its input) because it can be
%evaluated to the same residual that would be produced by the semantics of
%\ref{sec:semantics}.

More precisely, for any $\coltwo e A$ which reduces to a residual $q$ (via $\diatwo e q$),
$e$ splits into a syntactically separated program $\mathcal{P}$ 
(via the new relation $e \splittwosym \mathcal{P}$) which is
reduced to a residual $q'$ (via the new relation $\mathcal{P} \sepredtwosym q'$), which is the same as $q$ up to an equivalence.
By ``syntactically separated'' we mean that $\mathcal{P}$ 
has the form $\pipeS p l r$, where  
$p$ (called the {\em precomputation}) is a monostage term representing all the
first-stage computations in $e$, 
and $l.r$ (called the {\em resumer}) is a monostage term representing all the
second-stage computations in $e$.  
$\sepredtwosym$ is defined by a single rule, which evaluates the precomputation and substitutes the resulting value in for $l$ in the resumer:
\[
\infer{\sepredtwo {\pipeS p l r} {[b/l]r}} {\reduce p b}
\]
We call $b$ the {\em boundary value} resulting from the split since it represents the data communicated between the first and second stage computations.
A summary of these operations and the relationship between them is provided on the right side of \ref{fig:splittingSummary}.

Since terms at world \bbtwo\ can depend on terms at \bbonem\ (via
\texttt{prev}), splitting is also defined on \bbonem\ terms.  However,
defining correctness requirements for splitting \bbonem\ terms is
challenging because unlike \bbtwo\ terms (which reduce to monostage
residuals that can be directly compared to the monostage result of
$\sepredtwosym$), \bbonem\ terms reduce to partial values and residual
tables that represent computations at both stages.
%One complication arises from the fact that \lang\ terms at world \bbonem\ produce multistage output.
For example, the \bbonem\ term:
\begin{lstlisting}
(next {1+2}, grnd{3+4})
\end{lstlisting}
reduces (via $\redonesym$) to the residual table and partial value:
\begin{lstlisting}
[yhat |-> 1+2] (next {yhat}, grnd{7})
\end{lstlisting}

To resolve the mismatch between the multi-stage computations
represented by residual tables and partial values and the desired monostaged
outputs of splitting,
% Since this output has interleaved stages, theres no way a syntactically separated term could directly reduce to it.
we choose to define a translation, called {\em masking}, written $\rtab \xi v \vsplito \mval i q$,
which converts residual tables and partial values into a syntactically separated {\em masked value}.
%version $\mathcal{V}$.
%As before, we enforce the ``syntactically separated'' property by defining $\mathcal{V}$ to have the form $\mval i q$ (called a {\em masked value})
The first component of the masked value, $i$, is a value holding the
result of all first stage computations in $v$.  The second component,
$q$, is a residual representing all second stage computations in $\rtab
\xi v$.

%where 
%$i$ is a monostage value representing the first stage part of $v$,
%and $q$ is a monostage term representing all second-stage computations in $\xi$ and $v$.

%Note that masking is a technical device used to state the correctness of splitting at \bbonem; 
%it is not part of the splitting algorithm itself.

We define the requirements for splitting \bbonem\ terms using the
results of masking. Specifically, for any $\colmix e A$ which reduces
to $\rtab \xi v$ (via $\redonesym$), masking yields the masked value
$\mval i q$ (via $\vsplito$).  Then $e$ splits into a syntactically
seperated program $\mathcal{P}$ (via the new relation $e \splitonesym
\mathcal{P}$) which is reduced to a masked value $\mval i {q'}$ (via
the new relation $\sepredtwosym$) where $q'$ is the same as $q$ up to
an equivalence.

%Given the definition of masking, \bbonem\ terms split via the new
%relation $e \splitonesym \mathcal{P}$, where $\mathcal{P}$ must have
%the form $\pipeM c l r$
Similar to \bbtwo\ term splitting, $\mathcal{P}$ takes the form
$\pipeM c l r$ where $c$ (called the {\em combined term}) is a
monostage term encoding all the first-stage computations in $e$, and
$l.r$ (again called the {\em resumer}) is a monostage term encoding
all the second-stage computations in $e$.  $\sepredonesym$ is defined
by a single rule that yields masked values:
\[
\infer{\sepredone {\pipeM c l r} {\mval i {[b/l]r}}} {\reduce c {(i,b)}}
\]

Note that since $\coltwo e A$ reduces to an entirely second-stage
residual, its first-stage computations only exist to generate input
for second stage computations.  In contrast, since $\colmix e A$
reduces to a multi-stage residual table and partial value, its first
stage computations serve to both generate the value used as input for
the second stage {\em and also} produce a first-stage value.
Correspondingly, in the $\sepredtwosym$ rule, the precomputation $p$
generated via splitting reduces only to a boundary value which is
passed to the resumer; but in the $\sepredonesym$ rule, the combined
term $c$ reduces to a tuple containing both the first stage result $i$
and the boundary value $b$ provided as input to the resumer.  A
summary of the relationship between the results of directly evaluating
\lang\ and the results of splitting is provided at left in
\ref{fig:splittingSummary}.

In the following subsections we formally define the masking
transformation ($\vsplito$), then describe the algorithm for splitting
both \bbonem\ terms ($\splitonesym$) and \bbtwo\ terms
($\splittwosym$).
  
\subsection{Masking}

The masking operation converts a partial value into a masked value $\mval i q$,
where $i$ is a monostage value encoding all of the first-stage information of the original partial value,
and $q$ is a monostage term encoding all of the second-stage information of the original partial value.
Remember that masking will not play a role in the final splitting algorithm, 
but instead exists to specify the contract to which splitting at \bbonem\ must adhere.
Accordingly, masking should be thought of as a definition, and as such it is in some parts arbitrary.

The rules of the masking relation are given in \ref{fig:valMask}.
Masking operates by first inducting on the entries of the residual table.  
Being purely second-stage content, these are reified into let statements at the top of the resumer.
Once the table is empty, masking inducts on value itself.

Masking assigns ground values to the immediate value
and likewise assigns references into the residual table to the resumer.
In both cases, the alternate component is assigned to $\tup{}$, to represent trivial information.
Note that the \texttt{grnd} and \texttt{next} annotations are erased.

Masking distributes into tuples, injections, and rolls, since their subvalues may have content at both stages.
However, the tags of injections and rolls are replicated only in the immediate value, 
since they represent first-stage information.

Since lambdas may represent multistage computations, 
masking splits the body of lambdas as general world \bbonem\ terms (as described in \ref{sec:split-one}), 
and packages the resulting terms as functions.

\subsection{Term Splitting at \bbonem}
\label{sec:split-one}

We now show how to translate terms $\colmix e A$ into the form $\pipeM c l r$,
pursuant to the correctness condition given in \ref{fig:splittingSummary}.
The algorithm is specified by the $\splitonesym$ relation (\cref{fig:termSplit}), 
which proceeds recursively on the structure of~$e$.

When $e$ is unit or a variable,
splitting yields a combined term formed by tupling $e$ with a $\tup{}$ precomputation.
These expressions, as they contain no second-stage subcomputations, have a trivial resumer, $\tup{}$.
Similarly, the contents of a \texttt{grnd} block are assigned entirely to the immediate value,
with trivial precomputation and resumer.

For all non-terminals (except \texttt{next}),
splitting descends into $e$, recursively splitting its $n$ subterms
to produce their respective combined terms $c_1,\ldots,c_n$ and resumers $r_1, \ldots, r_n$.
The combined term of $e$ is formed by binding $c_1,\ldots,c_n$
to the patterns $(y_1,z_1),\ldots,(y_n,z_n)$
to isolate immediate results from boundary values. Then,
the immediate result of $e$ is formed by replacing $e$'s subterms with $y_1,\ldots,y_n$.
The resumer binds the boundary values $b_1,\ldots,b_n$ to an
argument $(l_1,\ldots,l_n)$ in a term that has the same structure
of~$e$ but where each subterm is replaced by its resumer ($r_i$'s).

Splitting {\tt case} yields a combined term that executes one of the branches' combined terms based on the immediate result $y_1$ of the predicate.
The boundary value $b_i$ for this branch is injected and bundled with that of the predicate ($b_1$).   
$b_i$ is cased in the resumer to determine which branch's resumer should be executed.
{\tt case} is the only rule where splitting adds non-trivial logic is added to the precomputation.

Function introduction has a $\tup{}$ boundary value,
since functions are already fully reduced in our semantics.
However, since the body of a function may itself be multistage, splitting must continue into it.
The immediate result is a new function formed from the first-stage part of the original body.
The resumer is a new function formed out of the second-stage part of the original body.
It is the responsibility of the application site to save the precomputation of the function body
and pass it to the resumer version of the function.

Since the results of splitting \texttt{next} terms depend on the output of
splitting its world \bbtwo\ subterm,
we defer description of \texttt{next} until after describing world \bbtwo\ term splitting.

\subsection{Term Splitting at \bbtwo}

Because world \bbtwo\ terms in \lang\ reduce to monostage residuals (as opposed to partial values),
term splitting at world \bbtwo\ assumes a simpler form than the version at \bbonem\ does. 
The algorithm is specified by the $\splittwosym$ relation in \cref{fig:termSplit}.

In the terminal cases of
constants and variables, splitting generates trivial precomputations that are \texttt{()}, and resumers consisting of the original term.
For example, the integer constant \texttt{3} splits into the
precomputation \texttt{()} and resumer \texttt{\_=>3}.

More generally, for all (except \texttt{prev}) 
$n$-ary terms $e = \mathcal{C}\ttlpar e_1 \ttsemi \ldots \ttsemi e_n \ttrpar$ 
the precomputation is the tupled precomputations of $e$'s $n$ subterms:
$p=(p_1,\ldots,p_n)$.  The resumer binds each boundary value to an
argument $(l_1,\ldots,l_n)$ in a term that has the same structure
of~$e$ but where each subterm is replaced by its corresponding resumer:
$r = \mathcal{C}\ttlpar r_1 \ttsemi \ldots \ttsemi r_n \ttrpar$ .
Notably, at \texttt{case}s and functions the
precomputation of subterms is lifted out from underneath world \bbtwo\ binders.  
% TODO: should probably draw a parallel to the same behavior in dynamics

Splitting \texttt{prev} generates a precomputation that projects the immediate
result of its world \bbone\ subterm.
Since the argument to \texttt{prev} is of $\fut$ type, its immediate result reduces to $\tup{}$, justifying why it can be thrown away.
Finally, splitting \texttt{next} simply tuples up the precomputation of its
world \bbtwo\ subterm with a trivial immediate result $\tup{}$.

\subsection {Necessity of \bbonep}
\label{sec:needGround}

We have not yet given a justification for why first stage code must be
partitioned between the worlds \bbonem\ and \bbonep.
Certainly one could imagine a simpler system without all the \texttt{grnd} annotations.  
Why wouldn't this work?

In order to be correct, any code at \bbonem\ must be split with the 
pessimistic assumption that it may result in work at the second stage.
When this assumption turns out not to be true---that is, purely monostage code---then 
splitting may produce second stage code which is needlessly costly 
(an example of this will occur in \ref{sec:exampleQS}).
Detecting and optimizing this case is in general a global program analysis,
since functions can be passed around as values.  
So instead of relying on hefty analysis, 
we take the approach of adding enough structure to the input language's type system to
allow the input code to {\em prove} itself to be---in some parts---monostage.

We find that giving input with \texttt{grnd} annotations is not especially cumbersome in practice.
Yet even if a language designer desired a different implicit/explicit trade-off,
then the three-world \lang\ would still be useful as a typed intermediate representation.

\end{abstrsyn}

\input{figures/splitting-misc}
\input{figures/splitting-term}
