
\section{Splitting Algorithm}

Motivate splitting here.  (Depends on intro)
Consider splitting at \bbtwo. 
The basic idea is that, for a given input program, we want to find all of the stage \bbone\ content, pull that out into a single term, 
and also produce a stage \bbtwo\ term, which takes the results of the stage \bbone\ part and produces the final answer.
We call these two parts the {\em precomputation} and the {\em residual}, respectively.
More formally, we want to take some $\coltwo e A$ and produce a $p : \tau$ and a $r : \tau \to A$ such that $e$ and $(r~p)$ reduce to the same value.
Consider the following stage \bbtwo\ example:
\begin{lstlisting}
if 6*7 > 41 then
	hold{1+2} * 3
else 
	hold{2*3} + hold {4*5}
\end{lstlisting}
Under the definitions above, this should split into:
\begin{lstlisting}
(1+2,2*3,4*5)
\end{lstlisting}
and
\begin{lstlisting}
fn (l1,l2,l3) => 
    if 6*7 > 41 then l1 * 3 else l2 + l3
\end{lstlisting}
Essentially what we've done is find all of the $\pause$ expressions, 
bundle them into a tuple in then precomputation, 
and then unbundle them into the correct place in the residual.
Note how splitting has the same speculative behavior as our \lang\ dynamics,
wherein we run the stage \bbone\ code in {\em both} branches of the stage \bbtwo\ {\tt if} expression.

Now consider splitting the following expression, where the {\tt if} is at stage \bbone, rather than stage \bbtwo:
\begin{lstlisting}
prev {
  if 6*7 > 41 then
    next{1+hold{2*3}}
  else 
    next{4+5}
}
\end{lstlisting}
This splits into
\begin{lstlisting}
if 6*7 > 41 then inL (2*3) else inR ()
\end{lstlisting}
and
\begin{lstlisting}
fn l => 
  case l of
    l1 => 1+l1
  | () => 4+5
\end{lstlisting}
In this example, we 

[develope the more formal version...]

  $\diatwo [\cdot;\cdot] e q$ and $\reduce q v$ iff $\reduce {r~p} {v}$.


\input{figures/splitting-term}
\input{figures/splitting-sumfun}

[Present the splitting judgement.  Give statements of type and value correctness for splitting.  Give all of the splitting rules.  Talk through a few of them.]

\section{Examples for Staged Pipelines}

Give the gist of one-to-one pipeline example (like client/server).
Then talk about a one-to-many pipeline.
Then talk about a many-to-one pipeline like spark.  It clear how to target something like this for known base types on the boundary, and for product types.  But sums on the boundary are hard!  We leave many-to-one as future-work.


\section{Examples of Algorithm Derivation}

Fast exponent example.  

\begin{lstlisting} 
let exp (b : $int, e : int) : $int =
	if e == 0 then
		next{1}
	else if (e mod 2) == 0 then
		next{let x = prev{exp(b,e/2)} in x*x}
	else
		next{prev{b} * prev{exp (b,e-1)}}		
\end{lstlisting}

splits into

\begin{lstlisting} 
let exp (b, e) =
	((), roll (
		if e == 0 then
			inL ()
		else 
			inR (
				if (e mod 2) == 0 then
					inL (#2 (exp (b,e/2)))
				else
					inR (#2 (exp (b,e-1)))
			)
	))
\end{lstlisting}

and

\begin{lstlisting} 
let exp ((b, e), p) =
	case unroll p of
	  () => 1
	| d  =>
		case d of
		  r => let x = exp ((b,()),r) in x*x
		| r => b * exp ((b,()),r)
\end{lstlisting}

Quickselect example.

\begin{lstlisting} 
let qs (l : "*$\mathtt{\mu \alpha. }$*"() + "*$\mathtt{int*\alpha}$*", i: $int) = 
	case unroll l of
	  () => next {0}
	| (h,t) => 
		let (left,right,n) = partition h t in
		next{
			let n = prev{hold n} in
			case compare prev{i} n of
			  () (*LT*) => prev {qs left i}
			| () (*EQ*) => prev {hold h}
			| () (*GT*) => 
				prev {qs right next{prev{i}-n-1}}
		}	
\end{lstlisting}

Things to try: an interpreter which, partially evaluated, does cps or something.

For each of these examples, talk about what partial evaluation would do and why that might be bad.


[Meta-ML eases off on this restriction but does not (I think?) eliminate it.]

[What's going on with names and necessity?]

[Our work bears a lot of similarity to ML5, which also uses a modal type system.  The difference is that we target stages systems (each stage talks to the next), whereas they target distributed ones (all stages talk to all others). The type systems reflect this directly in the world accessibility relation.  There might be some analogue of stage-splitting in the ML5 work, but I have not yet isolated it (might be buried in CPS conversion).]

