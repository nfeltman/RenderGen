%!TEX root = paper.tex

\section{Splitting Algorithm}
\label{sec:splitting}

\begin{abstrsyn}

The primary strength of \lang\ is the expressive power afforded by
its ability to syntactically interleave work intended for stage \bbone\
and work intended for stage \bbtwo, as well as its ability to form
mixed-stage abstractions. 

In this section, we provide an algorithm to translate the multistage terms and values of \lang\
into equivalent but simpler forms where the stage \bbone\ and stage \bbtwo\ portions 
of the computation are {\em syntactically separated} from each other.
That is, we desire outputs of the form $\mathcal{C}(e_1;e_2)$ where  
$e_1$ is a monostage term encoding all stage \bbone\ computation, 
and $e_2$ is a monostage term encoding all stage \bbtwo\ computation.
To represent outputs in this way, we introduce three new constructs:
\begin{itemize}
\item {\em Single-output pipelines}, \texttt{pipeS}, for the output of splitting \lang\ terms at world \bbtwo.
\item {\em Multi-output pipelines}, \texttt{pipeM}, for the output of splitting \lang\ terms at world \bbonem. 
\item {\em Masked values}, \texttt{mv}, which will serve a purpose analogous to \lang\ partial values.
\end{itemize}

We also define analogs to evaluation and residualization for these new terms, 
called $\sepredonesym$ and $\sepredtwosym$, 
which respectively send \texttt{pipeM} terms to \texttt{mv} terms
and \texttt{pipeS} terms to residuals.
An overview of these features is provided in \ref{fig:outputTermSummary}.
That figure also provides the actual rules for $\sepredonesym$ and $\sepredtwosym$.
Note how there's one rule for each, and they're rather simple.
Indeed, the simplicity of these reduction rules is one reason why we 
would want to translate into this separated form, rather than use the semantics of \ref{sec:semantics}.

With these output terms defined, we can state the goal of our splitting algorithm:
to translate terms in \lang\ to a syntactically-separated form, 
such that the semantics is preserved.

Exactly what is meant by ``such that the semantics is preserved'' depends on whether we're translating
terms at \bbonem\ or \bbtwo.  
In the latter case, where an $\coltwo e A$ is translated to a $\pipeS p l r$ with the $\splittwosym$ relation,
this constraint is straightforward: $e$ and $\pipeS p l r$ can both be reduced to residuals
via $\redtwosym$ and $\sepredtwosym$, so we only need to require that those
residuals be equivalent for the translation to be correct.
In the former case, where an $\colone e A$ is translated to a $\pipeM c l r$ with the $\splitonesym$ relation, 
things are more complicated: 
the output of $\redonesym$ is a partial value and the output of $\sepredonesym$ is a masked value,
so we first need a way to relate those forms if we want to talk about correctness of the term translation.
That is the purpose of the {\em masking} relation, written $\vsplito$.

This section proceeds by defining masking ($\vsplito$), 
then using masking to motivate the definition of \bbonem-translation ($\splitonesym$),
and finally coming back to define \bbtwo-translation ($\splittwosym$).
A summary of these operations and the relationship between them is provided in \ref{fig:splittingSummary}.

\subsection{Masking}

The point of the masking operation is simply to convert a partial value into a masked value $\mval i q$
by assigning all of the stage \bbone\ content to $i$ and all of the stage \bbtwo\ content to $q$.
The rules of the masking relation are given in \ref{fig:valMask}.

Masking operates by first inducting on the entries of the residual table.  
Being purely stage~\bbtwo\ content, these are reified into let statements at the top of the resumer.
Once the table is empty, masking inducts on value itself.

Masking assigns purely stage~\bbone\ values to the immediate value
and likewise assign references into the residual table to the resumer.
In both cases, the offside component is assigned to \texttt{()}, to represent trivial information.

Masking distributes into tuples, injections, and rolls, since their subvalues may have content at both stages.
However, the tags of injections and rolls are replicated only in the immediate value, 
since they represent stage~\bbone\ information.

Since lambdas may represent multi-stage computations, 
masking splits the body of lambdas as general stage~\bbone\ terms (as described in \ref{sec:split-one}), 
and packages the resulting terms as functions.

\subsection{Term Splitting at \bbonem}
\label{sec:split-one}

We now show how to translate terms $\colone e A$ into the form $\pipeM c l r$,
pursuant to the correctness condition given in \ref{fig:splittingSummary}.
The algorithm is specified by the $\splitonesym$ relation (\cref{fig:termSplit}), 
which proceeds recursively on the structure of~$e$.

When $e$ is a terminal (a variable or base constant)
splitting yields a combined term formed by tupling $e$ with a \texttt{()} precomputation, 
and the trivial resumer \texttt{()}. 
(Stage~\bbone\ terminals, by definition, contain no stage~\bbtwo\ subcomputations.)  
For example, the integer constant \texttt{3} splits into the combined term \texttt{(3,())} and resumer \texttt{\_=>()}.

For all non-terminals (except \texttt{next}),
splitting descends into $e$, recursively splitting its $n$ subterms
to produce their respective combined terms $c_1,\ldots,c_n$ and resumers $r_1, \ldots, r_n$.
The combined term of $e$ is formed by binding $c_1,\ldots,c_n$
to the patterns $(y_1,z_1),\ldots,(y_n,z_n)$
to isolate \bbone-results from boundary values. Then,
the \bbone-result of $e$ is formed by replacing $e$'s subterms with $y_1,\ldots,y_n$.
The resumer binds the boundary values $b_1,\ldots,b_n$ to an
argument $(l_1,\ldots,l_n)$ in a term that has the same structure
of~$e$ but where each subterm is replaced by its resumer ($r_i$'s).

Splitting {\tt case} yields a combined term that executes one of the branches' combined terms based on the \bbone-result $y_1$ of the predicate.
The boundary value $b_i$ for this branch is injected and bundled with that of the predicate ($b_1$).   
$b_i$ is cased in the resumer to determine which branch's resumer should be executed.
{\tt case} and \texttt{hold} are the only two rules where splitting adds non-trivial logic is added to the precomputation.

Function introduction has a \texttt{()} boundary value,
since functions are already fully reduced in our semantics.
However, since the body of a function may itself be multi-stage, splitting must continue into it.
The \bbone-result is a new function formed from the stage~\bbone\ part of the original body.
The resumer is a new function formed out of the stage~\bbtwo\ part of the original body.
It is the responsibility of the application site to save the precomputation of the function body
and pass it to the resumer version of the function.

Since the results of splitting \texttt{next} terms depend on the output of splitting its stage~\bbtwo\ subterm,
we defer description of \texttt{next} until after describing stage~\bbtwo\ term splitting.

\subsection{Term Splitting at \bbtwo}

Because stage~\bbtwo\ terms in \lang\ reduce to monostage residuals (as opposed to partial values),
term splitting at \bbtwo\ assumes a simpler form than the version at \bbonem\ does. 
The algorithm is specified by the $\splittwosym$ relation in \cref{fig:termSplit}.

In the terminal cases of
constants and variables, splitting generates trivial precomputations that are \texttt{()}, and resumers consisting of the original term.
For example, the integer constant \texttt{3} splits into the
precomputation \texttt{()} and resumer \texttt{\_=>3}.

More generally, for all (except \texttt{prev} and \texttt{hold}) 
$n$-ary terms $e = \mathcal{C}\ttlpar e_1 \ttsemi \ldots \ttsemi e_n \ttrpar$ 
the precomputation is the tupled precomputations of $e$'s $n$ subterms:
$p=(p_1,\ldots,p_n)$.  The resumer binds each boundary value to an
argument $(l_1,\ldots,l_n)$ in a term that has the same structure
of~$e$ but where each subterm is replaced by its corresponding resumer:
$r = \mathcal{C}\ttlpar r_1 \ttsemi \ldots \ttsemi r_n \ttrpar$ .
Notably, at \texttt{case}s and functions the
precomputation of subterms is lifted out from underneath stage \bbtwo\ binders.  
% TODO: should probably draw a parallel to the same behavior in dynamics

Splitting \texttt{prev} generates a precomputation that projects the \bbone-result of its stage~\bbone\ subterm.
Since the argument to \texttt{prev} is of $\fut$ type, its \bbone-result reduces to \texttt{()}, justifying why it can be thrown away.
\texttt{hold} treats the entire combined term of its stage~\bbone\ subexpression as a precomputation, 
and projects out the integer result in the resumer. 
\footnote{The resumer of an integer expression is usually trivial, 
but we have to include it here for termination purposes.} 
Finally, splitting \texttt{next} simply tuples up the precomputation of its stage~\bbtwo\ subterm with a trivial \bbone-result \texttt{()}.

\end{abstrsyn}

\input{figures/splitting-term}
\input{figures/splitting-misc}
