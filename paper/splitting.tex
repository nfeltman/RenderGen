\section{Splitting Algorithm}
\label{sec:splitting}

Although terms in \lang\ clearly distinguish their stage \bbone\ and stage
\bbtwo\ components, these components may be interleaved in complex ways. The
goal of \emph{stage splitting} is to produce from a term in \lang\ a pair of
terms in an unstaged language \langmono, which respectively perform all the
stage \bbone\ and stage \bbtwo\ subcomputations of the original term.

Since splitting stage \bbtwo\ terms is easier than splitting stage \bbone\
terms, we begin by describing how to split stage \bbtwo\ terms.

\subsection {Stage \bbtwo\ Splitting}

Splitting a stage \bbtwo\ term $\coltwo e A$ produces a \emph{precomputation}
term $p$ and a \emph{resumer} function $l.r$, which contain all stage \bbone\
and \bbtwo\ subcomputations of $e$, respectively. Since stage \bbtwo\
computations can depend on its stage \bbone\ computations within $e$, 
$r$ must depend on $p$, which splitting accomplishes via the variable $l$. 
Given this form, the goal for splitting is to ensure that evaluating
$\letin l p r$ agrees with the value to which $e$ itself evaluates. 

\ur{Correctness will have
  to go beyond this, by saying for example that all stage 1 parts are
  in p etc.  Note that this correctness allows a trivial split
   that shoves everything to r, e.g., p = () and r is ``e''
  (might need to flatten).}



Splitting stage \bbtwo\ terms, as implemented by the judgment $e \splittwosym
[p,l.r]$ (\cref{fig:termSplitTwo}), is guided by the structure of the term $e$.

\ur{At this point, I would have expected a brief discussion of the
  easy cases, like the paragraph that starts with ``In general'' below
  does. You can move that paragraph here and edit to play this role.
  You can then move onto the example below after stating that more
  interesting things happen with prev and hold.}

For example, the stage \bbtwo\ term
\begin{lstlisting}
2`hold{`1` 1+2 `2`} < (hold{`1` 3+4 `2`} - 5)`
\end{lstlisting}
has two subterms, the latter of which itself has two subterms. Two are $\pause$s
containing stage \bbone\ computations, while the third has no stage \bbone\
content. 

\ur{The discussion of the subterms is not helpful. what is the point?}

The precomputation \emph{lifts} these computations in the same tree
structure: \verb|(1+2,(3+4,()))|.%
\ur{Not clear what a ``tree structure'' is. }
\footnote{In later examples, we will optimize out unnecessary \texttt{()}s.}
The resumer is a function which computes the stage \bbtwo\ value of the original
term by mapping the results of the precomputation in place of the $\pause$s:
\verb|(L1,(L2,_)) => L1 < (L2 - 5)|. 

\ur{The above example should refer to Figure 11 (not Figure 10).  But
  this is not mentioned.}

\ur{This paragraph should come first, followed by a paragraph that
  talks about Figure 11.}
In general, constants and variables have no stage \bbone\ content, so their
precomputations are \texttt{()}, and their resumers return the original term's
value. Non-staging constructs with $n$ subterms have precomputations which are
$n$-tuples of their subterms' precomputations, and resumers which pass each
component to the resumer of the respective subterm. (This behavior at
\texttt{case} and functions causes precomputations to be lifted out from
underneath stage \bbtwo\ binders.) The $\prev$ and $\pause$ rules depends on
splitting stage \bbone\ terms, which is covered later.

\subsection{Stage \bbone\ Splitting}

Splitting a stage \bbone\ term $\colone e A$ produces a term and a function,
which respectively contain all the stage \bbone\ and stage \bbtwo\
subcomputations of $e$. The situation is more complex than when splitting stage
\bbtwo\ terms; to see why, consider the correctness criterion for splitting
stage \bbone\ terms.

Stage \bbone\ evaluation of $e$, via $e\mathbin{\redonesym}[\xi;v]$,
yields a table of (stage \bbtwo) residuals $\xi$, and a (stage \bbone) partial
value $v$. It is tempting to compare the two results of evaluating $e$ to the
two results of splitting it. To see where this goes wrong, consider the stage
\bbone\ term
\begin{lstlisting}
1`(1+2, next{`2`hold{`1`3+4`2`} + 5`1`})`
\end{lstlisting}
which evaluates to
\begin{lstlisting}
2`[yhat|->7+5]` 1`(3,next{`2`yhat`1`})`
\end{lstlisting}
This partial value contains a $\next$, and so is itself multistaged:
intuitively, its stage \bbone\ part is \texttt{3}, while its stage \bbtwo\ part
is $\mathtt{\hat{y}}$, which is bound to \texttt{7+5}.

\ur{So what goes wrong?  I have no idea what you are talking about at
  this point.  The thought seems unfinished.}


\ur{The following paragraph makes no sense to me, especially because
  it does not match Figure 11.  AS far as I can see Figure 11 does not
talk about masking but value splitting.}
We formalize this notion via two \emph{masking} functions (\ref{fig:valMask}),
$\masko{\cdot}$ and $\maskt{\cdot}$, which expose only the relevant structure of
a partial value at each stage, essentially by replacing all stage \bbone\
(resp., \bbtwo) components of a partial value by \texttt{()}. The first result
of splitting must then compute the \bbone-mask of the partial value, and the
second result the \bbtwo-mask. 

There is one final subtlety to splitting stage \bbone\ terms. In the example
above, there are \emph{two} flavors of stage \bbone\ subcomputations:
\texttt{1+2}, which is needed to compute the \bbone-mask, and \texttt{3+4},
a precomputation which is used by the computation of the \bbtwo-mask. 

\ur{This paragraph is unintellegible to me.  What is the point?}

Formally, splitting a stage \bbone\ term, as implemented by the judgment $e
\splitonesym [c,l.r]$ (\ref{fig:termSplitOne}), yields a \emph{combined result}
$c$ which computes a pair of the stage \bbone\ result and the precomputation,
and a \emph{resumer} function $l.r$. The correctness of splitting requires that,
for $e\mathbin{\redonesym}[\xi;v]$, we have that $\pio~c$ agrees with
$\masko{v}$, and $\letin l{\pit~c}r$ agrees with $\maskt{\xi;v}$.

The example splits into a combined result $c=$ \texttt{((1+2,()), 3+4)}, and a
resumer $l.r=$ \texttt{L => ((),L+5)}. Then $\pio~c$ reduces to \texttt{(3,())},
which agrees with the stage \bbone\ mask, and $\letin l{\pit~c}r$ reduces to
\texttt{((),12)}, which agrees with the stage \bbtwo\ mask.

\paragraph{Stage \bbone\ masking}

The purpose of masking is to expose only the relevant structure of a partial
value $v$ at each stage. For the most part, stage \bbone\ masking, $\masko{v}$,
simply replaces all $\next$s in $v$ with \texttt{()}. The only exception is for
functions $\lam xAe$; such a value represents a computation, so masking splits
its body as a computation, $e\splitonesym [c,l.r]$, and replaces it with its
stage \bbone\ component, the combined result.

\paragraph{Stage \bbtwo\ masking}

Stage \bbtwo\ masking, unlike stage \bbone\ masking, requires access to the
residual table $\xi$, because the stage \bbtwo\ parts of $v$ contain references
to $\xi$. To compute $\maskt{\xi;v}$, we rewrite $v$ to expose only the relevant
structure, and then reify the resulting term in the context $\xi$. This
rewriting process replaces base type constants in $v$ with \texttt{()}, and
$\next~\hat{y}$ with $\hat{y}$. Injection tags are eliminated, because the sum
type is at stage \bbone, so the tag is not relevant at stage \bbtwo. For
functions $\lam xAe$, masking again splits its body $e\splitonesym [c,l.r]$,
replaces it with the resumer, and uncurries, to yield $\lambda (x,l).r$.

\paragraph{Splitting}

Splitting stage \bbone\ terms, as implemented by the judgment $e\splitonesym
[c,l.r]$, is also guided by the structure of the term $e$.

\TODO polish the following explanation

The rule for $\next$ simply tuples up the precomputation of its subexpression with a trivial immediate result,
while the rule for $\prev$ projects the combined result of its subexpression to isolate the precomputation.
It may seem like this $\prev$ rule is throwing information away, but we well show later that the first component 
of the evaluated form of $c$ in the $\prev$ rule must always be unit.
The $\pause$ rule treats the entire combined result of its subexpression as a precomputation, 
and projects out the integer result in the resumer.%
\footnote{The resumer of an integer expression is usually trivial, 
but we have to include it here for termination purposes.}

In the splitting rules for stage \bbone\ {\tt case} expressions, we
have enough information at stage \bbone\ to know what branch to take, so there's
no need to evaluate both sides. Instead, we evaluate the stage \bbone\ portion of the
taken branch only, and inject the precomputation into a sum type. In the
resumer, we case on that injection, and resume the stage \bbtwo\ portion of the
correct branch.

\input{figures/splitting-term}

\subsection{Optimizations}

The above splitting rules are correct, but can be optimized in many cases. One
major optimization is to eliminate redundant instances of \texttt{()}---for
example, if multiple subterms have a \texttt{()} precomputation, these can be
combined.

A similar issue can occur in the precomputations for recursive function bodies.
Consider the stage \bbtwo\ term
\begin{lstlisting}
2`prev{
  1`letfun fact (n : int) : int = 
    if n <= 0 then 1 else fact(n-1)*n
  in next{`2`hold {`1`fact 5`2`}-100`1`}`2`
}`
\end{lstlisting}
which splits into:
\begin{lstlisting}
1`letfun fact (n : int) : int * prec = 
  if n <= 0 then (1,L) 
  else let (y,z) = fact(n-1) in (y*n,R z)
in fact 5`

2`l => 
letfun fact (n : unit, l0 : prec) : unit = 
  case l0 of L => () | R l1 => fact ((),l0)
in (fact (pi2 l); pi1 l)-100`
\end{lstlisting}
\texttt{fact}, being a stage \bbone\ function, itself splits into two recursive
functions, which compute a combined result (stage \bbone\ result and
precomputation), and a stage \bbtwo\ result, respectively. This precomputation
could be given the type
\begin{lstlisting}
datatype prec = L | R of prec
\end{lstlisting}
while the stage \bbtwo\ result is always \texttt{()}.

It is wasteful to run the stage \bbtwo\ version of \texttt{fact}, since it
always returns \texttt{()}; worse yet, it has linear runtime!

We solve this issue by adding a new staging annotation to \lang, called
\texttt{mono}. $\monoSt~e$ is stage \bbone, and requires that $e$ contains
no stage \bbtwo\ subexpressions. This adds a new stage \bbmono\ and two new
rules to \lang:
\begin{mathpar}
\infer{\typesone{\monoSt~e}A}{\typesmono e A} \and
\infer{\diaone{\monoSt~e}{\cdot;v}}{\diaone{e}{\cdot;v}}
\end{mathpar}

\crem{Why is it difficult?}

To split \texttt{mono} terms, we must produce a resumer with the correct shape
for the enclosed term. This is difficult to produce statically, because the
language has sums and general recursion. We instead produce it dynamically,
using a new value in \langmono, \texttt{dummy}, which can be consumed as though
it had any type:
\begin{mathpar}
\infer{e_1~e_2~\redsym~\mathtt{dummy}}{e_1~\redsym~\mathtt{dummy} & e_2~\redsym~v} \and
\infer{\unroll~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pio~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}\and
\infer{\pit~e~\redsym~\mathtt{dummy}}{e~\redsym~\mathtt{dummy}}
\end{mathpar}

\crem{Explain $\overset{C}{\to}$.}

The splitting rules are then
\begin{mathpar}
\infer{\splitone{\monoSt~e}A {e', {\tt dummy}} }{e \overset{C}{\rightarrow} e'} \and
\infer{e_1~e_2 \overset{C}{\rightarrow} \pio~(e_1'~e_2')}{e_1 \overset{C}{\rightarrow} e_1' & e_2 \overset{C}{\rightarrow} e_2'} \and
\infer{\lambda x.e \overset{C}{\rightarrow} \lambda x.(e',())}{e \overset{C}{\rightarrow} e'}
\end{mathpar}
And $\overset{C}{\rightarrow}$ operates like a map at all other terms.

To see that this optimization is correct, notice that \texttt{dummy} can only
appear in the resumers of terms that have no circles in their \lang\ type.
Since the $\prev$ rule requires a circle type, dummy values cannot leak from the
resumers of stage \bbone\ terms into the resumers of stage \bbtwo\ terms.

\input{figures/splitting-misc}

\subsection{Implementation}

\crem{Say something about the implementation.}

