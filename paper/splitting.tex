%!TEX root = paper.tex

\section{Splitting Algorithm}
\label{sec:splitting}

%\input{figures/splitting-overview}

\begin{abstrsyn}

Splitting statically transforms terms in \lang\ into a pair of
monostaged terms ($f_1$ and $f_2(-)$) that correspond to the first-stage 
and second-stage computations in the original term. Since full
evaluation of world \bbtwo\ terms (both first-stage and second-stage
evaluation) only produces values in stage two, the idea of splitting
is to generate terms where evaluating $f_1$ in a first pass, and then
evaluating $f_2$ on the result of the first pass, yields the same
value as full evaluation of the original \lang\ program.

Similarly, when splitting \bbonem\ terms, first pass evaluation of
$f_1$ should produce the same value as first-stage evaluation of the
original \lang\ term.  However, complexity arises because
\bbonem\ terms may also contain computations to be evaluated in the
second stage. (For example, a \bbonem\ term of type $\fut \rmint$
results in an \rmint\ value in the second stage.) Thus we also want
the second pass evaluation of $f_2$ on the outputs of $f_1$ to yield
the same value as fully evaluating all second-stage computations in
the original \bbonem\ term. Finally, when splitting \bbonep\ terms,
which only produce values in the first stage, we only need to compare
the result of $f_1$ with that of the \lang\ term.

Handling the asymmetry between the results of evaluating
\bbonem\ terms (which may produce results at both the first and second
stage) and \bbtwo\ terms (which only produce second-stage results) is
fundamental to the structure of the splitting algorithm presented in
this section.

\textbf{\bbtwo\ term splitting.}  For any $\coltwo e A$
which reduces to the residual $\exv q$ (via repeated $\stepsym \bbtwo$),
splitting $e$ (via the new relation~$\splittwosym$)
yields a pair of monostaged terms $\pipeS p l r$, where $p$ and $l.r$
contain all first- and second-stage computations in $e$ respectively.

First pass evaluation reduces $p$ to $b$,
which is plugged in for $l$ to produce $[b/l]r$.
Correctness of splitting states that this should be equivalent 
to the residual produced by direct evaluation, $q$.
Since execution of the first pass serves to generate input for
the second pass, we say $p$ is a {\em precomputation} that produces a
{\em boundary value} ($b$) for the {\em resumer} ($l.r$).
More precisely, we can state correctness as \ref{thm:allCorrect}:
\begin{theorem}
\label{thm:allCorrect}
If $e \stepsym \bbtwo \cdots \stepsym \bbtwo \exv q$ and $\splitone e A p {l.r}$,
then $\reduce p b$ and $[b/l]r \equiv q$.
\end{theorem}
where $\reduce e v$ indicates standard monostage reduction of the term $e$ to the value $v$,
and $e_1 \equiv e_2$ indicates a monostage equivalence (defined later).

We prove \ref{thm:allCorrect} by induction on the steps of evaluation.  
In the base case, where $e$ is already a residual of the form $\exv q$, we know
$\splitone {\exv q} A {\exv{\tup{}}} {\_.q}$, and so by uniqueness of splitting, 
$p = b = \tup{}$ and $r = q$.
It directly follows that $\reduce {\exv {\tup {}}} {\tup {}}$ and $q \equiv q$.


\textbf{\bbonem\ term splitting.}  For any $\colmix e A$ which reduces
to $\exv v$ (via repeated $\stepsym \bbonem$), 
splitting $e$ (via the new relation~$\splitonesym$) again 
yields the pair of monostage terms $\pipeM c l r$. 
Evaluating $c$ in the first pass produces the pair
$(i,b)$, where the first element $i$ matches the first-stage results
contained in $v$.  For example, in the simple case where $e$
contains entirely first-stage computation, such as:
\begin{lstlisting}
1` 3`gr{`1`literalone+literaltwo`3`}`
\end{lstlisting}
the first-stage result is the value 3.  The second element of the pair, $b$,
is the boundary value used as input to the resumer in second pass
evaluation as $[b/l]r \equiv q$, where $q$ is the same as
result produced by second-stage computations in $e$.  For example, in
the case where $\rtab \xi v$ contains entirely second-stage
computation, such as:
\begin{lstlisting}
2`[yhat |-> 2+3]`1` next{`2`yhat`1`}`
\end{lstlisting}
the second-stage result is the value 5. Since in general residual
tables and partial values describe a mixture of both first and second
stage computations, in the subsequent subsection we define an
operation, called {\em masking}, that separates residual tables and
partial values into their first- and second-stage results. We then
describe the algorithm for splitting both \bbonem\ terms
($\splitonesym$) and \bbtwo\ terms ($\splittwosym$).


%Since $c$ ensapulates computations that produce both $e$'s first-stage
%result and also the boundary value required by the resumer, we refer
%to it as a {\em combined term}.

%Note that since $\coltwo e A$ reduces to an entirely second-stage
%residual, its first-stage computations only exist to generate input
%for second-stage computations.  In contrast, since $\colmix e A$
%reduces to a multi-stage residual table and partial value, its first
%stage computations serve to both generate the value used as input for
%the second stage {\em and also} produce a first-stage value.
%Correspondingly, the precomputation $p$ resulting from splitting
%\bbtwo\ terms reduces only to a boundary value $b$ which is passed to
%the resumer; but the combined term $c$ resulting from splitting
%\bbonem\ terms reduces to a tuple containing both the first stage {\em
%  immediate result} $i$ and the boundary value $b$ (motivating the
%name {\em combined term}). 

\subsection{Masking}
\label{sec:masking}

%Masking separates residual tables and partial values into first-stage
%results and second stage residuals.

Masking (given by the relation $\vsplito$) converts a residual table $\xi$
and associated partial value $v$ into a masked value $\mval i q$.
%that explicitly separates the first stage components of 
%result from the residual.
%where $i$ is a monostage value encoding all
%first-stage components of the partial value, and $q$ is a monostage
%term encoding all of the second-stage computations of the partial
%value.
The first part of the masked value, $i$, is a monostage value holding
the result of all first-stage components of $v$.  The second
component, $q$, is a residual representing all second-stage
computations in $\xi$ and $v$.

%(A precise definition of masking is
%given in \ref{sec:masking}.)

%Masking is not a transformation performed as part of the splitting
%algorithm.  Instead, masking defines an intuitive notion of the first-stage 
%and second-stage ``components'' of residual tables and partial
%values, and it is used to define the requirements of what output
%splitting of \bbonem\ terms must produce.
To provide intuition about the intent of masking, consider the
following residual table and partial value:
\begin{lstlisting}
2`[yhat |-> 1+2]`1` (next{`2`yhat`1`}, injL (3`gr{`1`7`3`}`, next{`2`yhat`1`}))`
\end{lstlisting}
To construct the value $i$ representing its first-stage components,
masking first redacts all second-stage (blue) parts, along with the
surrounding \texttt{next} annotations. (This redaction removes the
entire residual table since it only represents second-stage
computations.) The resulting ``holes'' in the term are replaced with
unit values.
%\begin{lstlisting}
%4`##########`1` (`4`######`1`, injL (gr{7}, `4`######`1`))`
%\end{lstlisting}
%The holes inside the term needs to be filled with something to convey the lack of information, so we use a unit values:
\begin{lstlisting}
1`((), injL (3`gr{`1`7`3`}`,()))`
\end{lstlisting}
Finally, masking drops \texttt{gr} annotations yielding:
\begin{lstlisting}
1`((), injL (7,()))`
\end{lstlisting}
To construct the residual $q$ (corresponding to second-stage computations) masking first redacts all \texttt{gr} blocks
(replacing them with unit), \texttt{next} annotations, and injection tags:
%\begin{lstlisting}
%2`[yhat |-> 1+2]`1` (`4`####`2`yhat`4`#`1`, `4`####`1` (`4`####`1`,`4`####`2`yhat`4`#`1`))`
%\end{lstlisting}
%Where the \texttt{gr} blocks left a hole, we put in a unit values:
\begin{lstlisting}
2`[yhat |-> 1+2] (yhat, ((),yhat))`
\end{lstlisting}
Then the residual table is reified into \texttt{let} bindings,
yielding:
\begin{lstlisting}
2`let yhat = 1+2 in (yhat, ((),yhat))`
\end{lstlisting}
A precise definition of the masking relation is given in
\ref{fig:valMask}.

%Since lambdas may represent multi-stage computations, masking splits
%the body of lambdas as general world \bbonem\ terms (as described in
%\ref{sec:split-one}), and packages the resulting terms as functions in
%both the first- and second-stage parts of the masked value.

% Masking operates by first inducting on the entries of the residual table.  
% Being purely second-stage content, these are reified into let statements at the top of the resumer.
% Once the table is empty, masking inducts on value itself.

% Masking assigns ground values to the immediate value
% and likewise assigns references into the residual table to the resumer.
% In both cases, the alternate component is assigned to $\tup{}$, to represent trivial information.
% Note that the \texttt{gr} and \texttt{next} annotations are erased.

% Masking distributes into tuples, injections, and rolls, since their subvalues may have content at both stages.
% However, the tags of injections and rolls are replicated only in the immediate value, 
% since they represent first-stage information.

\subsection{Term Splitting at \bbonem}
\label{sec:split-one}

Given the definition of masking, we now describe how to split
\bbonem\ terms. The algorithm, given in \cref{fig:termSplit}, proceeds
recursively on the structure of~$e$. We derive a few cases here.

\paragraph {Unit.} 
As a simple first case, consider splitting the unit value, $\tup{}$
which masks to $\mval {\tup{}} {\tup{}}$.
%Units trivial contain unit split into more units: $\tup{} \vsplito \mval {\tup{}} {\tup{}}$.
Splitting must produce a $c$ and $l.r$ satisfying
\[
	\reduce c {\tup{\tup{},b}} \text{ and } [b/l]r \equiv \tup{}
\]
Our algorithm uses $c=\tup{\tup{},\tup{}}$ and $l.r = \_.\tup{}$.
Splitting $\pure{e}$ follows in similar fashion, except the first 
component of $c$ now becomes the result of evaluating the \bbonep\ term $e$.

\paragraph {Injections.}
Now consider splitting the non-terminal $\inl {e}$, where $\diaone
{e} \xi v$ and $\rtab \xi v \vsplito \mval i q$, and thus:
\[
	\splitone e A c {l.r} \text{ and } \reduce c {\tup{i,b}} \text{ and } [b/l]r \equiv q
\]
Since $\diaone {\inl e} \xi {\inl v}$ and $\rtab \xi {\inl v} \vsplito \mval {\inl i} q$,
splitting must produce a $c'$ and $l.r'$ satisfying
\[
	\reduce {c'} {\tup{\inl i,b'}} \text{ and } [b'/l]r' \equiv q
\]
Our algorithm generates a first pass $c'$ that produces the same
boundary value as splitting $e$:
\[
c' = \letin {\tup {x,y}} c {\tup{\inl x, y}}
\]
Splitting the injection also generates the same resumer as splitting
the subterm $e$ (that is, $l.r' = l.r$).

\paragraph{Tuple.} For an example of splitting terms with more than one argument, consider the tuple $\tup{e_1,e_2}$,
where $\diaone {e_k} {\xi_k} {v_k}$ and 
$\rtab {\xi_k} {v_k} \vsplito \mval {i_k} {q_k}$ for $k = 1,2$.  
Inductively:
\[
	\splitone {e_k} A {c_k} {l_k.r_k} \text{ and } \reduce {c_k} {\tup{i_k,b_k}} \text{ and } [b_k/l_k]r_k \equiv q_k
\]
Since $\diaone {\tup{e_i,e_2}} {\xi_1,\xi_2} {\tup{v_1,v_2}}$ 
and $\rtab {\xi_1,\xi_2} {\tup{v_1,v_2}}$ and $\tup{v_1,v_2} \vsplito \mval {\tup{i_1,i_2}} {\tup{q_1,q_2}}$,
splitting generates:
\[
	\reduce {c} {\tup{\tup{i_1,i_2},b}} \text{ and } [b/l]r \equiv \tup{q_1,q_2}
\]
The resulting boundary value is the tuple of the boundary values of
the subterms, $b = \tup{b_1,b_2}$.  The value is 
constructed using
\[
c = \letin{\tup{y_1,z_1}}{c_1}{\letin{\tup{y_2,z_2}}{c_2}{\tup{\tup{y_1, y_2},\tup{z_1, z_2}}}}
\]
and deconstructed in the resumer with a tuple pattern:
\[
l.r = \tup{l_1,l_2}.\tup{r_1,r_2}
\]
\paragraph {Case.}
Splitting is most complicated at $\caseof {e_1} {x_2.e_2} {x_3.e_3}$ terms because of their divergent control flow.
Here we consider only the case where
$\diaone {e_1} {\xi_1} {\inl {v_1}}$ and \\ $\rtab {\xi_1} {\inl {v_1}} \vsplito \mval {\inl {i_1}} {q_1}$.
(The \texttt{inr} case is analogous.)

\noindent
Inductively,
\[
	\splitone {e_1} A {c_1} {l_1.r_1} \text{ and } \reduce {c_1} {\tup{\inl {i_1},b_1}} \text{ and } [b_1/l_1]r_1 \equiv q_1
\]
Additionally, the first branch evaluates $\diaone {[v_1/x_2]e_2} {\xi_2} {v_2}$
and $\rtab {\xi_1,\xi_2} {v_2} \vsplito \mval {i_2} {q_2}$.
Therefore:
\begin{gather*}
	\splitone {e_2} A {c_2} {l_2.r_2} \text{ and } \reduce {[i_1/x_2]c_2}
  {\tup{i_2,b_2}} \\
\text{ and } [q_1/x_2][b_2/l_2]r_2 \equiv q_2
\end{gather*}
(Because $e_2$ is open on $x_2$, $\pipeM{c_2}{l_2}{r_2}$ is also open on $x_2$.
When we substitute some $v_1$ for $x_2$ in $e_2$, we must substitute the masks
of $v_1$ into $c_2$ and $l_2.r_2$.)

The entire case evaluates as
$\diaone {\caseof {e_1} {x_2.e_2} {x_3.e_3}} {\xi_1,\xi_2} {v_2}$, so splitting should produce 
some $c'$ and
$l'.r'$ such that 
\[
  \reduce {c'} {\tup{i_2,b'}} \text{ and }
  [b'/l']r' \equiv q_2
\]
We choose
\[
c' =
{\left(
\talllet{\tup{y_1,z_1}}{c_1}{
\tallcase{y_1}
{x_2.\letin{\tup{y_2,z_2}}{c_2}{\tup{y_2,\tup{z_1,\inl{z_2}}}}}
{x_3.\cdots\ttrpar}
}\right)}
\]
\[
l'.r' =
\tup{l_1,l_b}.\letin{z}{r_1}{\caseof{l_b}{l_2.[z/x_2]{r_2}}{l_3.\cdots}}
\]
The term $c'$ reduces to
$\tup{i_2,\tup{b_1,\inl{b_2}}}$, so 
$b' = \tup{b_1,\inl{b_2}}$. Therefore
$[b'/l']r'$ reduces to
$[[b_1/l_1]r_1/x_2][b_2/l_2]r_2$, exactly the 
$[q_1/x_2][b_2/l_2]r_2$ required.

More intuitively, $c'$ cases on $i_1$ to run the first branch of first-stage
code. The boundary value for that branch, $b_2$, is packaged as $\tup {b_1, \inl
{b_2}}$. The resumer of the predicate uses $b_1$, and $\inl{b_2}$ signals to run
the first branch's resumer. The second branches of $c'$ and $l'.r'$ are
similarly constrained by the $\texttt{inr}$ case.

%Recovering first stage divergence is easy, since for $\splitone {e_1} ? {c_1} {l_1.r_1}$, 
%$\reduce {e_1} {\inl {v_1}}$ implies $\reduce {c_1} {\tup{\inl {i_1},b_1}}$.

\paragraph {Function.} 
Function introduction has a $\tup{}$ boundary value, since functions
are already fully reduced in our semantics.  However, since the body
of a function may itself be multistage, splitting must descend into
it.  The first pass generated by splitting produces an $i$ that is a new
function formed from the first-stage part of the original body.  The
resumer is a new function formed out of the second-stage part of the
original body.  It is the responsibility of the application site to
save the precomputation of the function body and pass it to the
resumer version of the function.

\subsection{Term Splitting at \bbtwo}

Because world \bbtwo\ terms in \lang\ reduce to monostage residuals
(as opposed to partial values), term splitting at world
\bbtwo\ (specified by the $\splittwosym$ relation in
\cref{fig:termSplit}) is simpler than that of \bbonem.

Consider any $n$-ary \bbtwo-term $e = \scriptCapp {e_1 \ttsemi \ldots
  \ttsemi e_n}$ (except \texttt{prev}, which is discussed shortly).
Note that for any $\diatwo e q$, the residual $q$ must have the form
$\scriptCapp {q_1 \ttsemi \ldots \ttsemi q_n}$, even if $\mathcal{C}$ is
nullary or the $q_i$ have binders.
For each $k$, splitting the subterm $e_k$ yields $p_k$ and $l_k.r_k$ where
\[
	\reduce {p_k} {b_k} \text{ and } [{b_k}/{l_k}]{r_k} \equiv {q_k}
\]
Correspondingly, splitting $\scriptCapp {e_1 \ttsemi \ldots \ttsemi e_n}$ generates $p$ and $l.r$ where
\[
	\reduce p b \text{ and } [b/l]r \equiv \scriptCapp {q_1 \ttsemi \ldots \ttsemi q_n}
\]
Our algorithm accomplishes this by using $p = \tup {p_1, \ldots, p_n}$ and
$l.r = \tup {l_1, \ldots, l_n}.\scriptCapp {r_1 \ttsemi \ldots \ttsemi r_n}$.

%Again, this holds even for nullary terms and under binders.
In particular, $\caseof{e_1}{x_2.e_2}{x_3.e_3}$ splits into:
\[
\pipeS {\tup{p_1,p_2,p_3}} {\tup{l_1,l_2,l_3}} {\caseof{r_1}{x_2.r_2}{x_3.r_3}}
\]
Note how the precomputations of $e_2$ and $e_3$ are pulled out from
underneath the binder into a tuple that is always executed in the
first stage. This occurs regardless of what branch is eventually
executed in the second stage.

\paragraph{Staging constructs.}
Since \texttt{next} and \texttt{prev} do nothing more than convert between 
second-stage terms at \bbtwo\ and encapsulated second-stage terms at \bbonem,
their splitting rules are relatively simple.
Given $\diatwo e q$, splitting yields $p$ and $l.r$ where
\[
	\reduce p b \text{ and } [b/l]r \equiv q
\]
Then for $\diaone {\next {e}} {{\hat y} \mapsto q} {\next {\hat y}}$
and\\ $\rtab {{\hat y} \mapsto q} {\next {\hat y}} \vsplito \mval {\tup{}} {\letin {\hat y} q {\hat y}}$, splitting must produce $c'$ and $l'.r'$ where
\[
	\reduce {c'} {\tup {\tup{},b'}} \text{ and } [b'/l']r' \equiv \letin {\hat y} q {\hat y}
\]
Our algorithm chooses $c' = \tup{\tup{},p}$ and $l'.r' = l.r$.
Applying this process in reverse yields a splitting rule for $\prev e$ which applies \texttt{pi1} to the combined term of $e$.

\subsection {Role of World \bbonep}
\label{sec:needGround}

The splitting algorithm described in the previous subsections operates
purely on the local structure of \lang\ terms.  One artifact of this design
is that splitting \bbonem\ terms may generate resumers containing
unnecessary logic.  For example, the rule for splitting
\bbonem\ \texttt{case} terms inserts the tag from the \texttt{case}
argument into the boundary value, then decodes this tag in the
resumer. This logic occurs regardless of whether the terms forming the
branches of the \texttt{case} contain second-stage computations.
Worse, if this \texttt{case} appeared in the body of a recursive
function with no other second-stage computations, splitting would
generate a resumer with (useless) recursive calls.

Rather than attempt global optimization of the outputs of splitting,
we instead leverage the type system to indicate when a term contains
no second-stage computations by adding a third world \bbonep\ whose
terms are purely first-stage.  While not necessary for ordinary staged
term evaluation (\ref{sec:stagedsemantics}), this annotation is
particularly useful for splitting. Specifically, splitting $\pure e$
terms trivially yields a unit resumer.

The \texttt{partition} function in the quickselect example in
\ref{sec:exampleQS} is an example of such a function that contains no
second-stage computations, but, if not defined within a $\pure$
annotation, would cause splitting to generate a recursive resumer.

\end{abstrsyn}

\input{figures/splitting-misc}
\input{figures/splitting-term}
