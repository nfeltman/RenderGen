%!TEX root = paper.tex
 \section{Examples of Splitting}
\label{sec:examples}

Now we investigate the behavior of our splitting algorithm on several examples.
While our splitting algorithm does not yield typed output terms, in practice we
find it possible to assign types to many such outputs. In the examples that
follow, for the sake of readability, we have manually added type annotations and
performed some minor optimizations.

\subsection{Dot Product}

Our first example takes the dot product of two three-dimensional integer
vectors, where the first two coordinates are first-stage, and the last
coordinate is second-stage. \texttt{dot} is a first-order, non-recursive
function---precisely the sort of code studied in prior work on pass separation
for imperative languages. (A very similar example appears in \cite{knoblock96}.)
%
\begin{lstlisting} 
1`type vec = ^int * ^int * $`2`int`

1`//dot : vec * vec -> $int
fun dot (
  (3`grnd{`1`x1`3`}`1`,`3`grnd{`1`y1`3`}`1`,next{`2`z1`1`}): vec,
  (3`grnd{`1`x2`3`}`1`,`3`grnd{`1`y2`3`}`1`,next{`2`z2`1`}): vec) = 
next{
  2`prev{`1`hold `3`grnd{`1`(x1*x2) + (y1*y2)`3`}`2`} + (z1*z2)`
1`}`
\end{lstlisting}
%
The body of \texttt{dot} is a \rmint{} term at world \bbtwo\ containing a
\rmint\ computation of \texttt{(x1*x2) + (y1*y2)} which is promoted from world
\bbonep\ to world \bbtwo. We would expect the first stage of the split program
to take the first two coordinates of each vector and perform that first-stage
computation; and the second stage to take the final coordinates and the result
of the first stage, then multiply and add.

Our algorithm splits \texttt{dot} into the two functions:
%
\begin{lstlisting} 
1`fun dot1 ((x1,y1,()),(x2,y2,())) 
  = ((), (x1*x2)+(y1*y2))`

2`fun dot2 ((((),(),z1),((),(),z2)),l) 
  = l+(z1*z2)`
\end{lstlisting}
%
As expected, \texttt{dot1} returns \texttt{(x1*x2)+(y1*y2)} as the
precomputation, and \texttt{dot2} adds that precomputation to the products of
the final coordinates. This is exactly what is done in \cite{knoblock96}, except
that they write the precomputation into a mutable cache.

\subsection{Exponentiation by Squaring}

\crem{work in progress}

Our next example computes $b^e$ using exponentiation by squaring, where $e$ is
known at the first stage, and $b$ is known at the second stage. This is a common
example in the partial evaluation literature.
%
\begin{lstlisting} 
fun exp (b : $int , grnd{e} : ^int) = 
  if grnd{e == 0} then 
    next{1} 
  else if grnd {(e mod 2) == 0} then
    exp(next{prev{b}*prev{b}},grnd{e/2})
  else 
    next{prev{b} * prev{exp(b,grnd{e-1})}}
\end{lstlisting}
%
Our algorithm splits \texttt{exp} into the two functions:
%
\begin{lstlisting} 
datatype nat = Zero | Even of nat | Odd of nat

fun exp1 (b : unit, e : int) =
  if e==0 then
    ((), Zero)
  else if (e mod 2)==0 then 
    ((), Even (#2 (exp1 ((), e/2))))
  else 
    ((), Odd (#2 (exp1 (b, e-1))))

fun exp2 ((b : int, e : unit), l : nat) = 
    case l of
      Zero => 1
    | Even n => exp2 ((b*b, ()), n)
    | Odd n => b * exp2 ((b, ()), n)
\end{lstlisting}
%
Because \texttt{exp} is a recursive function whose conditionals depend only on
$e$, partial evaluation fully unrolls the conditionals depending on the binary
representation of $e$. Our algorithm, on the other hand, creates a data
structure which communicates to the second-stage function which conditionals
should be taken.

Splitting has produced two recursive functions,
one (\texttt{exp1}) which builds up an intermediate data structure (\texttt{nat}),
and another (\texttt{exp2}) which consumes that data structure.  
Noticing that said structure is just a binary representation of the exponent,
we've given it an appropriate name.

This may seem like a deep observation, 
that integers can be decomposed into a binary respresation,
but it actually follows from the recursive structure of the original program:
just as \texttt{exp} could either terminate or recur in one of two ways,
\texttt{nat} likewise has a base case and two recursive cases.
Splitting oberves this only by following local structure.

Of course, since integers are usually stored in a binary format anyway, 
this isn't practically useful, but it's a clear exposition of the technique.
Partially evaluating this code is typically more useful,
as that would eliminate branches in the residual,
and exponents tend to be small enough to keep code size reasonable.

\subsection{Quickselect}

We now move on to our marquee example: quickselect.
The function {\tt qs} in the code below is a staged version of the quickselect algorithm.
Standard quickselect finds the $k$th largest number in a list (l) by recursively partitioning the list by its 
first element and picking the side which contains the $k$th largest element.
In this case, we've staged quickselect by saying that the list is stage \bbone\ and $k$ is stage \bbtwo.
The helper function {\tt partition} operates entirely in stage \bbone, and so we have wrapped it in a \texttt{grnd}.
In this example, we make use of the behavior where first stage code is executed even under second stage branches.

\begin{lstlisting} 
atsigngrnd { 
  datatype list = Empty | Cons of int * list
  fun partition ((p,l) : int*list) : (int*list*list) = 
    case unroll l of 
      Empty => (0, Empty, Empty) 
    | Cons (h,t) => 
      let val (s,left,right) = partition (p,t) in 
      if h<p 
      then (s+1,Cons(h,left),right) 
      else (s,left,Cons(h,right))
}

fun qs (grnd{Empty}, next{i}) = next {0} 
  | qs (grnd{Cons ht}, next{i}) =
    let 
      val grnd{(n,left,right)} = grnd{partition ht}
      val next{n} = hold grnd{n}
    in
    next { 
      case unroll (compare (i,n)) of
        LT => prev{qs (grnd{left},next{i})}
      | EQ => prev{hold grnd{#1 ht}}
      | GT => prev{qs (grnd{right},next{i-n-1})}
    }
\end{lstlisting}
Running stage splitting on this code produces:
\begin{lstlisting} 
datatype list = Empty | Cons of int * list
datatype tree = Leaf of unit 
              | Branch of int * tree * int * tree
fun partition ((p,l) : int*list) : (int*list*list) = 
  case l of 
    Empty => (0,Empty, Empty) 
  | Cons (h,t) => 
    let val (s,left,right) = partition (p,t) in 
    if h<p 
    then (s+1,Cons(h,left),right) 
    else (s,left,Cons(h,right))

fun qs1 (l : list, i : int) = ((), 
  case l of
    Empty => Leaf ()
  | Cons (h,t) => 
      Branch (
        let (left,right,n) = partition h t in
        (n, #2 (qs1 left i), h, #2 (qs1 right i))
      )
  )

fun qs2 (((), i : int), p : tree) = 
  case p of
    Leaf () => 0
  | Branch (n,left,h,right) =>
        case compare (i, n) of 
          LT => qs (((), i), left) 
        | EQ => h 
        | GT => qs (((), i-n-1), right)

\end{lstlisting}

These functions recursively build ({\tt qs\_1}) and then search ({\tt qs\_2}) a binary tree,
which stores a set element and subtree size at every branch.
All of the list partitioning work now occurs within the precomputation.
Thus, {\tt qs\_1} performs $\Theta(n \log n)$ work per call, whereas {\tt qs\_2} performs expected $\Theta(\log n)$ work.
This results in a net speedup over standard quickselect if we perform $\Omega(n / \log n)$ queries on the same list. 

\crem{Nico: add something here about the importance of ground}

\subsection {Mixed Map Combinator}

In the previous example, we suggested that staged quickselect could be applied to one list and many queries.
In this example, we implement that behavior by passing \texttt{qs} to a higher order function.
Such a combinator, which operates over both stages at once, is possible because of the generality of \lang's abstractions.

Note that we have to define a datatype for integer lists at the second stage, which is given by \texttt{list2}.
\begin{lstlisting} 
atsignnext{
  datatype list2 = Empty2 | Cons2 of int * list2
}

type qsType = ^list*$int->$int

// map : qsType -> ^list * $list2 -> $list2
fun map f (l, q) = 
next {
  let 
  fun m Empty2 = Empty2
    | m (Cons2(h,t)) = Cons2(prev{f (l,next{h})}, m t)
  in m prev{q}
}

val qsMany = map qs
\end{lstlisting}
The \texttt{map} function splits into the following two functions:
\begin{lstlisting} 
datatype list2 = Empty2 | Cons2 of int * list2

fun map1 f = (fn (l,()) => ((), #2 (f (l, ()))), ())
fun map2 (f,()) ((l,q), p : tree) =
  let 
  fun m Empty2 = Empty2
    | m (Cons2(h,t)) = Cons2(f ((l,h), p), m t) 
  in m q
\end{lstlisting}

As desired, \texttt{qs1} (which is passed to \texttt{map1} via variable \texttt{f}) is executed only once per invocation of \texttt{map},
whereas \texttt{qs2} (which is passed to \texttt{map2} via variable \texttt{f}) is executed once per query.
