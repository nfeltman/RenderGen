

\section{Examples of Algorithm Derivation}
\label{sec:examples}

In this section, I show a few example of how splitting can be used to derive
standard data structures a relatively simple multistage code.

Pay attention to how partial evaluation (essentially our semantics) and splitting compare for these examples.
The main difference to note is that where splitting creates an explicit data structure, partial evaluation will
essentially embed that datastructure in the residual. 

\subsection{Fast Exponent}

Here is a staged version of fast-exponent.
\begin{lstlisting} 
fun fexp (b : $int, e : int) : $int =
	if e == 0 then
		next{1}
	else if (e mod 2) == 0 then
		next{let x = prev{fexp(b,e/2)} in x*x}
	else
		next{prev{b} * prev{fexp (b,e-1)}}		
\end{lstlisting}
It splits into
\begin{lstlisting} 
fun fexp (b, e) =
  ((), roll (
    if e == 0 then inj1 ()
    else
      inj2 (
        if (e mod 2) == 0
        then inj1 (#2 (fexp (b,e/2)))
        else inj2 (#2 (fexp (b,e-1)))
      )
  ))
\end{lstlisting}
and
\begin{lstlisting} 
fun fexp ((b, e), p) =
	case unroll p of
	  inj1 () => 1
	| inj2 d =>
		case d of
		  inj1 r => let x = fexp ((b,()),r) in x*x
		| inj2 r => b * fexp ((b,()),r)
\end{lstlisting}

Although split programs are not typed, we'll recognize the intermediate data structure 
above as being as isomorphic to the recursive datatype definitions:
\begin{lstlisting} 
datatype binaryList = Empty 
                      | NotEmpty of neList
withtype neList = Zero of binaryList 
                  | One of binaryList
\end{lstlisting}
Which is all to say that the split code precomputes a binary representation of the exponent.

Splitting this code produces interesting results, but partial evaluation is probably more effective,
given that exponents are often not that large.

\subsection{Quickselect}

Here we have a staged version of quickselect.
\begin{lstlisting} 
datatype list = Empty | Cons of int * list
fun partition ((p,l) : int*list) : (int*list*list) =
  case unroll l of 
    Empty => (0,Empty, Empty) 
  | Cons (h,t) =>
      let (s,left,right) = partition (p,t) in
      if h<p 
      then (s+1,Cons(h,left),right)
      else (s,left,Cons(h,right))
fun qs (l : list, i: $int) = 
  case l of
    Empty => next {0}
  | Cons (h,t) => 
      let (left,right,n) = partition h t in
      next{
        let n = hold{n} in
          case compare prev{i} n of
            LT => prev {qs left i}
          | EQ => hold {h}
          | GT => prev {qs right next{prev{i}-n-1}}
      }	
\end{lstlisting}
It splits into
\begin{lstlisting} 
datatype _ = Empty | Cons of _
fun partition (p,l) =
  case unroll l of 
    Empty => (0,Empty, Empty) 
  | Cons (h,t) =>
      let (s,left,right) = partition (p,t) in
      if h<p 
      then (s+1,Cons(h,left),right)
      else (s,left,Cons(h,right))
fun qs (l, i) = roll((), 
  case l of
    Empty => inj1 ()
  | Cons (h,t) => 
      inj2 (
        let (left,right,n) = partition h t in
        (n, #2 (qs left i), h, #2 (qs right i))
      )
  )
\end{lstlisting}
and 
\begin{lstlisting} 
datatype _ = Empty | Cons of _
fun qs ((l, i), p) = 
  case unroll p of
    inj1 () => 0
  | inj2 (n,p1,h,p2) => 
      next{
        let n = hold{n} in
          case compare prev{i} n of
            LT => prev {qs left i}
          | EQ => hold {h}
          | GT => prev {qs right next{prev{i}-n-1}}
      }	
\end{lstlisting}
There are a few things to note:
\begin{itemize}
\item Outputs are untyped.  Rather than elaborate out the datatypes, I keep them in and just null out the types.
\item I made a huge simplification here.  The partition function doesn't have any real stage two computation,
but that won't stop the current algorithm from keeping track of all the recursive calls and retracing all of its
steps in stage-\bbtwo.
\end{itemize}

\subsection{Trie}

\begin{lstlisting} 
datatype letter = A | B | C
datatype string = EmptyS | ConsS of letter * string
datatype list = EmptyL | ConsL of string * list
fun partition (l : list) : (bool * list * list * list) =
  case l of
    EmptyL => (false,EmptyL,EmptyL,EmptyL)
  | ConsL (s,ss) =>
      let (anyEmpty,a,b,c) = partition ss in
      case unroll s of
        EmptyS => (true,a,b,c)
      | ConsS (z,zs) =>
          case z of 
            A => (anyEmpty, ConsL(zs,a), b, c) 
          | B => (anyEmpty, a, ConsL(zs,b), c) 
          | C => (anyEmpty, a, b, ConsL(zs, c))
fun exists ((l,s) : list * $string) : $bool =
  case l of 
    EmptyL => next{false} 
  | ConsL _ => 
    let (anyEmpty, a, b, c) = partition l in
    next {
      case prev{s} of
        EmptyS => prev{
          if anyEmpty then next{true} else next{false}
          }
      | ConsS (z,zs) =>
          case unroll z of
            A => prev{exists (a,next{zs})}
          | B => prev{exists (b,next{zs})} 
          | C => prev{exists (c,next{zs})}
    }
\end{lstlisting}

splits into

(coming...)

