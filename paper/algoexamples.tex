%!TEX root = paper.tex

\section{Examples of Algorithm Derivation}
\label{sec:examples}

We investigate the behavior of our splitting algorithm on several examples.

\subsection{Fast Exponent}

Here is a staged version of the fast-exponent example.
\begin{lstlisting} 
fun exp (b : $int , e : int) = 
  if e == 0 then 
    next{1} 
  else if (e mod 2) == 0 then
    next{let val x = prev{exp (b,e/2)} in x*x} 
  else 
    next{prev{b} * prev{exp (b,e-1)}}
\end{lstlisting}

\noindent
{\tt fexp} splits into the following two functions:

\begin{lstlisting} 
datatype nat = Zero | Even of nat | Odd of nat

fun exp1 (b : unit, e : int) =
  if e==0 then
    ((), Zero)
  else if (e mod 2)==0 then 
    ((), Even (#2 (exp (b, e/2))))
  else 
    ((), Odd (#2 (exp (b, e-1))))

fun exp2 ((b : int, e : unit), l : nat) = 
    case l of
      Zero => 1
    | Even n => let x = exp ((b, ()), n) in x*x 
    | Odd n => b * exp ((b, ()), n)
\end{lstlisting}

Which is all to say that the split code precomputes a binary representation of the exponent.
Since integers are usually stored in a binary format anyways, this isn't practically useful,
but it's still an interesting exposition of the technique.

Partially evaluating the code here might actually be useful, since the residual wouldn't have branches,
and exponents tend to be small enough that the code size would be reasonable.

\subsection{Quickselect}

\crem{Revise to take section 2 into account.}

We have observed that stage splitting can be used to transform \lang\ programs into two step algorithms where the precomputation generates a data-structure, and the residual uses the precomputed structure to accelerate repeated computation.  

The function {\tt qs} in the code below is a staged version of the quickselect algorithm.
Standard quickselect finds the $i$th largest number in a list (l) by recursively partitioning the list by its 
first element and picking the side which contains the $i$th largest element.
In this case, we've staged quickselect by saying that the list is stage \bbone\ and $i$ is stage \bbtwo.
The helper function {\tt partition} operates entirely in stage \bbone, and so we have wrapped it in a \texttt{grnd}.

\begin{lstlisting} 
atsigngrnd { 
  datatype list = Empty | Cons of int * list
  fun partition ((p,l) : int*list) : (int*list*list) = 
    case unroll l of 
      Empty => (0, Empty, Empty) 
    | Cons (h,t) => 
      let val (s,left,right) = partition (p,t) in 
      if h<p 
      then (s+1,Cons(h,left),right) 
      else (s,left,Cons(h,right))
}

fun qs (grnd{Empty}, next{i}) = next {0} 
  | qs (grnd{Cons ht}, next{i}) =
    let 
      val grnd{(n,left,right)} = grnd{partition ht}
      val next{n} = hold grnd{n}
    in
    next { 
      case unroll (compare (i,n)) of
        LT => prev{qs (grnd{left},next{i})}
      | EQ => prev{hold grnd{#1 ht}}
      | GT => prev{qs (grnd{right},next{i-n-1})}
    }
\end{lstlisting}

\noindent
Running stage splitting on this code produces:

\begin{lstlisting} 
datatype list = Empty | Cons of int * list
datatype tree = Leaf of unit 
              | Branch of int * tree * int * tree
fun partition ((p,l) : int*list) : (int*list*list) = 
  case l of 
    Empty => (0,Empty, Empty) 
  | Cons (h,t) => 
    let val (s,left,right) = partition (p,t) in 
    if h<p 
    then (s+1,Cons(h,left),right) 
    else (s,left,Cons(h,right))

fun qs1 (l : list, i : int) = ((), 
  case l of
    Empty => Leaf ()
  | Cons (h,t) => 
      Branch (
        let (left,right,n) = partition h t in
        (n, #2 (qs1 left i), h, #2 (qs1 right i))
      )
  )

fun qs2 (((), i : int), p : tree) = 
  case p of
    Leaf () => 0
  | Branch (n,left,h,right) =>
        case compare (i, n) of 
          LT => qs (((), i), left) 
        | EQ => h 
        | GT => qs (((), i-n-1), right)

\end{lstlisting}

These functions recursively build ({\tt qs\_1} and then search ({\tt qs\_2}) a binary tree,
which stores a set element and subtree size at every branch.
All of the list partitioning work now occurs within the precomputation.

Partial evaluation creates a giant tree of if statements proportional to the size of the list,
whereas splitting just creates the tree out of values, and then interprets it in the residual.
For large input lists (which is typical), this saves a lot on memory.

This works well because quickselect does a lot of work at stage one that can be amortized across all of stage two.

Also, the behavior where we lift precomputations out from branches is very important.

\subsection {Mixed Map Combinator}

Because \lang\ is so general, we can write combinators which effectively operate over {\em both stages at once}.

\begin{lstlisting} 
fun map (f:^list*$int->$int, l:^list, q:$list2) = 
next {
  let 
  fun m Empty2 = Empty2
    | m (Cons2 (h,t)) = Cons2 (prev{f (l,next{h})}, m t)
  in m prev{q}
}
\end{lstlisting}

\noindent
{\tt map} splits into the following two functions:

\begin{lstlisting} 

fun map1 (f,l,()) = ((), #2 (f (l, ())))

fun map2 ((f,l,q), b : tree) = 
let fun m q_0 =
  case q_0 of 
    Empty2 => Empty2 
  | Cons2 (h,t) => Cons2 (f ((l, h), b), m t)
in m q
\end{lstlisting}