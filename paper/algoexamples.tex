

\section{Examples of Algorithm Derivation}
\label{sec:examples}

In this section, I show a few example of how splitting can be used to derive
standard data structures a relatively simple multistage code.

\subsection{Fast Exponent}

Fast exponent example.  

\begin{lstlisting} 
fun fexp (b : $int, e : int) : $int =
	if e == 0 then
		next{1}
	else if (e mod 2) == 0 then
		next{let x = prev{fexp(b,e/2)} in x*x}
	else
		next{prev{b} * prev{fexp (b,e-1)}}		
\end{lstlisting}

splits into

\begin{lstlisting} 
fun fexp (b, e) =
  ((), roll (
    if e == 0 then inj1 ()
    else
      inj2 (
        if (e mod 2) == 0
        then inj1 (#2 (fexp (b,e/2)))
        else inj2 (#2 (fexp (b,e-1)))
      )
  ))
\end{lstlisting}

and

\begin{lstlisting} 
fun fexp ((b, e), p) =
	case unroll p of
	  inj1 () => 1
	| inj2 d =>
		case d of
		  inj1 r => let x = fexp ((b,()),r) in x*x
		| inj2 r => b * fexp ((b,()),r)
\end{lstlisting}

\subsection{Quickselect}

\begin{lstlisting} 
datatype list = Empty | Cons of int * list
fun partition ((p,l) : int*list) : (int*list*list) =
  case unroll l of 
    Empty => (0,Empty, Empty) 
  | Cons (h,t) =>
      let (s,left,right) = partition (p,t) in
      if h<p 
      then (s+1,Cons(h,left),right)
      else (s,left,Cons(h,right))
fun qs (l : list, i: $int) = 
  case l of
    Empty => next {0}
  | Cons (h,t) => 
      let (left,right,n) = partition h t in
      next{
        let n = hold{n} in
          case compare prev{i} n of
            LT => prev {qs left i}
          | EQ => hold {h}
          | GT => prev {qs right next{prev{i}-n-1}}
      }	
\end{lstlisting}

splits into

\begin{lstlisting} 
datatype _ = Empty | Cons of _
fun partition (p,l) =
  case unroll l of 
    Empty => (0,Empty, Empty) 
  | Cons (h,t) =>
      let (s,left,right) = partition (p,t) in
      if h<p 
      then (s+1,Cons(h,left),right)
      else (s,left,Cons(h,right))
fun qs (l, i) = roll((), 
  case l of
    Empty => inj1 ()
  | Cons (h,t) => 
      inj2 (
        let (left,right,n) = partition h t in
        (n, #2 (qs left i), h, #2 (qs right i))
      )
  )
\end{lstlisting}

and 

\begin{lstlisting} 
datatype _ = Empty | Cons of _
fun qs ((l, i), p) = 
  case unroll p of
    inj1 () => 0
  | inj2 (n,p1,h,p2) => 
      next{
        let n = hold{n} in
          case compare prev{i} n of
            LT => prev {qs left i}
          | EQ => hold {h}
          | GT => prev {qs right next{prev{i}-n-1}}
      }	
\end{lstlisting}

There are a few things to note:
\begin{itemize}
\item Outputs are untyped.  Rather than elaborate out the datatypes, I keep them in and just null out the types.
\item I made a huge simplification here.  The partition function doesn't have any real stage two computation,
but that won't stop the current algorithm from keeping track of all the recursive calls and retracing all of its
steps in stage-\bbtwo.
\end{itemize}



\subsection{Trie}

\begin{lstlisting} 
datatype letter = A | B | C
datatype string = EmptyS | ConsS of letter * string
datatype list = EmptyL | ConsL of string * list
fun partition (l : list) : (bool * list * list * list) =
  case l of
    EmptyL => (false,EmptyL,EmptyL,EmptyL)
  | ConsL (s,ss) =>
      let (anyEmpty,a,b,c) = partition ss in
      case unroll s of
        EmptyS => (true,a,b,c)
      | ConsS (z,zs) =>
          case z of 
            A => (anyEmpty, ConsL(zs,a), b, c) 
          | B => (anyEmpty, a, ConsL(zs,b), c) 
          | C => (anyEmpty, a, b, ConsL(zs, c))
fun exists ((l,s) : list * $string) : $bool =
  case l of 
    EmptyL => next{false} 
  | ConsL _ => 
    let (anyEmpty, a, b, c) = partition l in
    next {
      case prev{s} of
        EmptyS => prev{
          if anyEmpty then next{true} else next{false}
          }
      | ConsS (z,zs) =>
          case unroll z of
            A => prev{exists (a,next{zs})}
          | B => prev{exists (b,next{zs})} 
          | C => prev{exists (c,next{zs})}
    }
\end{lstlisting}

splits into

(coming...)

\subsection {Partial Evaluation vs. Splitting}

Lets consider how partial evaluation (essentially our semantics) and splitting compare for these examples.
