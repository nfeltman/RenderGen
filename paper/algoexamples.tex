%!TEX root = paper.tex
 \section{Examples of Algorithm Derivation}
\label{sec:examples}

We investigate the behavior of our splitting algorithm on several examples.
While our splitting algorithm does not produce typed output terms,
we find that in practice there do exist valid type annotation for small examples.
For the sake of readability in presenting the output of our splitting algorithm,
we take this liberty along with other minor clean-up and inverse-elaboration.

\subsection{Dot Product}

Our first example concerns the dot product of (integer) 3-vectors where 
the first two coordinates are known at the first stage and the 
third coordinate is known at the second stage.
The result is an integer at the second stage.
This example, largely lifted from \cite{knoblock96}, requires only straight-line code:
\begin{lstlisting} 
type vec = ^int * ^int * $int

// dot : vec * vec -> $int
fun dot (
  (grnd{x1},grnd{y1},next{z1}): vec, 
  (grnd{x2},grnd{y2},next{z2}): vec) = 
next{
  prev{hold grnd{(x1*x2) + (y1*y2)}} + (z1*z2)
}
\end{lstlisting}
The \texttt{dot} function splits into the two functions:
\begin{lstlisting} 

fun dot1 ((x1,y1,()),(x2,y2,())) 
  = ((), (x1*x2)+(y1*y2))

fun dot2 ((((),(),z1),((),(),z2)),l) 
  = l+(z1*z2)
\end{lstlisting}
Here, \texttt{dot1} calculates the products and sum on the first two coordinates and returns it as the precomputation,
then \texttt{dot2} adds that precompuation to the product of the last coordinate.

\subsection{Fast Exponent}

We next consider an example with recursion.
Here, the \texttt{exp} function calculates the exponent $b^e$
by considering three cases for $e$: zero, even (but not zero), and odd.
We stage the function by saying that the exponent is known at the first stage,
but the base is known at the second stage.
The result is an integer at the second stage.
\begin{lstlisting} 
fun exp (b : $int , e : int) = 
  if e == 0 then 
    next{1} 
  else if (e mod 2) == 0 then
    next{let val x = prev{exp (b,e/2)} in x*x} 
  else 
    next{prev{b} * prev{exp (b,e-1)}}
\end{lstlisting}
\noindent
From this, splitting creates the following two functions:
\begin{lstlisting} 
datatype nat = Zero | Even of nat | Odd of nat

fun exp1 (b : unit, e : int) =
  if e==0 then
    ((), Zero)
  else if (e mod 2)==0 then 
    ((), Even (#2 (exp (b, e/2))))
  else 
    ((), Odd (#2 (exp (b, e-1))))

fun exp2 ((b : int, e : unit), l : nat) = 
    case l of
      Zero => 1
    | Even n => let x = exp ((b, ()), n) in x*x 
    | Odd n => b * exp ((b, ()), n)
\end{lstlisting}
Splitting has produced two recursive functions,
one (\texttt{exp1}) which builds up an intermediate data structure (\texttt{nat}),
and another (\texttt{exp2}) which consumes that data structure.  
Noticing that said structure is just a binary representation of the exponent,
we've given it an appropriate name.

This may seem like a deep observation, 
that integers can be decomposed into a binary respresation,
but it actually follows from the recursive structure of the original program:
just as \texttt{exp} could either terminate or recur in one of two ways,
\texttt{nat} likewise has a base case and two recursive cases.
Splitting oberves this only by following local structure.

Of course, since integers are usually stored in a binary format anyway, 
this isn't practically useful, but it's a clear exposition of the technique.
Partially evaluating this code is typically more useful,
as that would eliminate branches in the residual,
and exponents tend to be small enough to keep code size reasonable.

\subsection{Quickselect}

\crem{Revise to take section 2 into account.}

We now move on to our marquee example: quickselect.
The function {\tt qs} in the code below is a staged version of the quickselect algorithm.
Standard quickselect finds the $k$th largest number in a list (l) by recursively partitioning the list by its 
first element and picking the side which contains the $k$th largest element.
In this case, we've staged quickselect by saying that the list is stage \bbone\ and $k$ is stage \bbtwo.
The helper function {\tt partition} operates entirely in stage \bbone, and so we have wrapped it in a \texttt{grnd}.
In this example, we make use of the behavior where first stage code is executed even under second stage branches.

\begin{lstlisting} 
atsigngrnd { 
  datatype list = Empty | Cons of int * list
  fun partition ((p,l) : int*list) : (int*list*list) = 
    case unroll l of 
      Empty => (0, Empty, Empty) 
    | Cons (h,t) => 
      let val (s,left,right) = partition (p,t) in 
      if h<p 
      then (s+1,Cons(h,left),right) 
      else (s,left,Cons(h,right))
}

fun qs (grnd{Empty}, next{i}) = next {0} 
  | qs (grnd{Cons ht}, next{i}) =
    let 
      val grnd{(n,left,right)} = grnd{partition ht}
      val next{n} = hold grnd{n}
    in
    next { 
      case unroll (compare (i,n)) of
        LT => prev{qs (grnd{left},next{i})}
      | EQ => prev{hold grnd{#1 ht}}
      | GT => prev{qs (grnd{right},next{i-n-1})}
    }
\end{lstlisting}
Running stage splitting on this code produces:
\begin{lstlisting} 
datatype list = Empty | Cons of int * list
datatype tree = Leaf of unit 
              | Branch of int * tree * int * tree
fun partition ((p,l) : int*list) : (int*list*list) = 
  case l of 
    Empty => (0,Empty, Empty) 
  | Cons (h,t) => 
    let val (s,left,right) = partition (p,t) in 
    if h<p 
    then (s+1,Cons(h,left),right) 
    else (s,left,Cons(h,right))

fun qs1 (l : list, i : int) = ((), 
  case l of
    Empty => Leaf ()
  | Cons (h,t) => 
      Branch (
        let (left,right,n) = partition h t in
        (n, #2 (qs1 left i), h, #2 (qs1 right i))
      )
  )

fun qs2 (((), i : int), p : tree) = 
  case p of
    Leaf () => 0
  | Branch (n,left,h,right) =>
        case compare (i, n) of 
          LT => qs (((), i), left) 
        | EQ => h 
        | GT => qs (((), i-n-1), right)

\end{lstlisting}

These functions recursively build ({\tt qs\_1}) and then search ({\tt qs\_2}) a binary tree,
which stores a set element and subtree size at every branch.
All of the list partitioning work now occurs within the precomputation.
Thus, {\tt qs\_1} performs $\Theta(n \log n)$ work per call, whereas {\tt qs\_2} performs expected $\Theta(\log n)$ work.
This results in a net speedup over standard quickselect if we perform $\Omega(n / \log n)$ queries on the same list. 

\subsection {Mixed Map Combinator}

In the previous example, we suggested that staged quickselect could be applied to one list and many queries.
In this example, we implement that behavior by passing \texttt{qs} to a higher order function.
Such a combinator, which operates over both stages at once, is possible because of the generality of \lang's abstractions.

Note that we have to define a datatype for integer lists at the second stage, which is given by \texttt{list2}.
\begin{lstlisting} 
atsignnext{
  datatype list2 = Empty2 | Cons2 of int * list2
}

type qsType = ^list*$int->$int

// map : qsType -> ^list * $list2 -> $list2
fun map f (l, q) = 
next {
  let 
  fun m Empty2 = Empty2
    | m (Cons2(h,t)) = Cons2(prev{f (l,next{h})}, m t)
  in m prev{q}
}

val qsMany = map qs
\end{lstlisting}
The \texttt{map} function splits into the following two functions:
\begin{lstlisting} 
datatype list2 = Empty2 | Cons2 of int * list2

fun map1 f = (fn (l,()) => ((), #2 (f (l, ()))), ())
fun map2 (f,()) ((l,q), p : tree) =
  let 
  fun m Empty2 = Empty2
    | m (Cons2(h,t)) = Cons2(f ((l,h), p), m t) 
  in m q
\end{lstlisting}

As desired, \texttt{qs1} (which is passed to \texttt{map1} via variable \texttt{f}) is executed only once per invocation of \texttt{map},
whereas \texttt{qs2} (which is passed to \texttt{map2} via variable \texttt{f}) is executed once per query.